#!/usr/bin/env bash
# ==============================================================================
# Mock ACP Server for testing - NDJSON protocol
# ==============================================================================
# Minimal ACP-compatible server that:
# - Responds to initialize with protocol version
# - Creates sessions with sequential IDs
# - Echoes prompts back as session/update notifications
# - Supports session/end
#
# Environment Variables:
#   MOCK_ACP_DELAY_MS=<ms>  - Add artificial delay to responses (testing)
#   MOCK_ACP_ERROR=<method> - Return error for specified method
# ==============================================================================

set -euo pipefail

session_counter=0

# Log to stderr only (stdout is for protocol)
log() {
    printf '[mock-acp-server] %s\n' "$*" >&2
}

# Write NDJSON response to stdout
respond() {
    printf '%s\n' "$1"
}

# Optional delay for testing concurrency
maybe_delay() {
    if [[ -n "${MOCK_ACP_DELAY_MS:-}" ]]; then
        sleep "$(printf '0.%03d' "$MOCK_ACP_DELAY_MS")" 2>/dev/null || true
    fi
}

log "Starting mock ACP server"

while IFS= read -r line; do
    [[ -z "$line" ]] && continue

    # Parse JSON using jq
    local_method=$(printf '%s' "$line" | jq -r '.method // empty')
    local_id=$(printf '%s' "$line" | jq -r '.id // empty')

    log "Received: method=$local_method id=$local_id"

    # Check for forced error
    if [[ "${MOCK_ACP_ERROR:-}" == "$local_method" ]]; then
        log "Forcing error for method: $local_method"
        respond "{\"jsonrpc\":\"2.0\",\"id\":\"$local_id\",\"error\":{\"code\":-32000,\"message\":\"Forced error for testing\"}}"
        continue
    fi

    maybe_delay

    case "$local_method" in
        initialize)
            local_version=$(printf '%s' "$line" | jq -r '.params.protocolVersion // "2025-01-01"')
            respond "{\"jsonrpc\":\"2.0\",\"id\":\"$local_id\",\"result\":{\"protocolVersion\":\"$local_version\",\"capabilities\":{},\"serverInfo\":{\"name\":\"mock-acp-server\",\"version\":\"0.1.0\"}}}"
            ;;
        session/new)
            ((session_counter++)) || true
            local_cwd=$(printf '%s' "$line" | jq -r '.params.cwd // empty')
            local_session_id="mock-session-$session_counter"
            log "Creating session: $local_session_id (cwd=$local_cwd)"
            respond "{\"jsonrpc\":\"2.0\",\"id\":\"$local_id\",\"result\":{\"sessionId\":\"$local_session_id\"}}"
            ;;
        session/prompt)
            local_session_id=$(printf '%s' "$line" | jq -r '.params.sessionId // empty')
            local_message=$(printf '%s' "$line" | jq -r '.params.message // empty')
            log "Prompt for session $local_session_id: $local_message"
            # Send session/update notification (no id)
            respond "{\"jsonrpc\":\"2.0\",\"method\":\"session/update\",\"params\":{\"sessionId\":\"$local_session_id\",\"message\":\"Echo: $local_message\"}}"
            ;;
        session/end)
            local_session_id=$(printf '%s' "$line" | jq -r '.params.sessionId // empty')
            log "Ending session: $local_session_id"
            # session/end may or may not have an id (can be notification)
            if [[ -n "$local_id" ]]; then
                respond "{\"jsonrpc\":\"2.0\",\"id\":\"$local_id\",\"result\":{}}"
            fi
            ;;
        *)
            log "Unknown method: $local_method"
            if [[ -n "$local_id" ]]; then
                respond "{\"jsonrpc\":\"2.0\",\"id\":\"$local_id\",\"error\":{\"code\":-32601,\"message\":\"Method not found: $local_method\"}}"
            fi
            ;;
    esac
done

log "Server exiting (stdin EOF)"
