name: Build and Push Docker Image

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
  schedule:
    - cron: '0 2 * * *'  # 2am UTC daily for nightly builds

concurrency:
  group: docker-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install shellcheck
        run: sudo apt-get update && sudo apt-get install -y shellcheck

      - name: Lint shell scripts with shellcheck
        run: |
          echo "Running shellcheck on shell scripts..."
          shellcheck -x src/*.sh src/lib/*.sh

      - name: Check manifest consistency
        run: ./scripts/check-manifest-consistency.sh

  build:
    needs: lint
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # CRITICAL for NBGV

      - name: Convert repository name to lowercase
        run: |
          echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

      - name: Set up .NET for NBGV
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Install and run NBGV
        id: nbgv
        run: |
          dotnet tool restore
          echo "SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_OUTPUT"
          echo "SimpleVersion=$(dotnet nbgv get-version -v SimpleVersion)" >> "$GITHUB_OUTPUT"
          echo "GitCommitId=$(dotnet nbgv get-version -v GitCommitId)" >> "$GITHUB_OUTPUT"
          echo "NBGV_SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_ENV"
          echo "NBGV_SimpleVersion=$(dotnet nbgv get-version -v SimpleVersion)" >> "$GITHUB_ENV"
          echo "NBGV_GitCommitId=$(dotnet nbgv get-version -v GitCommitId)" >> "$GITHUB_ENV"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64,amd64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get build date
        id: date
        run: echo "value=$(date +%Y%m%d)" >> $GITHUB_OUTPUT

      - name: Determine build strategy
        id: build_strategy
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "platforms=linux/amd64" >> $GITHUB_OUTPUT
            echo "push=false" >> $GITHUB_OUTPUT
            echo "load=true" >> $GITHUB_OUTPUT
            echo "image_prefix=containai" >> $GITHUB_OUTPUT
            echo "tag_suffix=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          else
            echo "platforms=linux/amd64,linux/arm64" >> $GITHUB_OUTPUT
            echo "push=true" >> $GITHUB_OUTPUT
            echo "load=false" >> $GITHUB_OUTPUT
            echo "image_prefix=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT
            # tag_suffix for layer images: latest for tags, nightly for main/schedule
            if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
              echo "tag_suffix=latest" >> $GITHUB_OUTPUT
            else
              # Main branch push OR scheduled run
              echo "tag_suffix=nightly" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Build images (PR)
        if: github.event_name == 'pull_request'
        run: |
          ./src/build.sh \
            --image-prefix containai \
            --version "${{ steps.nbgv.outputs.SemVer2 }}" \
            --platforms linux/amd64 \
            --load

      - name: Build and push base image
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v6
        with:
          context: src
          file: src/container/Dockerfile.base
          platforms: ${{ steps.build_strategy.outputs.platforms }}
          push: ${{ steps.build_strategy.outputs.push }}
          load: ${{ steps.build_strategy.outputs.load }}
          tags: ${{ steps.build_strategy.outputs.image_prefix }}/base:${{ steps.build_strategy.outputs.tag_suffix }}
          build-args: |
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.nbgv.outputs.SemVer2 }}
          cache-from: type=gha,scope=base
          cache-to: type=gha,mode=max,scope=base

      - name: Build and push sdks image
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v6
        with:
          context: src
          file: src/container/Dockerfile.sdks
          platforms: ${{ steps.build_strategy.outputs.platforms }}
          push: ${{ steps.build_strategy.outputs.push }}
          load: ${{ steps.build_strategy.outputs.load }}
          tags: ${{ steps.build_strategy.outputs.image_prefix }}/sdks:${{ steps.build_strategy.outputs.tag_suffix }}
          build-args: |
            BASE_IMAGE=${{ steps.build_strategy.outputs.image_prefix }}/base:${{ steps.build_strategy.outputs.tag_suffix }}
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.nbgv.outputs.SemVer2 }}
          cache-from: type=gha,scope=sdks
          cache-to: type=gha,mode=max,scope=sdks

      - name: Generate container files
        if: github.event_name != 'pull_request'
        run: |
          mkdir -p src/container/generated
          ./src/scripts/gen-dockerfile-symlinks.sh src/sync-manifest.toml src/container/generated/symlinks.sh
          ./src/scripts/gen-init-dirs.sh src/sync-manifest.toml src/container/generated/init-dirs.sh
          ./src/scripts/gen-container-link-spec.sh src/sync-manifest.toml src/container/generated/link-spec.json
          cp src/container/link-repair.sh src/container/generated/link-repair.sh

      - name: Build and push full image
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v6
        with:
          context: src
          file: src/container/Dockerfile.agents
          platforms: ${{ steps.build_strategy.outputs.platforms }}
          push: ${{ steps.build_strategy.outputs.push }}
          load: ${{ steps.build_strategy.outputs.load }}
          tags: ${{ steps.build_strategy.outputs.image_prefix }}/agents:${{ steps.build_strategy.outputs.tag_suffix }}
          build-args: |
            SDKS_IMAGE=${{ steps.build_strategy.outputs.image_prefix }}/sdks:${{ steps.build_strategy.outputs.tag_suffix }}
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.nbgv.outputs.SemVer2 }}
          cache-from: type=gha,scope=full-v2
          cache-to: type=gha,mode=max,scope=full-v2

      - name: Extract metadata (tags, labels)
        id: meta
        if: github.event_name != 'pull_request'
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # latest ONLY for tagged releases
            type=raw,value=latest,enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            # Semver for tags only
            type=semver,pattern={{version}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            type=semver,pattern={{major}},enable=${{ startsWith(github.ref, 'refs/tags/v') && !startsWith(github.ref, 'refs/tags/v0.') }}
            # Nightly for main branch and schedule
            type=raw,value=nightly,enable=${{ github.ref == 'refs/heads/main' || github.event_name == 'schedule' }}
            type=raw,value=nightly-${{ steps.date.outputs.value }},enable=${{ github.ref == 'refs/heads/main' || github.event_name == 'schedule' }}
            # SHA for all builds
            type=sha,prefix=sha-

      - name: Build and push Docker image
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v6
        with:
          context: src
          file: src/container/Dockerfile
          platforms: ${{ steps.build_strategy.outputs.platforms }}
          push: ${{ steps.build_strategy.outputs.push }}
          load: ${{ steps.build_strategy.outputs.load }}
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            AGENTS_IMAGE=${{ steps.build_strategy.outputs.image_prefix }}/agents:${{ steps.build_strategy.outputs.tag_suffix }}
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.nbgv.outputs.SemVer2 }}
          cache-from: type=gha,scope=main
          cache-to: type=gha,mode=max,scope=main

  # ============================================================================
  # Build Multi-arch Tarballs
  # ============================================================================
  # Builds AOT .NET binaries for each architecture and creates release tarballs.
  # PR builds upload tarballs as artifacts for E2E testing.
  # Release builds are handled by the release workflow.
  # ============================================================================
  build-tarballs:
    needs: lint
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 20

    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
            dotnet_rid: linux-x64
            tarball_arch: linux-x64
          - arch: arm64
            runner: ubuntu-24.04-arm
            dotnet_rid: linux-arm64
            tarball_arch: linux-arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # CRITICAL for NBGV

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Install and run NBGV
        id: nbgv
        run: |
          dotnet tool restore
          echo "SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_OUTPUT"
          echo "NBGV_SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_ENV"

      - name: Build AOT binary
        run: |
          echo "============================================="
          echo "Building acp-proxy for ${{ matrix.dotnet_rid }}"
          echo "============================================="
          dotnet publish src/acp-proxy \
            -r ${{ matrix.dotnet_rid }} \
            -c Release \
            --self-contained \
            -o src/acp-proxy/publish/${{ matrix.dotnet_rid }}

          # Verify binary exists and is executable
          ls -la src/acp-proxy/publish/${{ matrix.dotnet_rid }}/
          file src/acp-proxy/publish/${{ matrix.dotnet_rid }}/acp-proxy

      - name: Create release tarball
        run: |
          echo "============================================="
          echo "Creating tarball for ${{ matrix.tarball_arch }}"
          echo "============================================="
          ./scripts/package-release.sh \
            --arch ${{ matrix.tarball_arch }} \
            --version "$NBGV_SemVer2" \
            --output-dir ./artifacts

          ls -la ./artifacts/

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v4
        with:
          name: containai-tarball-${{ matrix.arch }}
          path: ./artifacts/containai-*.tar.gz
          retention-days: 7
          if-no-files-found: error

  # ============================================================================
  # Import Tests
  # ============================================================================
  # Tiered test strategy:
  # - Host-side tests (manifest parsing, consistency) run in lint job above
  # - Integration tests run here after build, using the built image
  # - Full E2E tests (sysbox/systemd containers) require self-hosted runners
  #   with sysbox installed - see docs/testing.md for manual E2E testing
  #
  # Test execution on PRs:
  # - Depends on build job to ensure build passes first
  # - Builds image locally (GitHub Actions jobs can't share Docker images)
  # - Runs full test suite (standard Docker runtime, no sysbox required)
  #
  # Note: The test job rebuilds the image because GitHub Actions jobs run on
  # separate runners. The build dependency ensures we don't waste CI time
  # running tests if the build would fail.
  # ============================================================================
  test:
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # CRITICAL for NBGV

      - name: Set up .NET for NBGV
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Install and run NBGV
        run: |
          dotnet tool restore
          echo "NBGV_SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test image
        run: |
          echo "Building containai image for testing..."
          ./src/build.sh \
            --image-prefix containai \
            --version "$NBGV_SemVer2" \
            --platforms linux/amd64 \
            --load

      - name: Verify test image
        run: |
          echo "Verifying containai:latest image was built..."
          if ! docker image inspect containai:latest >/dev/null 2>&1; then
            echo "::error::containai:latest image not found after build"
            echo "Available images:"
            docker images | grep -E '^(containai|REPOSITORY)' || true
            exit 1
          fi
          echo "Image built successfully:"
          docker image inspect containai:latest --format '{{.Id}} {{.Created}}'

      - name: Run import integration tests
        run: |
          echo "============================================="
          echo "Running import integration tests"
          echo "============================================="
          # Set IMAGE_NAME to use the built image
          export IMAGE_NAME="containai:latest"
          ./tests/integration/test-sync-integration.sh

      - name: Run .NET unit tests (if test projects exist)
        run: |
          echo "============================================="
          echo "Running .NET unit tests (MTP runner)"
          echo "============================================="
          # Only run tests if test projects exist
          if find . -name '*Tests*.csproj' -o -name '*.Tests.csproj' | grep -q .; then
            dotnet test --configuration Release
          else
            echo "No test projects found, skipping dotnet test"
          fi

      - name: Build ACP Proxy
        run: |
          echo "============================================="
          echo "Building ACP proxy binary"
          echo "============================================="
          cd src/acp-proxy
          # Use self-contained publish for portability
          dotnet publish -r linux-x64 -c Release --self-contained -o publish
          mkdir -p ../bin
          cp publish/acp-proxy ../bin/acp-proxy
          chmod +x ../bin/acp-proxy

      - name: Run ACP integration tests
        env:
          CAI_ACP_TEST_MODE: "1"
          CAI_ACP_DIRECT_SPAWN: "1"
        run: |
          echo "============================================="
          echo "Running ACP proxy integration tests"
          echo "============================================="
          chmod +x ./tests/integration/mock-acp-server
          ./tests/integration/test-acp-proxy.sh

      - name: Upload test logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs-${{ github.run_id }}
          path: |
            ~/.containai-test-*
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E Tests (Sysbox/DinD) - GitHub-hosted runners
  # ============================================================================
  # Attempts to run E2E tests on GitHub-hosted runners. Sysbox requires kernel
  # module loading which may not work due to virtualization constraints.
  # This job gracefully skips if sysbox installation fails.
  #
  # Install flow: Downloads tarball artifact from build-tarballs job, tests
  # install.sh --local --yes to verify the tarball install path works.
  # ============================================================================
  e2e-test:
    needs: [build, build-tarballs]
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-22.04
          - arch: arm64
            runner: ubuntu-24.04-arm

    steps:
      # Always checkout repository - needed for build.sh and test scripts
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # CRITICAL for NBGV

      # Try to download tarball artifact (from Task 5's PR artifact upload)
      # This tests the install path; repo checkout above provides build/test scripts
      - name: Download tarball artifact
        id: download_tarball
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: containai-tarball-${{ matrix.arch }}
          path: /tmp/tarball

      - name: Extract and install from tarball
        id: install
        if: steps.download_tarball.outcome == 'success'
        run: |
          echo "============================================="
          echo "Installing from tarball artifact"
          echo "============================================="
          cd /tmp/tarball
          tar xzf containai-*.tar.gz
          cd containai-*/
          if ./install.sh --local --yes 2>&1; then
            echo "INSTALL_SUCCESS=true" >> "$GITHUB_OUTPUT"
            echo "INSTALL_METHOD=tarball" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::install.sh --local --yes failed"
            echo "INSTALL_SUCCESS=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Log install method
        run: |
          if [[ "${{ steps.install.outputs.INSTALL_METHOD }}" == "tarball" ]]; then
            echo "Tested install from tarball artifact"
          else
            echo "Tarball artifact not available - build-tarballs job may have failed"
          fi

      # Fail if tarball was downloaded but install failed - this is a regression
      - name: Verify install success
        if: steps.download_tarball.outcome == 'success' && steps.install.outputs.INSTALL_SUCCESS != 'true'
        run: |
          echo "::error::Tarball artifact was downloaded but install.sh --local --yes failed"
          echo "This indicates a regression in the install path."
          exit 1

      - name: Check kernel version
        id: kernel
        run: |
          echo "============================================="
          echo "Kernel Information"
          echo "============================================="
          uname -a
          echo "KERNEL_VERSION=$(uname -r)" >> "$GITHUB_OUTPUT"

      - name: Attempt sysbox installation
        id: sysbox
        run: |
          echo "============================================="
          echo "Attempting Sysbox Installation"
          echo "============================================="

          # Try to install sysbox - this may fail on GH-hosted runners
          # due to kernel module loading restrictions

          # Download sysbox package with SHA256 verification
          SYSBOX_VERSION="0.6.4"
          ARCH=$(dpkg --print-architecture)
          SYSBOX_URL="https://downloads.nestybox.com/sysbox/releases/v${SYSBOX_VERSION}/sysbox-ce_${SYSBOX_VERSION}-0.linux_${ARCH}.deb"

          # Pinned SHA256 checksums for supply chain security
          # From: https://github.com/nestybox/sysbox/releases/tag/v0.6.4
          if [[ "$ARCH" == "amd64" ]]; then
            EXPECTED_SHA256="d034ddd364ee1f226b8b1ce7456ea8a12abc2eb661bdf42d3e603ed2dc741827"
          elif [[ "$ARCH" == "arm64" ]]; then
            EXPECTED_SHA256="0ed41cd828cbeadbeceae41ec8c422b415bb1437443eb1fdf571f4973806a90e"
          else
            echo "SYSBOX_AVAILABLE=false" >> "$GITHUB_OUTPUT"
            echo "SYSBOX_SKIP_REASON=Unsupported architecture: $ARCH" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Downloading sysbox from: $SYSBOX_URL"
          if ! curl -fsSL -o /tmp/sysbox.deb "$SYSBOX_URL"; then
            echo "SYSBOX_AVAILABLE=false" >> "$GITHUB_OUTPUT"
            echo "SYSBOX_SKIP_REASON=Failed to download sysbox package" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Verify SHA256 checksum
          echo "Verifying SHA256 checksum..."
          ACTUAL_SHA256=$(sha256sum /tmp/sysbox.deb | cut -d' ' -f1)
          if [[ "$ACTUAL_SHA256" != "$EXPECTED_SHA256" ]]; then
            echo "::error::SHA256 checksum mismatch!"
            echo "  Expected: $EXPECTED_SHA256"
            echo "  Actual:   $ACTUAL_SHA256"
            echo "SYSBOX_AVAILABLE=false" >> "$GITHUB_OUTPUT"
            echo "SYSBOX_SKIP_REASON=SHA256 checksum verification failed" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "SHA256 checksum verified: $ACTUAL_SHA256"

          # Install sysbox dependencies (with graceful failure handling)
          echo "Installing dependencies..."
          if ! sudo apt-get update -qq 2>&1; then
            echo "SYSBOX_AVAILABLE=false" >> "$GITHUB_OUTPUT"
            echo "SYSBOX_SKIP_REASON=apt-get update failed" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if ! sudo apt-get install -y -qq jq fuse rsync 2>&1; then
            echo "SYSBOX_AVAILABLE=false" >> "$GITHUB_OUTPUT"
            echo "SYSBOX_SKIP_REASON=Failed to install dependencies (jq, fuse, rsync)" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Attempt sysbox installation
          echo "Installing sysbox..."
          if ! sudo dpkg -i /tmp/sysbox.deb 2>&1; then
            # dpkg may fail but apt can fix it
            if ! sudo apt-get install -f -y 2>&1; then
              echo "SYSBOX_AVAILABLE=false" >> "$GITHUB_OUTPUT"
              echo "SYSBOX_SKIP_REASON=Sysbox installation failed (likely kernel module issue)" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          # Verify sysbox services are running
          echo "Checking sysbox services..."
          if systemctl is-active --quiet sysbox-mgr && systemctl is-active --quiet sysbox-fs; then
            echo "Sysbox services are running"
            echo "SYSBOX_AVAILABLE=true" >> "$GITHUB_OUTPUT"
          else
            echo "Sysbox services failed to start"
            systemctl status sysbox-mgr --no-pager || true
            systemctl status sysbox-fs --no-pager || true
            echo "SYSBOX_AVAILABLE=false" >> "$GITHUB_OUTPUT"
            echo "SYSBOX_SKIP_REASON=Sysbox services failed to start" >> "$GITHUB_OUTPUT"
          fi

      - name: Configure Docker for sysbox
        id: docker_config
        if: steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true'
        run: |
          echo "============================================="
          echo "Configuring Docker with sysbox runtime"
          echo "============================================="

          # Create Docker context for E2E tests (test-dind.sh uses containai-docker context)
          docker context create containai-docker --docker "host=unix:///var/run/docker.sock" || true

          # Merge sysbox runtime into existing daemon.json (don't clobber runner defaults)
          # Don't set default-runtime - tests explicitly use --runtime=sysbox-runc
          sudo mkdir -p /etc/docker
          DAEMON_JSON="/etc/docker/daemon.json"
          if [[ -f "$DAEMON_JSON" ]]; then
            echo "Merging sysbox runtime into existing daemon.json..."
            EXISTING=$(sudo cat "$DAEMON_JSON" 2>/dev/null || echo "{}")
            # Validate JSON before merging; if invalid, start fresh
            if ! echo "$EXISTING" | jq . >/dev/null 2>&1; then
              echo "::warning::Existing daemon.json is invalid, creating new one"
              EXISTING="{}"
            fi
            # Use jq to merge, adding sysbox-runc runtime
            if ! echo "$EXISTING" | jq '. + {"runtimes": (.runtimes // {} | . + {"sysbox-runc": {"path": "/usr/bin/sysbox-runc"}})}' | sudo tee "$DAEMON_JSON" > /dev/null; then
              echo "::error::Failed to merge daemon.json"
              echo "DOCKER_READY=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          else
            echo "Creating new daemon.json with sysbox runtime..."
            echo '{"runtimes": {"sysbox-runc": {"path": "/usr/bin/sysbox-runc"}}}' | sudo tee "$DAEMON_JSON" > /dev/null
          fi

          cat "$DAEMON_JSON"

          # Restart Docker to pick up new config (with error handling)
          echo "Restarting Docker..."
          if ! sudo systemctl restart docker 2>&1; then
            echo "::error::Failed to restart Docker"
            echo "DOCKER_READY=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Wait for Docker to be ready (poll instead of sleep)
          echo "Waiting for Docker to be ready..."
          TIMEOUT=30
          ELAPSED=0
          while ! docker info >/dev/null 2>&1; do
            sleep 1
            ELAPSED=$((ELAPSED + 1))
            if [[ $ELAPSED -ge $TIMEOUT ]]; then
              echo "::error::Docker failed to become ready within ${TIMEOUT}s"
              echo "DOCKER_READY=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          done
          echo "Docker ready after ${ELAPSED}s"

          # Verify sysbox is available on containai-docker context
          echo "Verifying sysbox runtime on containai-docker context..."
          RUNTIMES=$(docker --context containai-docker info --format '{{json .Runtimes}}' 2>/dev/null || echo "{}")
          echo "Available runtimes: $RUNTIMES"

          if echo "$RUNTIMES" | grep -q "sysbox-runc"; then
            echo "✓ Sysbox runtime detected on containai-docker context"
            echo "DOCKER_READY=true" >> "$GITHUB_OUTPUT"
          else
            echo "::error::Sysbox runtime not detected on containai-docker context"
            echo "DOCKER_READY=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up Docker Buildx
        if: steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true' && steps.docker_config.outputs.DOCKER_READY == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Set up .NET for NBGV
        if: steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true' && steps.docker_config.outputs.DOCKER_READY == 'true'
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Install and run NBGV
        if: steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true' && steps.docker_config.outputs.DOCKER_READY == 'true'
        run: |
          dotnet tool restore
          echo "NBGV_SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_ENV"

      - name: Build test image
        if: steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true' && steps.docker_config.outputs.DOCKER_READY == 'true'
        run: |
          echo "Building containai image for E2E testing..."
          ./src/build.sh \
            --image-prefix containai \
            --version "$NBGV_SemVer2" \
            --platforms linux/${{ matrix.arch }} \
            --load

      - name: Run E2E tests (DinD)
        if: steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true' && steps.docker_config.outputs.DOCKER_READY == 'true'
        env:
          CONTAINAI_TEST_IMAGE: containai/base:latest
        run: |
          echo "============================================="
          echo "Running Docker-in-Docker E2E tests"
          echo "============================================="
          ./tests/integration/test-dind.sh

      - name: Skip message (sysbox unavailable)
        if: steps.sysbox.outputs.SYSBOX_AVAILABLE != 'true' || steps.docker_config.outputs.DOCKER_READY != 'true'
        run: |
          echo "============================================="
          echo "E2E Tests Skipped (GitHub-hosted runner)"
          echo "============================================="
          if [[ "${{ steps.sysbox.outputs.SYSBOX_AVAILABLE }}" != "true" ]]; then
            echo "Reason: ${{ steps.sysbox.outputs.SYSBOX_SKIP_REASON }}"
          elif [[ "${{ steps.docker_config.outputs.DOCKER_READY }}" != "true" ]]; then
            echo "Reason: Docker failed to expose sysbox runtime"
          fi
          echo ""
          echo "Sysbox requires kernel module loading which is not supported"
          echo "on GitHub-hosted runners due to virtualization constraints."
          echo ""
          echo "E2E tests run automatically on the e2e-test-selfhosted job"
          echo "when self-hosted runners are available."
          echo ""
          echo "See docs/testing.md for manual E2E testing instructions."

      - name: Collect sysbox logs
        if: failure() && steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true'
        run: |
          mkdir -p /tmp/sysbox-logs
          journalctl -u sysbox-mgr --no-pager > /tmp/sysbox-logs/sysbox-mgr.log 2>&1 || true
          journalctl -u sysbox-fs --no-pager > /tmp/sysbox-logs/sysbox-fs.log 2>&1 || true
          sudo cp -r /var/log/sysbox/ /tmp/sysbox-logs/ 2>/dev/null || true

      - name: Upload E2E test logs on failure
        if: failure() && steps.sysbox.outputs.SYSBOX_AVAILABLE == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-logs-${{ matrix.arch }}-${{ github.run_id }}
          path: |
            ~/.containai-test-*
            /tmp/sysbox-logs/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E Tests (Sysbox/DinD) - Self-hosted runners
  # ============================================================================
  # Runs E2E tests on self-hosted runners with sysbox pre-installed.
  # These runners provide reliable sysbox support without installation issues.
  #
  # Self-hosted runner requirements:
  # - Ubuntu 22.04+ with kernel 5.5+
  # - Sysbox pre-installed: https://github.com/nestybox/sysbox
  # - Docker configured with sysbox runtime
  # - Runner labels: self-hosted, linux, sysbox, <arch>
  #
  # This job only runs on the main repo (not forks) to avoid indefinite queuing
  # when no self-hosted runners are available. Forks can set the repo variable
  # ENABLE_SELF_HOSTED_E2E=true if they have configured self-hosted runners.
  #
  # Install flow: Downloads tarball artifact from build-tarballs job, tests
  # install.sh --local --yes to verify the tarball install path works.
  # ============================================================================
  e2e-test-selfhosted:
    needs: [build, build-tarballs]
    # Only run on main repo or when explicitly enabled via repo variable
    # This prevents forks from hanging indefinitely waiting for self-hosted runners
    if: github.repository == 'novotnyllc/containai' || vars.ENABLE_SELF_HOSTED_E2E == 'true'
    runs-on: [self-hosted, linux, sysbox, '${{ matrix.arch }}']
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        arch: [amd64, arm64]

    steps:
      # Always checkout repository - needed for build.sh and test scripts
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # CRITICAL for NBGV

      # Try to download tarball artifact (from Task 5's PR artifact upload)
      # This tests the install path; repo checkout above provides build/test scripts
      - name: Download tarball artifact
        id: download_tarball
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: containai-tarball-${{ matrix.arch }}
          path: /tmp/tarball

      - name: Extract and install from tarball
        id: install
        if: steps.download_tarball.outcome == 'success'
        run: |
          echo "============================================="
          echo "Installing from tarball artifact"
          echo "============================================="
          cd /tmp/tarball
          tar xzf containai-*.tar.gz
          cd containai-*/
          if ./install.sh --local --yes 2>&1; then
            echo "INSTALL_SUCCESS=true" >> "$GITHUB_OUTPUT"
            echo "INSTALL_METHOD=tarball" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::install.sh --local --yes failed"
            echo "INSTALL_SUCCESS=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Log install method
        run: |
          if [[ "${{ steps.install.outputs.INSTALL_METHOD }}" == "tarball" ]]; then
            echo "Tested install from tarball artifact"
          else
            echo "Tarball artifact not available - build-tarballs job may have failed"
          fi

      # Fail if tarball was downloaded but install failed - this is a regression
      - name: Verify install success
        if: steps.download_tarball.outcome == 'success' && steps.install.outputs.INSTALL_SUCCESS != 'true'
        run: |
          echo "::error::Tarball artifact was downloaded but install.sh --local --yes failed"
          echo "This indicates a regression in the install path."
          exit 1

      - name: Verify sysbox is pre-installed
        id: verify
        run: |
          echo "============================================="
          echo "Verifying Sysbox Installation"
          echo "============================================="

          # Self-hosted runners should have sysbox pre-installed
          # DO NOT attempt to install/modify sysbox on self-hosted runners

          # Check sysbox services
          if ! systemctl is-active --quiet sysbox-mgr; then
            echo "::error::sysbox-mgr service is not running"
            echo "SYSBOX_READY=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          if ! systemctl is-active --quiet sysbox-fs; then
            echo "::error::sysbox-fs service is not running"
            echo "SYSBOX_READY=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          echo "✓ Sysbox services are running"

          # Create containai-docker context if it doesn't exist
          docker context create containai-docker --docker "host=unix:///var/run/docker.sock" 2>/dev/null || true

          # Verify sysbox runtime on containai-docker context
          RUNTIMES=$(docker --context containai-docker info --format '{{json .Runtimes}}' 2>/dev/null || echo "{}")
          echo "Available runtimes: $RUNTIMES"

          if echo "$RUNTIMES" | grep -q "sysbox-runc"; then
            echo "✓ Sysbox runtime detected on containai-docker context"
            echo "SYSBOX_READY=true" >> "$GITHUB_OUTPUT"
          else
            echo "::error::Sysbox runtime not available in Docker"
            echo "SYSBOX_READY=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Set up .NET for NBGV
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Install and run NBGV
        run: |
          dotnet tool restore
          echo "NBGV_SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test image
        run: |
          echo "Building containai image for E2E testing (${{ matrix.arch }})..."
          ./src/build.sh \
            --image-prefix containai \
            --version "$NBGV_SemVer2" \
            --platforms "linux/${{ matrix.arch }}" \
            --load

      - name: Run E2E tests (DinD)
        env:
          CONTAINAI_TEST_IMAGE: containai/base:latest
        run: |
          echo "============================================="
          echo "Running Docker-in-Docker E2E tests (${{ matrix.arch }})"
          echo "============================================="
          ./tests/integration/test-dind.sh

      - name: Collect logs on failure
        if: failure()
        run: |
          mkdir -p /tmp/sysbox-logs
          journalctl -u sysbox-mgr --no-pager -n 100 > /tmp/sysbox-logs/sysbox-mgr.log 2>&1 || true
          journalctl -u sysbox-fs --no-pager -n 100 > /tmp/sysbox-logs/sysbox-fs.log 2>&1 || true

      - name: Upload E2E test logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-logs-selfhosted-${{ matrix.arch }}-${{ github.run_id }}
          path: |
            ~/.containai-test-*
            /tmp/sysbox-logs/
          retention-days: 7
          if-no-files-found: ignore
