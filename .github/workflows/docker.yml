name: Build and Push Docker Image

on:
  workflow_dispatch:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
  schedule:
    - cron: '0 2 * * *'  # 2am UTC daily for nightly builds

concurrency:
  group: docker-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  CONTAINAI_VERBOSE: "1"

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Install shellcheck
        run: sudo apt-get update && sudo apt-get install -y shellcheck

      - name: Lint installer script with shellcheck
        run: |
          echo "Running shellcheck on install.sh..."
          shellcheck -x install.sh

      - name: Check manifest consistency
        run: dotnet run --project src/cai -- manifest check src/manifests

      - name: Strict .NET analyzer build
        run: dotnet build ContainAI.slnx -c Release -warnaserror

      - name: Collect ContainAI logs
        if: always()
        run: |
          mkdir -p /tmp/containai-logs
          cp -a ~/.config/containai/logs /tmp/containai-logs/ 2>/dev/null || true
          cp -a ~/.containai-test-* /tmp/containai-logs/ 2>/dev/null || true

      - name: Upload ContainAI logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: containai-logs-lint-${{ github.run_id }}
          path: /tmp/containai-logs/
          retention-days: 7
          if-no-files-found: ignore

  build-strategy:
    needs: lint
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    outputs:
      image_prefix: ${{ steps.strategy.outputs.image_prefix }}
      tag_suffix: ${{ steps.strategy.outputs.tag_suffix }}
      push: ${{ steps.strategy.outputs.push }}

    steps:
      - name: Determine build strategy
        id: strategy
        run: |
          set -euo pipefail
          image_name="${GITHUB_REPOSITORY,,}"
          echo "image_prefix=${{ env.REGISTRY }}/${image_name}" >> "$GITHUB_OUTPUT"
          if [[ "${GITHUB_EVENT_NAME}" == "pull_request" ]]; then
            echo "push=true" >> $GITHUB_OUTPUT
            echo "tag_suffix=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            echo "push=true" >> $GITHUB_OUTPUT
            echo "tag_suffix=latest" >> $GITHUB_OUTPUT
          else
            echo "push=true" >> $GITHUB_OUTPUT
            echo "tag_suffix=nightly" >> $GITHUB_OUTPUT
          fi

  build-push-arch:
    needs: [build-strategy, build-tarballs]
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            platform: linux/amd64
            runner: ubuntu-24.04
          - arch: arm64
            platform: linux/arm64
            runner: ubuntu-24.04-arm
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set version from build-tarballs
        run: |
          echo "NBGV_SemVer2=${{ needs.build-tarballs.outputs.version }}" >> "$GITHUB_ENV"

      - name: Download Linux tarball
        uses: actions/download-artifact@v4
        with:
          name: containai-tarball-${{ matrix.arch }}
          path: /tmp/tarball

      - name: Stage ContainAI CLI tarball
        run: |
          mkdir -p artifacts/cai-tarballs
          cp /tmp/tarball/containai-*.tar.gz artifacts/cai-tarballs/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push base image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/container/Dockerfile.base
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ needs.build-strategy.outputs.image_prefix }}/base:${{ needs.build-strategy.outputs.tag_suffix }}-${{ matrix.arch }}
          build-args: |
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            CONTAINAI_VERSION=${{ env.NBGV_SemVer2 }}
          cache-from: type=gha,scope=base-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=base-${{ matrix.arch }}

      - name: Build and push sdks image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/container/Dockerfile.sdks
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ needs.build-strategy.outputs.image_prefix }}/sdks:${{ needs.build-strategy.outputs.tag_suffix }}-${{ matrix.arch }}
          build-args: |
            BASE_IMAGE=${{ needs.build-strategy.outputs.image_prefix }}/base:${{ needs.build-strategy.outputs.tag_suffix }}-${{ matrix.arch }}
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            CONTAINAI_VERSION=${{ env.NBGV_SemVer2 }}
          cache-from: type=gha,scope=sdks-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=sdks-${{ matrix.arch }}

      - name: Build and push full image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/container/Dockerfile.agents
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ needs.build-strategy.outputs.image_prefix }}/agents:${{ needs.build-strategy.outputs.tag_suffix }}-${{ matrix.arch }}
          build-args: |
            SDKS_IMAGE=${{ needs.build-strategy.outputs.image_prefix }}/sdks:${{ needs.build-strategy.outputs.tag_suffix }}-${{ matrix.arch }}
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            CONTAINAI_VERSION=${{ env.NBGV_SemVer2 }}
          cache-from: type=gha,scope=agents-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=agents-${{ matrix.arch }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: src/container/Dockerfile
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ needs.build-strategy.outputs.image_prefix }}:${{ needs.build-strategy.outputs.tag_suffix }}-${{ matrix.arch }}
          build-args: |
            AGENTS_IMAGE=${{ needs.build-strategy.outputs.image_prefix }}/agents:${{ needs.build-strategy.outputs.tag_suffix }}-${{ matrix.arch }}
            BUILD_DATE=${{ github.run_started_at }}
            VCS_REF=${{ github.sha }}
            CONTAINAI_VERSION=${{ env.NBGV_SemVer2 }}
          cache-from: type=gha,scope=main-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=main-${{ matrix.arch }}

      - name: Collect ContainAI logs
        if: always()
        run: |
          mkdir -p /tmp/containai-logs
          cp -a ~/.config/containai/logs /tmp/containai-logs/ 2>/dev/null || true
          cp -a ~/.containai-test-* /tmp/containai-logs/ 2>/dev/null || true
          docker info > /tmp/containai-logs/docker-info.log 2>&1 || true
          docker buildx ls > /tmp/containai-logs/buildx-ls.log 2>&1 || true

      - name: Upload ContainAI logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: containai-logs-build-push-${{ matrix.arch }}-${{ github.run_id }}
          path: /tmp/containai-logs/
          retention-days: 7
          if-no-files-found: ignore

  build-push:
    needs: [build-strategy, build-push-arch]
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_prefix: ${{ needs.build-strategy.outputs.image_prefix }}
      tag_suffix: ${{ needs.build-strategy.outputs.tag_suffix }}
      push: ${{ needs.build-strategy.outputs.push }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge layer and runtime manifests
        run: |
          set -euo pipefail
          image_prefix="${{ needs.build-strategy.outputs.image_prefix }}"
          tag_suffix="${{ needs.build-strategy.outputs.tag_suffix }}"
          for layer in base sdks agents; do
            docker buildx imagetools create \
              -t "${image_prefix}/${layer}:${tag_suffix}" \
              "${image_prefix}/${layer}:${tag_suffix}-amd64" \
              "${image_prefix}/${layer}:${tag_suffix}-arm64"
          done
          docker buildx imagetools create \
            -t "${image_prefix}:${tag_suffix}" \
            "${image_prefix}:${tag_suffix}-amd64" \
            "${image_prefix}:${tag_suffix}-arm64"

      - name: Publish additional manifest aliases
        run: |
          set -euo pipefail
          image_prefix="${{ needs.build-strategy.outputs.image_prefix }}"
          canonical_tag="${{ needs.build-strategy.outputs.tag_suffix }}"
          canonical_image="${image_prefix}:${canonical_tag}"
          short_sha="${GITHUB_SHA::7}"

          aliases=("sha-${short_sha}")

          if [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            version="${GITHUB_REF_NAME#v}"
            major="${version%%.*}"
            remainder="${version#*.}"
            minor="${remainder%%.*}"
            aliases+=("latest" "${version}" "${major}.${minor}")
            if [[ "${major}" != "0" ]]; then
              aliases+=("${major}")
            fi
          elif [[ "${GITHUB_REF}" == "refs/heads/main" || "${GITHUB_EVENT_NAME}" == "schedule" ]]; then
            aliases+=("nightly" "nightly-$(date +%Y%m%d)")
          fi

          for alias in "${aliases[@]}"; do
            if [[ "${alias}" == "${canonical_tag}" ]]; then
              continue
            fi

            docker buildx imagetools create \
              -t "${image_prefix}:${alias}" \
              "${canonical_image}"
          done

  # ============================================================================
  # Build Test Images (per-arch) - shared across test jobs
  # ============================================================================
  # ============================================================================
  # Build Multi-arch Tarballs
  # ============================================================================
  # Builds AOT .NET binaries for each architecture and creates release tarballs.
  # PR builds upload tarballs as artifacts for E2E testing.
  # Release builds are handled by the release workflow.
  # ============================================================================
  build-tarballs:
    needs: lint
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    outputs:
      version: ${{ steps.nbgv.outputs.SemVer2 }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-24.04
            tarball_target: linux-x64
            rid: linux-x64
          - arch: arm64
            runner: ubuntu-24.04-arm
            tarball_target: linux-arm64
            rid: linux-arm64
          - arch: macos-x64
            runner: macos-15-intel
            tarball_target: macos-x64
            rid: osx-x64
          - arch: macos-arm64
            runner: macos-26
            tarball_target: macos-arm64
            rid: osx-arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Install and run NBGV
        id: nbgv
        run: |
          dotnet tool restore
          echo "SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_OUTPUT"
          echo "NBGV_SemVer2=$(dotnet nbgv get-version -v SemVer2)" >> "$GITHUB_ENV"

      - name: Build release tarball
        run: |
          echo "============================================="
          echo "Creating tarball for ${{ matrix.tarball_target }}"
          echo "============================================="
          dotnet publish ./src/cai/cai.csproj \
            -c Release \
            -r "${{ matrix.rid }}" \
            -warnaserror \
            -p:TrimmerSingleWarn=false

          ls -la ./artifacts/

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v4
        with:
          name: containai-tarball-${{ matrix.arch }}
          path: ./artifacts/containai-*.tar.gz
          retention-days: 7
          if-no-files-found: error

      - name: Collect ContainAI logs
        if: always()
        run: |
          mkdir -p /tmp/containai-logs
          cp -a ~/.config/containai/logs /tmp/containai-logs/ 2>/dev/null || true
          cp -a ~/.containai-test-* /tmp/containai-logs/ 2>/dev/null || true

      - name: Upload ContainAI logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: containai-logs-build-tarballs-${{ matrix.arch }}-${{ github.run_id }}
          path: /tmp/containai-logs/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # Import Tests
  # ============================================================================
  # Tiered test strategy:
  # - Host-side tests (manifest parsing, consistency) run in lint job above
  # - Integration tests run here after build, using the built image
  # - Full E2E tests (sysbox/systemd containers) require self-hosted runners
  #   with sysbox installed - see docs/testing.md for manual E2E testing
  #
  # Test execution:
  # - Depends on build-push job (single build stage)
  # - Pulls images from registry (no local rebuild)
  # - Runs full test suite (standard Docker runtime, no sysbox required)
  #
  # Note: Images are produced in build-push and pulled by test jobs.
  # ============================================================================
  test:
    needs: build-push
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    permissions:
      contents: read
      packages: read
    env:
      IMAGE_PREFIX: ${{ needs.build-push.outputs.image_prefix }}
      IMAGE_TAG: ${{ needs.build-push.outputs.tag_suffix }}
      IMAGE_NAME: ${{ needs.build-push.outputs.image_prefix }}/agents:${{ needs.build-push.outputs.tag_suffix }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-24.04
            dotnet_rid: linux-x64
          - arch: arm64
            runner: ubuntu-24.04-arm
            dotnet_rid: linux-arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Pull test images
        run: |
          docker pull "${IMAGE_PREFIX}/agents:${IMAGE_TAG}"
          docker pull "${IMAGE_PREFIX}/base:${IMAGE_TAG}"

      - name: Run import integration tests
        run: |
          echo "============================================="
          echo "Running import integration tests (${{ matrix.arch }})"
          echo "============================================="
          dotnet test --project tests/ContainAI.Cli.Tests/ContainAI.Cli.Tests.csproj --configuration Release -- --filter-trait "Category=SyncIntegration" --xunit-info

      - name: Run .NET unit tests with coverage
        run: |
          echo "============================================="
          echo "Running .NET unit tests with coverage (${{ matrix.arch }})"
          echo "============================================="
          find artifacts/bin -type d -name TestResults -prune -exec rm -rf {} +
          if find . -name '*Tests*.csproj' -o -name '*.Tests.csproj' | grep -q .; then
            dotnet test --solution ContainAI.slnx --configuration Release -- --filter-not-trait "Category=SyncIntegration" --coverage --coverage-output-format cobertura --xunit-info
          else
            echo "No test projects found, skipping dotnet test"
          fi

      - name: Install coverage report tools
        run: |
          dotnet tool install --global dotnet-reportgenerator-globaltool --version 5.5.1

      - name: Generate coverage reports
        run: |
          set -euo pipefail
          export PATH="$HOME/.dotnet/tools:$PATH"
          mkdir -p artifacts/coverage
          coverage_files="$(find artifacts/bin -type f -path '*/TestResults/*.cobertura.xml' | tr '\n' ';')"
          if [[ -z "$coverage_files" ]]; then
            echo "ERROR: No .cobertura.xml coverage files produced by test run"
            exit 1
          fi
          reportgenerator \
            -reports:"artifacts/bin/**/TestResults/*.cobertura.xml" \
            -targetdir:artifacts/coverage/report \
            "-reporttypes:HtmlInline;Cobertura;Badges;TextSummary"

      - name: Enforce .NET coverage thresholds (>= 97%)
        run: |
          set -euo pipefail
          summary_file="artifacts/coverage/report/Summary.txt"
          if [[ ! -f "$summary_file" ]]; then
            echo "ERROR: Coverage summary file not found: $summary_file"
            exit 1
          fi

          containai_cli_pct="$(awk '/^ContainAI\.Cli[[:space:]]+[0-9.]+%$/ {gsub("%","",$NF); print $NF; exit}' "$summary_file")"
          abstractions_pct="$(awk '/^ContainAI\.Cli\.Abstractions[[:space:]]+[0-9.]+%$/ {gsub("%","",$NF); print $NF; exit}' "$summary_file")"
          acp_proxy_pct="$(awk '/^AgentClientProtocol\.Proxy[[:space:]]+[0-9.]+%$/ {gsub("%","",$NF); print $NF; exit}' "$summary_file")"

          if [[ -z "$containai_cli_pct" ]]; then
            echo "ERROR: Could not determine coverage for ContainAI.Cli from $summary_file"
            exit 1
          fi

          if [[ -z "$abstractions_pct" ]]; then
            echo "ERROR: Could not determine coverage for ContainAI.Cli.Abstractions from $summary_file"
            exit 1
          fi

          if [[ -z "$acp_proxy_pct" ]]; then
            echo "ERROR: Could not determine coverage for AgentClientProtocol.Proxy from $summary_file"
            exit 1
          fi

          awk -v v="$containai_cli_pct" 'BEGIN { exit (v + 0 >= 97 ? 0 : 1) }' || {
            echo "ERROR: ContainAI.Cli coverage is ${containai_cli_pct}% (< 97%)"
            exit 1
          }

          awk -v v="$abstractions_pct" 'BEGIN { exit (v + 0 >= 97 ? 0 : 1) }' || {
            echo "ERROR: ContainAI.Cli.Abstractions coverage is ${abstractions_pct}% (< 97%)"
            exit 1
          }

          awk -v v="$acp_proxy_pct" 'BEGIN { exit (v + 0 >= 97 ? 0 : 1) }' || {
            echo "ERROR: AgentClientProtocol.Proxy coverage is ${acp_proxy_pct}% (< 97%)"
            exit 1
          }

          echo "Coverage gate passed: ContainAI.Cli=${containai_cli_pct}%, ContainAI.Cli.Abstractions=${abstractions_pct}%, AgentClientProtocol.Proxy=${acp_proxy_pct}%"

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: containai-coverage-${{ matrix.arch }}-${{ github.run_id }}
          path: artifacts/coverage/
          retention-days: 7
          if-no-files-found: error

      - name: Run ACP integration tests
        env:
          CAI_ACP_TEST_MODE: "1"
          CAI_ACP_DIRECT_SPAWN: "1"
        run: |
          echo "============================================="
          echo "Running ACP proxy integration tests (${{ matrix.arch }})"
          echo "============================================="
          dotnet test --project tests/AgentClientProtocol.Proxy.Tests/AgentClientProtocol.Proxy.Tests.csproj --configuration Release -- --xunit-info

      - name: Collect ContainAI logs
        if: always()
        run: |
          mkdir -p /tmp/containai-logs
          cp -a ~/.config/containai/logs /tmp/containai-logs/ 2>/dev/null || true
          cp -a ~/.containai-test-* /tmp/containai-logs/ 2>/dev/null || true
          docker info > /tmp/containai-logs/docker-info.log 2>&1 || true

      - name: Upload ContainAI logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: containai-logs-test-${{ matrix.arch }}-${{ github.run_id }}
          path: /tmp/containai-logs/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E Tests (Sysbox/DinD) - GitHub-hosted runners
  # ============================================================================
  # Attempts to run E2E tests on GitHub-hosted runners. Sysbox requires kernel
  # module loading which may not work due to virtualization constraints.
  # This job gracefully skips if sysbox installation fails.
  #
  # Install flow: Downloads tarball artifact from build-tarballs job, tests
  # install.sh --local --yes --no-setup to verify the tarball install path works.
  # ============================================================================
  e2e-test:
    needs: [build-push, build-tarballs]
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    permissions:
      contents: read
      packages: read
    env:
      IMAGE_PREFIX: ${{ needs.build-push.outputs.image_prefix }}
      IMAGE_TAG: ${{ needs.build-push.outputs.tag_suffix }}
      CONTAINAI_TEST_IMAGE: ${{ needs.build-push.outputs.image_prefix }}/base:${{ needs.build-push.outputs.tag_suffix }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-24.04
          - arch: arm64
            runner: ubuntu-24.04-arm

    steps:
      # Always checkout repository - needed for test scripts and build metadata
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download tarball artifact
        uses: actions/download-artifact@v4
        with:
          name: containai-tarball-${{ matrix.arch }}
          path: /tmp/tarball

      - name: Extract and install from tarball
        run: |
          echo "============================================="
          echo "Installing from tarball artifact"
          echo "============================================="
          cd /tmp/tarball
          tar xzf containai-*.tar.gz
          cd containai-*/
          ./install.sh --local --yes --no-setup

      - name: Run cai setup
        env:
          CAI_YES: "1"
        run: |
          echo "============================================="
          echo "Running cai setup"
          echo "============================================="
          export PATH="$HOME/.local/bin:$PATH"
          cai setup --verbose

      - name: Log in to Container Registry (containai-docker)
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker --context containai-docker login ${{ env.REGISTRY }} -u "${{ github.actor }}" --password-stdin

      - name: Smoke test ACP proxy command
        run: |
          if command -v cai >/dev/null 2>&1; then
            echo "Testing cai acp proxy command..."
            if cai acp proxy --help >/dev/null 2>&1; then
              echo "cai acp proxy works"
            else
              echo "::error::cai acp proxy command failed"
              exit 1
            fi
          else
            echo "::error::cai binary not found on PATH"
            exit 1
          fi

      - name: Check kernel version
        id: kernel
        run: |
          echo "============================================="
          echo "Kernel Information"
          echo "============================================="
          uname -a
          echo "KERNEL_VERSION=$(uname -r)" >> "$GITHUB_OUTPUT"

      - name: Pull test images into containai-docker
        run: |
          docker --context containai-docker pull "${CONTAINAI_TEST_IMAGE}"
          docker --context containai-docker images | grep -E '^(containai|ghcr.io|REPOSITORY)' || true

      - name: Run E2E runtime smoke tests
        run: |
          echo "============================================="
          echo "Running runtime smoke tests"
          echo "============================================="
          docker --context containai-docker run --rm --runtime=sysbox-runc "${CONTAINAI_TEST_IMAGE}" cai version
          docker --context containai-docker run --rm --runtime=sysbox-runc "${CONTAINAI_TEST_IMAGE}" cai system init --help
          docker --context containai-docker run --rm --runtime=sysbox-runc "${CONTAINAI_TEST_IMAGE}" cai system link-repair --help

      - name: Collect sysbox logs
        if: always()
        run: |
          mkdir -p /tmp/sysbox-logs
          journalctl -u sysbox-mgr --no-pager > /tmp/sysbox-logs/sysbox-mgr.log 2>&1 || true
          journalctl -u sysbox-fs --no-pager > /tmp/sysbox-logs/sysbox-fs.log 2>&1 || true
          sudo cp -r /var/log/sysbox/ /tmp/sysbox-logs/ 2>/dev/null || true

      - name: Upload E2E test logs on failure
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-logs-${{ matrix.arch }}-${{ github.run_id }}
          path: |
            ~/.containai-test-*
            /tmp/sysbox-logs/
          retention-days: 7
          if-no-files-found: ignore

      - name: Collect ContainAI logs
        if: always()
        run: |
          mkdir -p /tmp/containai-logs
          cp -a ~/.config/containai/logs /tmp/containai-logs/ 2>/dev/null || true
          cp -a ~/.containai-test-* /tmp/containai-logs/ 2>/dev/null || true
          cp -a /tmp/containai-docker-info.log /tmp/containai-logs/ 2>/dev/null || true
          docker info > /tmp/containai-logs/docker-info.log 2>&1 || true
          docker --context containai-docker info > /tmp/containai-logs/containai-docker-info.log 2>&1 || true

      - name: Upload ContainAI logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: containai-logs-e2e-${{ matrix.arch }}-${{ github.run_id }}
          path: /tmp/containai-logs/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E Tests (macOS + Lima) - Intel (enabled)
  # ============================================================================
  e2e-test-macos-intel:
    needs: [lint, build-push, build-tarballs]
    runs-on: macos-15-intel
    timeout-minutes: 60
    permissions:
      contents: read
      packages: read
    env:
      IMAGE_PREFIX: ${{ needs.build-push.outputs.image_prefix }}
      IMAGE_TAG: ${{ needs.build-push.outputs.tag_suffix }}
      CONTAINAI_TEST_IMAGE: ${{ needs.build-push.outputs.image_prefix }}/base:${{ needs.build-push.outputs.tag_suffix }}
      IMAGE_ARCH: amd64
      TARBALL_ARCH: macos-x64
      EXPECTED_UNAME: x86_64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify runner architecture
        run: |
          machine="$(uname -m)"
          expected="${EXPECTED_UNAME}"
          if [[ "$machine" != "$expected" ]]; then
            echo "::error::Runner arch mismatch. Expected $expected, got $machine"
            exit 1
          fi

      - name: Download tarball artifact
        uses: actions/download-artifact@v4
        with:
          name: containai-tarball-${{ env.TARBALL_ARCH }}
          path: /tmp/tarball

      - name: Extract and install from tarball
        run: |
          echo "============================================="
          echo "Installing from tarball artifact"
          echo "============================================="
          cd /tmp/tarball
          tar xzf containai-*.tar.gz
          cd containai-*/
          ./install.sh --local --yes --no-setup

      - name: Run cai setup (Lima + Sysbox)
        env:
          CAI_YES: "1"
        run: |
          set -euo pipefail
          echo "============================================="
          echo "Running cai setup"
          echo "============================================="
          export PATH="$HOME/.local/bin:$PATH"
          setup_timeout_secs=1200

          run_cai_setup_with_timeout() {
            if command -v gtimeout >/dev/null 2>&1; then
              gtimeout "$setup_timeout_secs" cai setup --verbose
            else
              # macOS runners always have perl; use alarm() as a timeout fallback.
              perl -e 'alarm shift; exec @ARGV or die $!' "$setup_timeout_secs" cai setup --verbose
            fi
          }

          for attempt in 1 2; do
            echo "Attempt $attempt: cai setup --verbose (timeout ${setup_timeout_secs}s)"
            if run_cai_setup_with_timeout; then
              echo "cai setup succeeded"
              break
            fi
            setup_rc=$?
            if [[ $setup_rc -eq 124 || $setup_rc -eq 142 ]]; then
              echo "::warning::cai setup timed out on attempt $attempt after ${setup_timeout_secs}s"
            else
              echo "::warning::cai setup failed on attempt $attempt (rc=$setup_rc)"
            fi
            if [[ -d "$HOME/.config/containai/logs" ]]; then
              echo "Recent ContainAI logs:"
              while IFS= read -r file; do
                echo "--- $file (tail) ---"
                tail -n 20 "$file" || true
              done < <(find "$HOME/.config/containai/logs" -type f -name '*.log' 2>/dev/null | head -20 || true)
            fi
            limactl list || true
            if [[ "$attempt" -lt 2 ]]; then
              if command -v limactl >/dev/null 2>&1; then
                limactl delete -f containai-docker || true
              fi
              rm -rf "$HOME/.lima/containai-docker" || true
              echo "Retrying after Lima cleanup..."
              continue
            fi
            echo "::error::cai setup failed after retries"
            exit 1
          done

      - name: Ensure containai-docker context is ready
        run: |
          set -euo pipefail
          CONTEXT_NAME="${{ env.CONTAINAI_DOCKER_CONTEXT }}"
          if [[ -z "$CONTEXT_NAME" ]]; then
            CONTEXT_NAME="containai-docker"
          fi

          echo "============================================="
          echo "Context diagnostics + readiness checks"
          echo "============================================="
          docker context ls || true
          if ! docker context inspect "$CONTEXT_NAME" >/dev/null 2>&1; then
            echo "::error::Docker context '$CONTEXT_NAME' not found after cai setup"
            docker context ls || true
            exit 1
          fi

          context_host=$(docker context inspect "$CONTEXT_NAME" --format '{{.Endpoints.docker.Host}}' 2>/dev/null || true)
          echo "Context '$CONTEXT_NAME' endpoint: ${context_host:-unknown}"

          if [[ "$context_host" == unix://* ]]; then
            socket_path="${context_host#unix://}"
            echo "Waiting for context socket: $socket_path"
            for i in $(seq 1 60); do
              if [[ -S "$socket_path" ]]; then
                echo "Socket ready"
                break
              fi
              sleep 2
            done
            if [[ ! -S "$socket_path" ]]; then
              echo "::error::Context socket not available: $socket_path"
              ls -la "$(dirname "$socket_path")" || true
              exit 1
            fi
          fi

          echo "Waiting for Docker API via context '$CONTEXT_NAME'"
          for i in $(seq 1 60); do
            if docker --context "$CONTEXT_NAME" info >/tmp/containai-docker-info.log 2>&1; then
              echo "Docker context '$CONTEXT_NAME' is ready"
              break
            fi
            echo "Attempt $i/60: context not ready yet"
            tail -n 5 /tmp/containai-docker-info.log 2>/dev/null || true
            sleep 2
          done

          if ! docker --context "$CONTEXT_NAME" info >/dev/null 2>&1; then
            echo "::error::Docker context '$CONTEXT_NAME' not reachable"
            cat /tmp/containai-docker-info.log || true
            docker --context "$CONTEXT_NAME" version || true
            if command -v limactl >/dev/null 2>&1; then
              limactl list || true
            fi
            exit 1
          fi

      - name: Log in to Container Registry (containai-docker)
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker --context containai-docker login ${{ env.REGISTRY }} -u "${{ github.actor }}" --password-stdin

      - name: Pull images into Lima
        run: |
          docker --context containai-docker pull "${CONTAINAI_TEST_IMAGE}"
          docker --context containai-docker images | grep -E '^(containai|ghcr.io|REPOSITORY)' || true

      - name: Diagnose Lima iptables access
        run: |
          set +e
          VM_NAME="containai-docker"
          echo "============================================="
          echo "Lima iptables diagnostics"
          echo "============================================="
          limactl list || true
          limactl shell "$VM_NAME" -- sh -c 'id; uname -a' || true
          limactl shell "$VM_NAME" -- sh -c 'command -v sudo || true; command -v iptables || true; command -v iptables-nft || true' || true
          limactl shell "$VM_NAME" -- sh -c 'ls -l /usr/sbin/iptables /sbin/iptables /usr/bin/iptables /usr/sbin/iptables-nft /sbin/iptables-nft /usr/bin/iptables-nft 2>/dev/null || true' || true
          limactl shell "$VM_NAME" -- sh -c 'sudo -n true && echo "sudo-nopasswd=yes" || echo "sudo-nopasswd=no"' || true
          limactl shell "$VM_NAME" -- sh -c 'sudo -n iptables -S >/tmp/cai-iptables-s.out 2>/tmp/cai-iptables-s.err; echo "sudo iptables -S rc=$?"; cat /tmp/cai-iptables-s.err' || true
          limactl shell "$VM_NAME" -- sh -c 'sudo -n iptables-nft -S >/tmp/cai-iptables-nft-s.out 2>/tmp/cai-iptables-nft-s.err; echo "sudo iptables-nft -S rc=$?"; cat /tmp/cai-iptables-nft-s.err' || true
          limactl shell "$VM_NAME" -- sh -c 'sudo -n iptables -S DOCKER-USER >/tmp/cai-iptables-docker-user.out 2>/tmp/cai-iptables-docker-user.err; echo "sudo iptables -S DOCKER-USER rc=$?"; cat /tmp/cai-iptables-docker-user.err' || true

      - name: Run Secure Engine E2E smoke tests (macOS)
        run: |
          docker --context containai-docker run --rm --runtime=sysbox-runc "${CONTAINAI_TEST_IMAGE}" cai version
          docker --context containai-docker run --rm --runtime=sysbox-runc "${CONTAINAI_TEST_IMAGE}" cai system init --help

      - name: Collect Lima diagnostics
        if: always()
        run: |
          set +e
          VM_NAME="${{ env.CONTAINAI_DOCKER_CONTEXT }}"
          if [[ -z "$VM_NAME" ]]; then
            VM_NAME="containai-docker"
          fi
          echo "============================================="
          echo "Lima diagnostics (failure)"
          echo "============================================="
          mkdir -p /tmp/lima-logs
          limactl list > /tmp/lima-logs/limactl-list.log 2>&1 || true
          limactl info "$VM_NAME" > /tmp/lima-logs/limactl-info.log 2>&1 || true
          if [[ -d "$HOME/.lima/$VM_NAME" ]]; then
            cp -a "$HOME/.lima/$VM_NAME"/*.log /tmp/lima-logs/ 2>/dev/null || true
            cp -a "$HOME/.lima/$VM_NAME"/serial*.log /tmp/lima-logs/ 2>/dev/null || true
          fi
          if [[ -d "$HOME/Library/Logs/Lima" ]]; then
            cp -a "$HOME/Library/Logs/Lima" /tmp/lima-logs/ 2>/dev/null || true
          fi
          limactl shell "$VM_NAME" -- systemctl status docker > /tmp/lima-logs/docker-status.log 2>&1 || true
          limactl shell "$VM_NAME" -- journalctl -u docker --no-pager > /tmp/lima-logs/docker-journal.log 2>&1 || true
          limactl shell "$VM_NAME" -- journalctl -u sysbox-mgr --no-pager > /tmp/lima-logs/sysbox-mgr-journal.log 2>&1 || true
          limactl shell "$VM_NAME" -- journalctl -u sysbox-fs --no-pager > /tmp/lima-logs/sysbox-fs-journal.log 2>&1 || true

      - name: Upload Lima logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lima-logs-macos-15-intel-${{ github.run_id }}
          path: /tmp/lima-logs/
          retention-days: 7
          if-no-files-found: ignore

      - name: Collect ContainAI logs
        if: always()
        run: |
          mkdir -p /tmp/containai-logs
          cp -a ~/.config/containai/logs /tmp/containai-logs/ 2>/dev/null || true
          cp -a ~/.containai-test-* /tmp/containai-logs/ 2>/dev/null || true
          docker info > /tmp/containai-logs/docker-info.log 2>&1 || true
          docker --context containai-docker info > /tmp/containai-logs/containai-docker-info.log 2>&1 || true

      - name: Upload ContainAI logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: containai-logs-macos-macos-15-intel-${{ github.run_id }}
          path: /tmp/containai-logs/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E Tests (macOS + Lima) - ARM (disabled)
  # ============================================================================
  e2e-test-macos-arm:
    if: ${{ false }}
    needs: [lint, build-push, build-tarballs]
    runs-on: macos-26
    timeout-minutes: 60
    permissions:
      contents: read
      packages: read
    steps:
      - name: Skip macOS ARM E2E
        run: |
          echo "macOS ARM E2E is disabled on GitHub-hosted runners."
