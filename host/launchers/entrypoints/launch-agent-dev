#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2016
# Launch an agent in an isolated container with its own git workspace
# The container runs persistently for VS Code Remote connection

set -e

# Source shared functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=host/utils/common-functions.sh
source "$SCRIPT_DIR/../../utils/common-functions.sh"

detect_environment_profile
REPO_ROOT="$CONTAINAI_ROOT"

if [ "$CONTAINAI_PROFILE" = "dev" ]; then
    maybe_check_launcher_updates "$REPO_ROOT" "launch-agent-dev"
fi

if ! run_integrity_check_if_needed; then
    echo "‚ùå Integrity verification failed; aborting launch." >&2
    exit 1
fi

if ! ensure_prerequisites_verified "$REPO_ROOT"; then
    exit 1
fi

if ! verify_host_security_prereqs "$REPO_ROOT"; then
    exit 1
fi

TRUSTED_PATHS=("host/launchers" "docker/runtime" "host/profiles")
TRUSTED_TREE_LABEL="launcher + helper files"
if [ "$CONTAINAI_PROFILE" = "dev" ]; then
    if ! ensure_trusted_paths_clean "$REPO_ROOT" "$TRUSTED_TREE_LABEL" "${TRUSTED_PATHS[@]}"; then
        exit 1
    fi
fi

if [ "$SOURCE_TYPE" = "local" ] && [ -f "$SOURCE/config.toml" ]; then
    SESSION_CONFIG_SOURCE="$SOURCE/config.toml"
fi

if [ -z "$SESSION_CONFIG_SOURCE" ] && [ -f "${HOME}/.config/containai/config.toml" ]; then
    SESSION_CONFIG_SOURCE="${HOME}/.config/containai/config.toml"
fi

LAUNCHER_HEAD_HASH=$(get_git_head_hash "$REPO_ROOT" 2>/dev/null || echo "")
TRUSTED_TREE_HASHES_RAW=$(collect_trusted_tree_hashes "$REPO_ROOT" "${TRUSTED_PATHS[@]}")
TRUSTED_TREE_HASHES_ENV=$(printf '%s' "$TRUSTED_TREE_HASHES_RAW" | tr '\n' ',' | sed 's/,$//')

if [ -n "$LAUNCHER_HEAD_HASH" ]; then
    echo "üîí Launcher commit: $LAUNCHER_HEAD_HASH"
fi
if [ -n "$TRUSTED_TREE_HASHES_RAW" ]; then
    echo "   Trusted tree hashes:"
    while IFS= read -r entry; do
        [ -z "$entry" ] && continue
        echo "     ‚Ä¢ $entry"
    done <<< "$TRUSTED_TREE_HASHES_RAW"
fi

SESSION_ARTIFACT_DIR=""
cleanup_session_artifacts() {
    local cache_root="${CONTAINAI_SESSION_CACHE:-${HOME:-/tmp}/.containai/session-cache}"
    if [ -n "$CONTAINER_NAME" ] && [ -d "$cache_root/${CONTAINER_NAME}" ]; then
        rm -rf "${cache_root:?}/${CONTAINER_NAME}"
    fi
    if [ -n "$PROXY_CONTAINER_NAME" ]; then
        stop_proxy_log_pipeline "$PROXY_CONTAINER_NAME"
    fi
}
trap cleanup_session_artifacts EXIT

SESSION_CONFIG_OUTPUT=""
SESSION_ID_FILE=""
SESSION_MANIFEST_PATH=""
SESSION_CONFIG_SHA256=""
SESSION_CONFIG_SOURCE=""
SESSION_CONFIG_RENDERED=false
SESSION_ID_BASE=$(date -u +"%Y%m%dT%H%M%SZ")
SESSION_CACHE_ROOT="${CONTAINAI_SESSION_CACHE:-${HOME}/.containai/session-cache}"

# Default values
AGENT=""
SOURCE="."
BRANCH=""
BRANCH_FROM_FLAG=false
NAME=""
DOTNET_PREVIEW=""
NETWORK_PROXY="squid"
CPU="4"
MEMORY="8g"
GPU=""
NO_PUSH=false
FORCE=false
USE_CURRENT_BRANCH=false
LOCAL_REMOTE_HOST_PATH=""
LOCAL_REMOTE_WSL_PATH=""
LOCAL_REMOTE_URL=""
LOCAL_REPO_PATH_VALUE=""
TMPFS_LARGE_SIZE="${CONTAINAI_TMPFS_LARGE:-2g}"
TMPFS_SMALL_SIZE="${CONTAINAI_TMPFS_SMALL:-512m}"
TMPFS_SECRET_SIZE="${CONTAINAI_TMPFS_SECRETS:-32m}"
DEFAULT_BROKER_STUBS=("github" "uno" "msftdocs" "playwright" "context7" "serena" "sequential-thinking" "fetch")
BROKER_STUBS=("${DEFAULT_BROKER_STUBS[@]}")
PROXY_SECCOMP_PROFILE_PATH="${REPO_ROOT}/host/profiles/seccomp-containai-proxy.json"
PROXY_APPARMOR_PROFILE="containai-proxy"
LOG_FORWARDER_SECCOMP_PROFILE_PATH="${REPO_ROOT}/host/profiles/seccomp-containai-log-forwarder.json"
LOG_BROKER_SECCOMP_PROFILE_PATH="${REPO_ROOT}/host/profiles/seccomp-containai-log-forwarder.json"
LOG_FORWARDER_APPARMOR_PROFILE="containai-log-forwarder"
LOG_BROKER_APPARMOR_PROFILE="containai-log-forwarder"
declare -A MCP_SECRET_VALUES=()
declare -A SESSION_STUB_SECRETS=()
declare -A SESSION_SECRET_FILE_SOURCES=()
declare -A AGENT_CLI_SECRET_TYPES=()
declare -A AGENT_CLI_SECRET_SOURCES=()
declare -A AGENT_CLI_SECRET_DIGESTS=()
declare -A AGENT_CLI_SECRET_NAMES_BY_STUB=()
declare -A AGENT_CLI_AGENT_NAME_BY_STUB=()
declare -a AGENT_CLI_STUBS=()

trim_whitespace() {
    local value="$1"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"
    printf '%s' "$value"
}

load_mcp_secret_values() {
    local -a candidates=()
    declare -A seen_map=()
    if [ -n "${CONTAINAI_MCP_SECRETS_FILE:-}" ]; then
        candidates+=("${CONTAINAI_MCP_SECRETS_FILE}")
    fi
    if [ -n "${MCP_SECRETS_FILE:-}" ]; then
        candidates+=("${MCP_SECRETS_FILE}")
    fi
    candidates+=("${HOME}/.config/containai/mcp-secrets.env" "${HOME}/.mcp-secrets.env")
    local candidate resolved
    for candidate in "${candidates[@]}"; do
        [ -n "$candidate" ] || continue
        resolved=$(realpath "$candidate" 2>/dev/null || echo "$candidate")
        if [ -n "${seen_map[$resolved]:-}" ]; then
            continue
        fi
        seen_map["$resolved"]=1
        if [ ! -f "$candidate" ]; then
            continue
        fi
        while IFS= read -r line || [ -n "$line" ]; do
            line=$(trim_whitespace "$line")
            [ -n "$line" ] || continue
            [[ "$line" == \#* ]] && continue
            if [[ "$line" == export* ]]; then
                line="${line#export }"
                line=$(trim_whitespace "$line")
            fi
            if [[ "$line" != *=* ]]; then
                continue
            fi
            local name="${line%%=*}"
            local value="${line#*=}"
            name=$(trim_whitespace "$name")
            value=$(trim_whitespace "$value")
            if [ -z "$name" ]; then
                continue
            fi
            if [ -n "$value" ] && [[ ( "$value" == "\""*"\"" ) || ( "$value" == "'"*"'" ) ]]; then
                value="${value:1:${#value}-2}"
            fi
            if [ -z "${MCP_SECRET_VALUES[$name]+x}" ]; then
                MCP_SECRET_VALUES["$name"]="$value"
            fi
        done < "$candidate"
    done
}

resolve_secret_value() {
    local key="$1"
    if [ -z "$key" ]; then
        return 1
    fi
    if [ -n "${MCP_SECRET_VALUES[$key]:-}" ]; then
        printf '%s' "${MCP_SECRET_VALUES[$key]}"
        return 0
    fi
    if [ -n "${!key:-}" ]; then
        MCP_SECRET_VALUES["$key"]="${!key}"
        printf '%s' "${!key}"
        return 0
    fi
    return 1
}

compute_sha256_for_file() {
    local path="$1"
    if command -v sha256sum >/dev/null 2>&1; then
        sha256sum "$path" | awk '{print $1}'
    elif command -v shasum >/dev/null 2>&1; then
        shasum -a 256 "$path" | awk '{print $1}'
    else
        echo "" && return 1
    fi
}

compute_sha256_for_string() {
    local value="$1"
    if command -v sha256sum >/dev/null 2>&1; then
        printf '%s' "$value" | sha256sum | awk '{print $1}'
    elif command -v shasum >/dev/null 2>&1; then
        printf '%s' "$value" | shasum -a 256 | awk '{print $1}'
    else
        echo "" && return 1
    fi
}

append_unique_value() {
    local value="$1"
    shift || true
    local existing
    for existing in "$@"; do
        if [ "$existing" = "$value" ]; then
            return 1
        fi
    done
    return 0
}

register_agent_cli_secret() {
    local agent_name="$1"
    local stub_name="$2"
    local secret_name="$3"
    local source_type="$4"
    local source_label="$5"
    local data_source="$6"
    local digest_value="$7"

    if append_unique_value "$stub_name" "${BROKER_STUBS[@]}"; then
        BROKER_STUBS+=("$stub_name")
    fi
    if append_unique_value "$stub_name" "${AGENT_CLI_STUBS[@]}"; then
        AGENT_CLI_STUBS+=("$stub_name")
    fi

    local current="${SESSION_STUB_SECRETS[$stub_name]:-}"
    if [ -n "$current" ]; then
        SESSION_STUB_SECRETS["$stub_name"]="$current $secret_name"
    else
        SESSION_STUB_SECRETS["$stub_name"]="$secret_name"
    fi

    if [ "$source_type" = "file" ]; then
        SESSION_SECRET_FILE_SOURCES["$secret_name"]="$data_source"
    else
        MCP_SECRET_VALUES["$secret_name"]="$data_source"
    fi

    AGENT_CLI_SECRET_TYPES["$secret_name"]="$source_type"
    AGENT_CLI_SECRET_SOURCES["$secret_name"]="$source_label"
    AGENT_CLI_SECRET_DIGESTS["$secret_name"]="$digest_value"
    AGENT_CLI_SECRET_NAMES_BY_STUB["$stub_name"]="${AGENT_CLI_SECRET_NAMES_BY_STUB[$stub_name]:+${AGENT_CLI_SECRET_NAMES_BY_STUB[$stub_name]} }$secret_name"
    AGENT_CLI_AGENT_NAME_BY_STUB["$stub_name"]="$agent_name"
}

detect_copilot_cli_secret() {
    local host_cfg="${HOME}/.copilot/config.json"
    if [ ! -f "$host_cfg" ]; then
        echo "‚ùå Copilot credentials not found at $host_cfg" >&2
        if [ "${CONTAINAI_ALLOW_AGENT_WITHOUT_SECRETS:-0}" = "1" ]; then
            echo "   Continuing due to CONTAINAI_ALLOW_AGENT_WITHOUT_SECRETS=1" >&2
            return 1
        fi
        exit 1
    fi
    local digest
    digest=$(compute_sha256_for_file "$host_cfg") || digest=""
    register_agent_cli_secret "copilot" "agent_copilot_cli" "copilot_cli_config_json" "file" "$host_cfg" "$host_cfg" "$digest"
    echo "üîê Copilot CLI credential detected (sha256=${digest:-unknown})"
}

detect_codex_cli_secret() {
    local host_cfg="${HOME}/.codex/auth.json"
    if [ ! -f "$host_cfg" ]; then
        echo "‚ùå Codex credentials not found at $host_cfg" >&2
        if [ "${CONTAINAI_ALLOW_AGENT_WITHOUT_SECRETS:-0}" = "1" ]; then
            echo "   Continuing due to CONTAINAI_ALLOW_AGENT_WITHOUT_SECRETS=1" >&2
            return 1
        fi
        exit 1
    fi
    local digest
    digest=$(compute_sha256_for_file "$host_cfg") || digest=""
    register_agent_cli_secret "codex" "agent_codex_cli" "codex_cli_auth_json" "file" "$host_cfg" "$host_cfg" "$digest"
    echo "üîê Codex CLI credential detected (sha256=${digest:-unknown})"
}

detect_claude_cli_secret() {
    local file_cfg="${HOME}/.claude/.credentials.json"
    if [ -f "$file_cfg" ]; then
        local digest
        digest=$(compute_sha256_for_file "$file_cfg") || digest=""
        register_agent_cli_secret "claude" "agent_claude_cli" "claude_cli_credentials" "file" "$file_cfg" "$file_cfg" "$digest"
        echo "üîê Claude CLI credential detected from $file_cfg (sha256=${digest:-unknown})"
        return 0
    fi
    if [ -n "${CLAUDE_API_KEY:-}" ]; then
        local digest
        digest=$(compute_sha256_for_string "$CLAUDE_API_KEY") || digest=""
        register_agent_cli_secret "claude" "agent_claude_cli" "claude_cli_credentials" "inline" "env:CLAUDE_API_KEY" "$CLAUDE_API_KEY" "$digest"
        echo "üîê Claude CLI credential detected from CLAUDE_API_KEY environment (sha256=${digest:-unknown})"
        return 0
    fi
    echo "‚ùå Claude credentials missing (expected ~/.claude/.credentials.json or CLAUDE_API_KEY)" >&2
    if [ "${CONTAINAI_ALLOW_AGENT_WITHOUT_SECRETS:-0}" = "1" ]; then
        echo "   Continuing due to CONTAINAI_ALLOW_AGENT_WITHOUT_SECRETS=1" >&2
        return 1
    fi
    exit 1
}

detect_agent_cli_secrets() {
    case "$AGENT" in
        copilot)
            detect_copilot_cli_secret || true
            ;;
        codex)
            detect_codex_cli_secret || true
            ;;
        claude)
            detect_claude_cli_secret || true
            ;;
    esac
}

write_agent_cli_manifest() {
    local manifest_path="$1"
    local stub="$2"
    local agent_name="$3"
    local session_id="$4"
    local secret_list="$5"
    local metadata_lines=""
    local secret
    for secret in $secret_list; do
        local label="${AGENT_CLI_SECRET_SOURCES[$secret]:-unknown}"
        local digest="${AGENT_CLI_SECRET_DIGESTS[$secret]:-}"
        metadata_lines+="$secret|$label|$digest"
        metadata_lines+=$'\n'
    done
    AGENT_CLI_SECRET_META="$metadata_lines" python3 - "$manifest_path" "$agent_name" "$stub" "$session_id" <<'PY'
import json
import os
import sys

if len(sys.argv) < 5:
    raise SystemExit(1)

manifest_path = sys.argv[1]
agent_name = sys.argv[2]
stub_name = sys.argv[3]
session_id = sys.argv[4]
meta = os.environ.get("AGENT_CLI_SECRET_META", "").strip().splitlines()
entries = []
for line in meta:
    if not line.strip():
        continue
    parts = line.split("|", 2)
    if len(parts) != 3:
        continue
    entries.append({
        "name": parts[0],
        "source": parts[1],
        "sha256": parts[2],
    })
doc = {
    "agent": agent_name,
    "stub": stub_name,
    "session": session_id,
    "secrets": entries,
}
with open(manifest_path, "w", encoding="utf-8") as handle:
    json.dump(doc, handle, indent=2)
PY
}

stage_agent_cli_capability_bundles() {
    local stub
    for stub in "${AGENT_CLI_STUBS[@]}"; do
        local agent_name="${AGENT_CLI_AGENT_NAME_BY_STUB[$stub]:-}"
        [ -n "$agent_name" ] || continue
        local source_dir="$BROKER_CAP_DIR/$stub"
        if [ ! -d "$source_dir" ]; then
            echo "‚ö†Ô∏è  Capability directory missing for stub '$stub'" >&2
            continue
        fi
        local dest_root="$SESSION_CONFIG_OUTPUT/$agent_name/cli"
        mkdir -p "$dest_root/capabilities"
        cp -a "$source_dir/." "$dest_root/capabilities/" >/dev/null 2>&1 || true
        write_agent_cli_manifest "$dest_root/manifest.json" "$stub" "$agent_name" "$SESSION_ID" "${AGENT_CLI_SECRET_NAMES_BY_STUB[$stub]}"
    done
}

package_agent_data_payload() {
    local agent_name="$1"
    local packager_script="$REPO_ROOT/host/utils/package-agent-data.py"
    if [ ! -f "$packager_script" ]; then
        return 0
    fi
    local data_dir="$SESSION_CONFIG_OUTPUT/$agent_name/data"
    mkdir -p "$data_dir"
    local tar_path="$data_dir/data-import.tar"
    local manifest_path="$data_dir/manifest.json"
    local -a runner_mounts=("--mount" "$SESSION_CONFIG_OUTPUT")
    local -a packager_args=(
        "--agent" "$agent_name"
        "--session-id" "$SESSION_ID"
        "--tar" "$tar_path"
        "--manifest" "$manifest_path"
    )
    if [ -n "${HOME:-}" ]; then
        packager_args+=("--home-path" "$HOME")
    fi
    if run_python_tool "$packager_script" "${runner_mounts[@]}" -- "${packager_args[@]}" >/dev/null 2>&1; then
        if [ -f "$tar_path" ] && [ -s "$tar_path" ]; then
            chmod 600 "$tar_path" 2>/dev/null || true
            echo "üì¶ Packaged ${agent_name} data import archive"
        else
            rm -f "$tar_path" "$manifest_path"
            echo "‚ÑπÔ∏è  No host data discovered for ${agent_name} data import"
        fi
    else
        echo "‚ö†Ô∏è  Failed to package host data for agent '${agent_name}'" >&2
        rm -f "$tar_path" "$manifest_path"
    fi
}

parse_stub_secret_manifest() {
    local file="$1"
    [ -f "$file" ] || return 0
    while IFS= read -r line || [ -n "$line" ]; do
        line=${line%%#*}
        line=$(trim_whitespace "$line")
        [ -n "$line" ] || continue
        local stub="${line%% *}"
        local rest="${line#"${stub}"}"
        rest=$(trim_whitespace "$rest")
        [ -n "$stub" ] || continue
        [ -n "$rest" ] || continue
        SESSION_STUB_SECRETS["$stub"]="$rest"
    done < "$file"
}

store_stub_secrets() {
    local broker_script="$1"
    local stub
    for stub in "${!SESSION_STUB_SECRETS[@]}"; do
        local names="${SESSION_STUB_SECRETS[$stub]}"
        [ -n "$names" ] || continue
        local name
        for name in $names; do
            local file_source="${SESSION_SECRET_FILE_SOURCES[$name]:-}"
            if [ -n "$file_source" ]; then
                if ! run_python_tool "$broker_script" -- store --stub "$stub" --name "$name" --from-file "$file_source" >/dev/null 2>&1; then
                    echo "‚ùå Failed to store secret '$name' for stub '$stub'" >&2
                    return 1
                fi
                continue
            fi
            local value
            value=$(resolve_secret_value "$name") || value=""
            if [ -z "$value" ]; then
                echo "‚ö†Ô∏è  Missing secret '$name' for stub '$stub'" >&2
                continue
            fi
            if ! CONTAINAI_SECRET_VALUE="$value" run_python_tool "$broker_script" -- store --stub "$stub" --name "$name" --from-env CONTAINAI_SECRET_VALUE >/dev/null 2>&1; then
                echo "‚ùå Failed to store secret '$name' for stub '$stub'" >&2
                return 1
            fi
        done
    done
    return 0
}

seal_stub_capabilities() {
    local broker_script="$1"
    local cap_root="$2"
    local stub
    for stub in "${!SESSION_STUB_SECRETS[@]}"; do
        local names="${SESSION_STUB_SECRETS[$stub]}"
        [ -n "$names" ] || continue
        local cap_dir="$cap_root/$stub"
        if [ ! -d "$cap_dir" ]; then
            echo "‚ö†Ô∏è  Capability directory missing for stub '$stub'" >&2
            continue
        fi
        local cap_file
        cap_file=$(find "$cap_dir" -maxdepth 1 -name '*.json' | head -n1)
        if [ -z "$cap_file" ]; then
            echo "‚ö†Ô∏è  No capability token found for stub '$stub'" >&2
            continue
        fi
        local redeem_args=("--capability" "$cap_file")
        local name
        for name in $names; do
            redeem_args+=("--secret" "$name")
        done
        if ! run_python_tool "$broker_script" --mount "$cap_root" -- "redeem" "${redeem_args[@]}" >/dev/null 2>&1; then
            echo "‚ùå Failed to seal secrets for stub '$stub'" >&2
            return 1
        fi
    done
    return 0
}

ensure_data_hmac_key() {
    local agent_name="$1"
    local session_id="$2"
    local dest_path="$3"
    if [ ! -f "$dest_path" ]; then
        local key_hex
        if command -v openssl >/dev/null 2>&1; then
            key_hex=$(openssl rand -hex 32 2>/dev/null || true)
        fi
        if [ -z "$key_hex" ]; then
            key_hex=$(python3 - <<'PY'
import secrets
print(secrets.token_hex(32))
PY
)
        fi
        printf '%s\n' "$key_hex" > "$dest_path"
        chmod 600 "$dest_path" 2>/dev/null || true
    fi
    local host_store="${HOME}/.config/containai/data-hmac/${agent_name}"
    mkdir -p "$host_store"
    cp "$dest_path" "$host_store/${session_id}.key"
    chmod 600 "$host_store/${session_id}.key" 2>/dev/null || true
}

# First argument must be agent type
if [[ $# -eq 0 || "$1" == "-"* ]]; then
    echo "‚ùå Error: Agent type is required as first argument"
    echo "Usage: launch-agent <agent> [SOURCE] [OPTIONS]"
    echo "Agent types: copilot, codex, claude"
    exit 1
fi

AGENT="$1"
shift

# Validate agent
case "$AGENT" in
    copilot|codex|claude) ;;
    *)
        echo "‚ùå Error: Invalid agent type '$AGENT'"
        echo "Valid options: copilot, codex, claude"
        exit 1
        ;;
esac

# Parse remaining arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--branch)
            BRANCH="$2"
            BRANCH_FROM_FLAG=true
            shift 2
            ;;
        --name)
            NAME="$2"
            shift 2
            ;;
        --dotnet-preview)
            DOTNET_PREVIEW="$2"
            shift 2
            ;;
        --network-proxy)
            NETWORK_PROXY="$2"
            shift 2
            ;;
        --cpu)
            CPU="$2"
            shift 2
            ;;
        --memory)
            MEMORY="$2"
            shift 2
            ;;
        --gpu)
            GPU="$2"
            shift 2
            ;;
        --no-push)
            NO_PUSH=true
            shift
            ;;
        --use-current-branch)
            USE_CURRENT_BRANCH=true
            shift
            ;;
        -y|--force)
            FORCE=true
            shift
            ;;
        -h|--help)
            echo "Usage: launch-agent <agent> [SOURCE] [OPTIONS]"
            echo ""
            echo "Agent types: copilot, codex, claude"
            echo ""
            echo "SOURCE can be:"
            echo "  ‚Ä¢ Local path to a git repository (default: current directory)"
            echo "  ‚Ä¢ Git URL (https://...)"
            echo ""
            echo "Options:"
            echo "  -b, --branch BRANCH         Branch name (creates <agent>/<branch>)"
            echo "  --name NAME                 Custom container name"
            echo "  --dotnet-preview CHANNEL    Install .NET preview SDK (e.g., 11.0)"
            echo "  --network-proxy MODE        Network proxy: allow-all, restricted, squid (default: allow-all)"
            echo "  --cpu NUM                   CPU limit (default: 4)"
            echo "  --memory SIZE               Memory limit (default: 8g)"
            echo "  --gpu SPEC                  GPU specification (e.g., 'all' or 'device=0')"
            echo "  --no-push                   Disable auto-push on container shutdown"
            echo "  --use-current-branch        Use current branch instead of creating agent branch (unsafe)"
            echo "  -y, --force                 Automatically replace existing agent branch without prompting"
            echo "  -h, --help                  Show this help"
            echo ""
            echo "Branch Behavior:"
            echo "  ‚Ä¢ Without --branch: creates unique session branch <agent>/session-N"
            echo "  ‚Ä¢ With --branch: creates <agent>/<branch>"
            echo "  ‚Ä¢ Already on agent branch: reuses that branch"
            echo "  ‚Ä¢ Use --use-current-branch to work directly on current branch"
            echo "  ‚Ä¢ Existing agent branches prompt for replacement"
            echo "  ‚Ä¢ Branches with unmerged commits are archived before replacement"
            echo ""
            echo "Examples:"
            echo "  launch-agent copilot                              # Copilot in current directory"
            echo "  launch-agent codex . -b refactor-db               # Codex in current dir, custom branch"
            echo "  launch-agent copilot https://github.com/user/repo # Copilot from GitHub"
            echo "  launch-agent claude /path/to/repo --name my-workspace"
            echo "  launch-agent copilot . -b feature-api -y          # Auto-replace existing agent branch"
            exit 0
            ;;
        *)
            SOURCE="$1"
            shift
            ;;
    esac
done

# Validate network proxy option (proxy required)
case "$NETWORK_PROXY" in
    squid) ;;
    allow-all|none|restricted)
        echo "‚ö†Ô∏è  Network proxy '$NETWORK_PROXY' is not allowed; forcing squid mode"
        NETWORK_PROXY="squid"
        ;;
    *)
        echo "‚ùå Error: Invalid --network-proxy value '$NETWORK_PROXY'"
        exit 1
        ;;
esac

# Check Docker
check_docker_running || exit 1
if ! verify_container_security_support; then
    exit 1
fi
CONTAINER_CLI=$(get_active_container_cmd)

# Determine if source is URL or local path
if [[ "$SOURCE" =~ ^https?:// ]]; then
    IS_URL=true
    SOURCE_TYPE="url"
    REPO_NAME=$(basename "$SOURCE" .git)
    GIT_URL="$SOURCE"
    WSL_PATH=""
else
    IS_URL=false
    SOURCE_TYPE="local"
    SOURCE=$(realpath "$SOURCE")
    
    # Check if git repository
    if [ ! -d "$SOURCE/.git" ]; then
        echo "‚ùå Error: $SOURCE is not a git repository"
        exit 1
    fi
    
    REPO_NAME=$(basename "$SOURCE")
    cd "$SOURCE"
    cd - > /dev/null
    WSL_PATH=$(convert_to_wsl_path "$SOURCE")
    GIT_URL=""
    LOCAL_REPO_PATH_VALUE="$WSL_PATH"

    if [ "$NO_PUSH" != true ]; then
        if command -v shasum >/dev/null 2>&1; then
            REMOTE_HASH=$(printf "%s" "$SOURCE" | shasum -a 256 | awk '{print $1}')
        else
            REMOTE_HASH=$(printf "%s" "$SOURCE" | sha256sum | awk '{print $1}')
        fi
        REMOTE_HASH=${REMOTE_HASH:0:16}
        LOCAL_REMOTE_DIR="${CONTAINAI_LOCAL_REMOTES_DIR:-${HOME}/.containai/local-remotes}"
        LOCAL_REMOTE_HOST_PATH="$LOCAL_REMOTE_DIR/${REMOTE_HASH}.git"
        mkdir -p "$LOCAL_REMOTE_DIR"
        if [ ! -d "$LOCAL_REMOTE_HOST_PATH" ]; then
            git init --bare "$LOCAL_REMOTE_HOST_PATH" >/dev/null
        fi
        LOCAL_REMOTE_WSL_PATH=$(convert_to_wsl_path "$LOCAL_REMOTE_HOST_PATH")
        LOCAL_REMOTE_URL="file:///tmp/local-remote"
        LOCAL_REPO_PATH_VALUE="$LOCAL_REMOTE_URL"
    fi

    if [ "$NO_PUSH" != true ] && [ -z "$LOCAL_REMOTE_URL" ]; then
        echo "‚ùå Failed to configure secure local remote for auto-push"
        exit 1
    fi
fi

if [ "$USE_CURRENT_BRANCH" = "true" ]; then
    if [ "$SOURCE_TYPE" != "local" ]; then
        echo "‚ùå Error: --use-current-branch is only supported for local repositories"
        exit 1
    fi
    if [ "$BRANCH_FROM_FLAG" = "true" ]; then
        echo "‚ùå Error: --use-current-branch cannot be combined with --branch"
        exit 1
    fi
fi

# Restricted network cannot clone URLs
if [ "$NETWORK_PROXY" = "restricted" ] && [ "$SOURCE_TYPE" = "url" ]; then
    echo "‚ùå Restricted network mode cannot clone from a URL. Provide a local path or use --network-proxy allow-all."
    exit 1
fi

# Helper: Check if branch name follows agent naming convention
is_agent_branch() {
    local branch_name="$1"
    [[ "$branch_name" =~ ^(copilot|codex|claude)/ ]]
}

# Determine branch name with safety checks
if [ -z "$BRANCH" ]; then
    if [ "$SOURCE_TYPE" = "local" ]; then
        cd "$SOURCE"
        CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        cd - > /dev/null
        
        # Safety: Never use current branch unless explicitly allowed and available
        if [ "$USE_CURRENT_BRANCH" = "true" ]; then
            if [ -z "$CURRENT_BRANCH" ]; then
                echo "‚ùå Error: Repository is in detached HEAD state; cannot use --use-current-branch"
                exit 1
            fi
            BRANCH="$CURRENT_BRANCH"
            echo "‚ö†Ô∏è  Warning: Using current branch directly (--use-current-branch specified)"
        elif is_agent_branch "$CURRENT_BRANCH"; then
            # Current branch is already an agent branch, safe to use
            BRANCH="$CURRENT_BRANCH"
            echo "‚úì Current branch '$CURRENT_BRANCH' is an agent branch"
        else
            # Generate unique session branch
            SESSION_NUM=$(find_next_session "$SOURCE" "$AGENT")
            BRANCH="session-${SESSION_NUM}"
            echo "‚ÑπÔ∏è  Creating new branch '${AGENT}/${BRANCH}' (current: ${CURRENT_BRANCH:-main})"
        fi
    else
        BRANCH="main"
    fi
fi

if ! validate_branch_name "$BRANCH"; then
    echo "‚ùå Error: Invalid branch name '$BRANCH'"
    echo "   Branch names must start with alphanumeric characters and avoid spaces"
    exit 1
fi

# Sanitize branch name for container naming
SAFE_BRANCH=$(echo "$BRANCH" | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')

# Determine container names
if [ -n "$NAME" ]; then
    if ! validate_container_name "$NAME"; then
        echo "‚ùå Error: Invalid custom name '$NAME'"
        echo "   Container names must start with alphanumeric characters and may include . _ -"
        exit 1
    fi
    CONTAINER_NAME="${AGENT}-${NAME}$(get_profile_suffix)"
    WORKSPACE_NAME="$NAME"
else
    CONTAINER_NAME="${AGENT}-${REPO_NAME}-${SAFE_BRANCH}$(get_profile_suffix)"
    WORKSPACE_NAME="$REPO_NAME"
fi

if ! validate_container_name "$CONTAINER_NAME"; then
    echo "‚ùå Error: Generated container name '$CONTAINER_NAME' is invalid"
    echo "   Adjust --name, repository, or branch values to avoid unsupported characters"
    exit 1
fi

SESSION_ARTIFACT_DIR="${SESSION_CACHE_ROOT}/${CONTAINER_NAME}"
SESSION_CONFIG_OUTPUT="$SESSION_ARTIFACT_DIR/session-config"
mkdir -p "$SESSION_CONFIG_OUTPUT"
SESSION_ID_FILE="$SESSION_CONFIG_OUTPUT/session.id"
if [ -f "$SESSION_ID_FILE" ]; then
    SESSION_ID=$(cat "$SESSION_ID_FILE")
else
    SESSION_ID="${CONTAINER_NAME}-${SESSION_ID_BASE}-${RANDOM}"
    printf '%s\n' "$SESSION_ID" > "$SESSION_ID_FILE"
fi
SESSION_MITM_DIR="$SESSION_CONFIG_OUTPUT/mitm"
PROXY_MITM_CA_CERT="$SESSION_MITM_DIR/proxy-ca.crt"
PROXY_MITM_CA_KEY="$SESSION_MITM_DIR/proxy-ca.key"
if [ -f "$PROXY_MITM_CA_CERT" ] && [ -f "$PROXY_MITM_CA_KEY" ]; then
    chmod 600 "$PROXY_MITM_CA_CERT" "$PROXY_MITM_CA_KEY" 2>/dev/null || true
else
    if ! generate_session_mitm_ca "$SESSION_MITM_DIR"; then
        echo "‚ùå Failed to generate per-session MITM CA" >&2
        exit 1
    fi
    PROXY_MITM_CA_CERT="$SESSION_MITM_DIR/proxy-ca.crt"
    PROXY_MITM_CA_KEY="$SESSION_MITM_DIR/proxy-ca.key"
fi

WORKSPACE_VOLUME=$(get_container_volume_name "$CONTAINER_NAME" "workspace")
HOME_VOLUME=$(get_container_volume_name "$CONTAINER_NAME" "home")
TOOLCACHE_VOLUME=$(get_container_volume_name "$CONTAINER_NAME" "toolcache")

# Determine agent branch (handle case where BRANCH is already agent/branch format)
if [ "$USE_CURRENT_BRANCH" = "true" ]; then
    AGENT_BRANCH="$BRANCH"
elif is_agent_branch "$BRANCH"; then
    AGENT_BRANCH="$BRANCH"
else
    AGENT_BRANCH="${AGENT}/${BRANCH}"
fi

PROXY_CONTAINER_NAME="${CONTAINER_NAME}-proxy"
PROXY_NETWORK_NAME="${CONTAINER_NAME}-net"
PROXY_IMAGE="$(if [ -n "${CONTAINAI_IMAGE_DIGEST_PROXY:-}" ]; then echo "containai-proxy@${CONTAINAI_IMAGE_DIGEST_PROXY}"; else echo "containai-proxy:local"; fi)"
LOG_FORWARDER_IMAGE="$(if [ -n "${CONTAINAI_IMAGE_DIGEST_LOG_FORWARDER:-}" ]; then echo "containai-log-forwarder@${CONTAINAI_IMAGE_DIGEST_LOG_FORWARDER}"; else echo "containai-log-forwarder:local"; fi)"
LOG_BROKER_IMAGE="${CONTAINAI_LOG_BROKER_IMAGE:-$LOG_FORWARDER_IMAGE}"

# Pull latest image
pull_and_tag_image "$AGENT"
IMAGE_NAME="containai-${AGENT}:local"
if [ -n "${CONTAINAI_IMAGE_DIGEST:-}" ]; then
    IMAGE_NAME="containai-${AGENT}@${CONTAINAI_IMAGE_DIGEST}"
fi

# Get timezone
TZ_VALUE="${TZ:-$(cat /etc/timezone 2>/dev/null || echo UTC)}"

# Squid allowed domains
SQUID_ALLOWED_DOMAINS="*.github.com,*.githubcopilot.com,*.nuget.org,*.npmjs.org,*.pypi.org,*.python.org,*.microsoft.com,*.docker.io,registry-1.docker.io,api.githubcopilot.com,learn.microsoft.com,platform.uno,*.githubusercontent.com,*.azureedge.net"
SQUID_HELPER_ACL_FILE="$SESSION_CONFIG_OUTPUT/squid-acls.conf"
PROXY_LOG_ROOT="${HOME}/.containai/logs/proxy"
PROXY_LOG_DIR="${PROXY_LOG_ROOT}/${CONTAINER_NAME}/${SESSION_ID}"
PROXY_LOG_CERT_DIR="${SESSION_CONFIG_OUTPUT}/log-broker"

# Determine network mode
NETWORK_MODE="$PROXY_NETWORK_NAME"
NETWORK_POLICY_ENV="squid"
PROXY_URL="http://${PROXY_CONTAINER_NAME}:3128"
pull_and_tag_image "proxy"

SESSION_CONFIG_ROOT_IN_CONTAINER="/run/containai"
RENDERER_SCRIPT="$REPO_ROOT/host/utils/render-session-config.py"
TRUSTED_HASH_ARGS=()
if [ -n "$TRUSTED_TREE_HASHES_RAW" ]; then
    while IFS= read -r entry; do
        [ -z "$entry" ] && continue
        TRUSTED_HASH_ARGS+=("--trusted-hash" "$entry")
    done <<< "$TRUSTED_TREE_HASHES_RAW"
fi

if [ -f "$RENDERER_SCRIPT" ]; then
    RENDER_ARGS=("--output" "$SESSION_CONFIG_OUTPUT" "--session-id" "$SESSION_ID" "--network-policy" "$NETWORK_POLICY_ENV" "--repo" "$REPO_NAME" "--agent" "$AGENT" "--container" "$CONTAINER_NAME")
    if [ -n "$SESSION_CONFIG_SOURCE" ]; then
        RENDER_ARGS+=("--config" "$SESSION_CONFIG_SOURCE")
    fi
    if [ -n "$LAUNCHER_HEAD_HASH" ]; then
        RENDER_ARGS+=("--git-head" "$LAUNCHER_HEAD_HASH")
    fi
    RENDER_ARGS+=("${TRUSTED_HASH_ARGS[@]}")
    RUNNER_MOUNTS=("--mount" "$SESSION_CONFIG_OUTPUT")
    if [ -n "$SESSION_CONFIG_SOURCE" ]; then
        RUNNER_MOUNTS+=("--mount" "$SESSION_CONFIG_SOURCE")
    fi
    if run_python_tool "$RENDERER_SCRIPT" "${RUNNER_MOUNTS[@]}" -- "${RENDER_ARGS[@]}" >/dev/null 2>&1; then
        SESSION_MANIFEST_PATH="$SESSION_CONFIG_OUTPUT/manifest.json"
        if [ -f "$SESSION_MANIFEST_PATH" ]; then
            if command -v shasum >/dev/null 2>&1; then
                SESSION_CONFIG_SHA256=$(shasum -a 256 "$SESSION_MANIFEST_PATH" | awk '{print $1}')
            elif command -v sha256sum >/dev/null 2>&1; then
                SESSION_CONFIG_SHA256=$(sha256sum "$SESSION_MANIFEST_PATH" | awk '{print $1}')
            else
                SESSION_CONFIG_SHA256=""
            fi
            SESSION_CONFIG_RENDERED=true
            echo "üîê Session MCP config manifest: ${SESSION_CONFIG_SHA256:-unknown}"
            log_session_config_manifest "$SESSION_ID" "${SESSION_CONFIG_SHA256:-}" "$REPO_ROOT" "$TRUSTED_TREE_HASHES_RAW"
            servers_file="$SESSION_CONFIG_OUTPUT/servers.txt"
            if [ -f "$servers_file" ]; then
                mapfile -t MANIFEST_STUBS < <(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' "$servers_file" | grep -v '^$')
                if [ ${#MANIFEST_STUBS[@]} -gt 0 ]; then
                    BROKER_STUBS=("${MANIFEST_STUBS[@]}")
                fi
            fi
            stub_secret_file="$SESSION_CONFIG_OUTPUT/stub-secrets.txt"
            if [ -f "$stub_secret_file" ]; then
                parse_stub_secret_manifest "$stub_secret_file"
            fi
        fi
    else
        echo "‚ö†Ô∏è  Failed to render session MCP config via python runner" >&2
    fi
else
    echo "‚ö†Ô∏è  Session config renderer missing at $RENDERER_SCRIPT" >&2
fi

detect_agent_cli_secrets

if ! ensure_broker_ready; then
    echo "‚ùå Secret broker health check failed" >&2
    exit 1
fi

BROKER_SCRIPT=$(get_secret_broker_script)
if [ -z "$BROKER_SCRIPT" ]; then
    echo "‚ùå Secret broker script not found" >&2
    exit 1
fi

if [ ${#SESSION_STUB_SECRETS[@]} -gt 0 ]; then
    load_mcp_secret_values
    if ! store_stub_secrets "$BROKER_SCRIPT"; then
        echo "‚ùå Failed to stage broker-managed secrets" >&2
        exit 1
    fi
fi

BROKER_CAP_DIR="$SESSION_CONFIG_OUTPUT/capabilities"
mkdir -p "$BROKER_CAP_DIR"
export CONTAINAI_SESSION_CONFIG_SHA256="${SESSION_CONFIG_SHA256:-}"
if ! issue_session_capabilities "$SESSION_ID" "$BROKER_CAP_DIR" "${BROKER_STUBS[@]}"; then
    echo "‚ùå Failed to issue capability tokens" >&2
    exit 1
fi

if [ ${#SESSION_STUB_SECRETS[@]} -gt 0 ]; then
    if ! seal_stub_capabilities "$BROKER_SCRIPT" "$BROKER_CAP_DIR"; then
        echo "‚ùå Failed to seal stub secrets" >&2
        exit 1
    fi
fi

if [ ${#AGENT_CLI_STUBS[@]} -gt 0 ]; then
    stage_agent_cli_capability_bundles
fi

package_agent_data_payload "$AGENT"

# Check for branch conflicts in local repos (only when creating isolated branches)
if [ "$SOURCE_TYPE" = "local" ] && [ "$USE_CURRENT_BRANCH" != "true" ]; then
    RESOLVED_PATH=$(realpath "$SOURCE")
    
    # Check if agent branch already exists
    if branch_exists "$RESOLVED_PATH" "$AGENT_BRANCH"; then
        echo "‚ö†Ô∏è  Branch '$AGENT_BRANCH' already exists in the repository"
        echo ""
        
        # Get current branch to check for unmerged commits
        cd "$RESOLVED_PATH"
        CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
        cd - > /dev/null
        
        # Check for unmerged commits
        UNMERGED_COMMITS=$(get_unmerged_commits "$RESOLVED_PATH" "$CURRENT_BRANCH" "$AGENT_BRANCH")
        
        if [ -n "$UNMERGED_COMMITS" ]; then
            echo "üìù Branch has unmerged commits:"
            echo "$UNMERGED_COMMITS" | head -5
            COMMIT_COUNT=$(echo "$UNMERGED_COMMITS" | wc -l)
            if [ "$COMMIT_COUNT" -gt 5 ]; then
                echo "   ... and $((COMMIT_COUNT - 5)) more"
            fi
            echo ""
            echo "   ‚ÑπÔ∏è  The branch will be archived before creating a new one."
            echo ""
        fi
        
        # Prompt for replacement unless force flag is set
        if [ "$FORCE" != "true" ]; then
            read -p "Replace existing branch? (y/N): " -n 1 -r REPLY
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "‚ùå Aborted. Use -y or --force to automatically replace."
                exit 1
            fi
        else
            echo "   üîÑ Force flag set - replacing automatically"
        fi
        
        # Archive or delete the branch
        if [ -n "$UNMERGED_COMMITS" ]; then
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            ARCHIVE_NAME="${AGENT_BRANCH}-archived-${TIMESTAMP}"
            echo "üì¶ Archiving to: $ARCHIVE_NAME"
            
            if rename_git_branch "$RESOLVED_PATH" "$AGENT_BRANCH" "$ARCHIVE_NAME"; then
                echo "   ‚úÖ Branch archived successfully"
            else
                echo "   ‚ùå Failed to archive branch"
                exit 1
            fi
        else
            echo "üóëÔ∏è  Removing existing branch (no unmerged commits)"
            if remove_git_branch "$RESOLVED_PATH" "$AGENT_BRANCH" "true"; then
                echo "   ‚úÖ Branch removed successfully"
            else
                echo "   ‚ùå Failed to remove branch"
                exit 1
            fi
        fi
        echo ""
    fi
fi

echo "üöÄ Launching ContainAI..."
echo "üéØ Agent: $AGENT"
echo "üìÅ Source: $SOURCE ($SOURCE_TYPE)"
echo "üåø Branch: $AGENT_BRANCH"
echo "üè∑Ô∏è  Container: $CONTAINER_NAME"
echo "üê≥ Image: $IMAGE_NAME"
echo "üåê Network policy: $NETWORK_POLICY_ENV"
echo ""

# Check if container already exists
if container_exists "$CONTAINER_NAME"; then
    echo "üì¶ Container '$CONTAINER_NAME' already exists"
    STATE=$(get_container_status "$CONTAINER_NAME")
    
    # Handle existing proxy if squid mode
    if [ "$USE_SQUID" = true ]; then
        EXISTING_PROXY=$(container_cli inspect -f '{{ index .Config.Labels "containai.proxy-container" }}' "$CONTAINER_NAME" 2>/dev/null || echo "$PROXY_CONTAINER_NAME")
        EXISTING_NETWORK=$(container_cli inspect -f '{{ index .Config.Labels "containai.proxy-network" }}' "$CONTAINER_NAME" 2>/dev/null || echo "$PROXY_NETWORK_NAME")
        PROXY_CONTAINER_NAME="$EXISTING_PROXY"
        PROXY_NETWORK_NAME="$EXISTING_NETWORK"
        ensure_squid_proxy "$PROXY_NETWORK_NAME" "$PROXY_CONTAINER_NAME" "$PROXY_IMAGE" "$CONTAINER_NAME" "$SQUID_ALLOWED_DOMAINS" "$SQUID_HELPER_ACL_FILE" "$AGENT" "$SESSION_ID" "$PROXY_MITM_CA_CERT" "$PROXY_MITM_CA_KEY"
        start_proxy_log_pipeline "$PROXY_CONTAINER_NAME" "$PROXY_NETWORK_NAME" "$PROXY_LOG_DIR" "$PROXY_LOG_CERT_DIR"
    fi
    
    if [ "$STATE" = "running" ]; then
        echo "‚úÖ Container is already running"
        echo "   Connect via: $CONTAINER_CLI exec -it $CONTAINER_NAME bash"
        echo "   Or use VS Code Dev Containers extension"
        exit 0
    else
        echo "‚ñ∂Ô∏è  Starting existing container..."
        container_cli start "$CONTAINER_NAME"
        echo "‚úÖ Container started"
        exit 0
    fi
fi

# Setup squid proxy if needed
if [ "$USE_SQUID" = true ]; then
    ensure_squid_proxy "$PROXY_NETWORK_NAME" "$PROXY_CONTAINER_NAME" "$PROXY_IMAGE" "$CONTAINER_NAME" "$SQUID_ALLOWED_DOMAINS" "$SQUID_HELPER_ACL_FILE" "$AGENT" "$SESSION_ID" "$PROXY_MITM_CA_CERT" "$PROXY_MITM_CA_KEY"
    start_proxy_log_pipeline "$PROXY_CONTAINER_NAME" "$PROXY_NETWORK_NAME" "$PROXY_LOG_DIR" "$PROXY_LOG_CERT_DIR"
fi

# Build docker arguments
AUTO_PUSH_VALUE=$([ "$NO_PUSH" = true ] && echo "false" || echo "true")

DOCKER_ARGS=(
    "run" "-d"
    "--name" "$CONTAINER_NAME"
    "--hostname" "$CONTAINER_NAME"
    "--security-opt" "apparmor=containai"
    "--security-opt" "seccomp=$SECCOMP_PROFILE_PATH"
    "-e" "TZ=$TZ_VALUE"
    "-e" "SOURCE_TYPE=$SOURCE_TYPE"
    "-e" "REPO_NAME=$WORKSPACE_NAME"
    "-e" "AGENT_BRANCH=$AGENT_BRANCH"
    "-e" "NETWORK_POLICY=$NETWORK_POLICY_ENV"
    "-e" "AUTO_PUSH_ON_SHUTDOWN=$AUTO_PUSH_VALUE"
    "-e" "CONTAINAI_PROFILE=$CONTAINAI_PROFILE"
    "-e" "AGENT_SESSION_MODE=shell"
    "-e" "AGENT_SESSION_SHELL_BIN=/bin/bash"
    "-e" "AGENT_SESSION_SHELL_ARGS=-l"
    "-e" "HOST_SESSION_ID=$SESSION_ID"
    "-e" "HOST_SESSION_CONFIG_SHA256=$SESSION_CONFIG_SHA256"
    "-e" "HOST_TRUSTED_TREES=$TRUSTED_TREE_HASHES_ENV"
    "-e" "HOST_LAUNCHER_HEAD=$LAUNCHER_HEAD_HASH"
    "-e" "HOST_SESSION_CONFIG_ROOT=$SESSION_CONFIG_ROOT_IN_CONTAINER"
    "-e" "HOST_CAPABILITY_ROOT=${SESSION_CONFIG_ROOT_IN_CONTAINER}/capabilities"
    "-e" "HOST_MITM_CA_CERT=${SESSION_CONFIG_ROOT_IN_CONTAINER}/mitm/proxy-ca.crt"
    "-e" "CONTAINAI_AGENT_SECRET_ROOT=/run/agent-secrets"
    "-e" "CONTAINAI_AGENT_DATA_ROOT=/run/agent-data"
    "-e" "CONTAINAI_SECRET_TMPFS_SIZE=${TMPFS_SECRET_SIZE}"
    "--label" "containai.type=agent"
    "--label" "containai.profile=$CONTAINAI_PROFILE"
    "--label" "containai.agent=$AGENT"
    "--label" "containai.repo=$REPO_NAME"
    "--label" "containai.branch=$AGENT_BRANCH"
    "--label" "containai.network-policy=$NETWORK_POLICY_ENV"
    "--label" "containai.volume.workspace=$WORKSPACE_VOLUME"
    "--label" "containai.volume.home=$HOME_VOLUME"
    "--label" "containai.volume.toolcache=$TOOLCACHE_VOLUME"
    "-v" "${HOME}/.gitconfig:/home/agentuser/.gitconfig:ro"
    "-v" "${HOME}/.config/gh:/home/agentuser/.config/gh:ro"
    "-v" "${HOME}/.config/github-copilot:/home/agentuser/.config/github-copilot:ro"
)

# Writable volumes for workspace, home, and tool cache
DOCKER_ARGS+=(
    "--mount" "type=volume,src=${WORKSPACE_VOLUME},dst=/workspace"
    "--mount" "type=volume,src=${HOME_VOLUME},dst=/home/agentuser"
    "--mount" "type=volume,src=${TOOLCACHE_VOLUME},dst=/toolcache"
)

# Add source-specific vars
if [ "$SOURCE_TYPE" = "url" ]; then
    DOCKER_ARGS+=("-e" "GIT_URL=$GIT_URL")
else
    LOCAL_REPO_ENV_VALUE="${LOCAL_REPO_PATH_VALUE:-$WSL_PATH}"
    DOCKER_ARGS+=("-e" "LOCAL_REPO_PATH=$LOCAL_REPO_ENV_VALUE")
    DOCKER_ARGS+=("-v" "${WSL_PATH}:/tmp/source-repo:ro")
    DOCKER_ARGS+=("--label" "containai.repo-path=$RESOLVED_PATH")
    if [ -n "${LOCAL_REMOTE_WSL_PATH:-}" ]; then
        DOCKER_ARGS+=("-e" "LOCAL_REMOTE_URL=${LOCAL_REMOTE_URL}")
        DOCKER_ARGS+=("-v" "${LOCAL_REMOTE_WSL_PATH}:/tmp/local-remote")
        DOCKER_ARGS+=("--label" "containai.local-remote=$LOCAL_REMOTE_HOST_PATH")
    fi
fi

[ -n "$DOTNET_PREVIEW" ] && DOCKER_ARGS+=("-e" "DOTNET_PREVIEW_CHANNEL=$DOTNET_PREVIEW")

# Add proxy environment if squid
if [ "$USE_SQUID" = true ]; then
    DOCKER_ARGS+=(
        "-e" "HTTP_PROXY=$PROXY_URL"
        "-e" "HTTPS_PROXY=$PROXY_URL"
        "-e" "http_proxy=$PROXY_URL"
        "-e" "https_proxy=$PROXY_URL"
        "-e" "NO_PROXY=localhost,127.0.0.1,.internal,::1"
        "-e" "no_proxy=localhost,127.0.0.1,.internal,::1"
        "--label" "containai.proxy-container=$PROXY_CONTAINER_NAME"
        "--label" "containai.proxy-network=$PROXY_NETWORK_NAME"
        "--label" "containai.proxy-image=$PROXY_IMAGE"
    )
fi

# Add optional agent configs
[ -d "${HOME}/.config/codex" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/codex:/home/agentuser/.config/codex:ro")
[ -d "${HOME}/.config/claude" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/claude:/home/agentuser/.config/claude:ro")
[ -f "${HOME}/.config/containai/mcp-secrets.env" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/containai/mcp-secrets.env:/home/agentuser/.mcp-secrets.env:ro")

TMPFS_MOUNTS=(
    "/tmp:rw,nosuid,nodev,size=${TMPFS_LARGE_SIZE},mode=1777"
    "/var/tmp:rw,nosuid,nodev,size=${TMPFS_LARGE_SIZE},mode=1777"
    "/run:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/log:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/lib/apt:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/lib/apt/lists:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/cache/apt:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/cache/debconf:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/lib/dpkg:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "${SESSION_CONFIG_ROOT_IN_CONTAINER}:rw,nosuid,nodev,noexec,mode=750"
    "/run/agent-secrets:rw,nosuid,nodev,noexec,size=${TMPFS_SECRET_SIZE},mode=750"
)

for tmpfs_mount in "${TMPFS_MOUNTS[@]}"; do
    DOCKER_ARGS+=("--tmpfs" "$tmpfs_mount")
done

# Start git credential proxy server on host if not already running
CREDENTIAL_SOCKET_PATH="${HOME}/.config/containai/git-credential.sock"
CREDENTIAL_PROXY_SCRIPT="$SCRIPT_DIR/../utils/git-credential-proxy-server.sh"

if [ ! -S "$CREDENTIAL_SOCKET_PATH" ]; then
    if [ -f "$CREDENTIAL_PROXY_SCRIPT" ]; then
        echo "üîê Starting git credential proxy server..."
        mkdir -p "$(dirname "$CREDENTIAL_SOCKET_PATH")"
        
        # Start proxy server in background with nohup
        nohup "$CREDENTIAL_PROXY_SCRIPT" "$CREDENTIAL_SOCKET_PATH" > /dev/null 2>&1 &
        PROXY_PID=$!
        
        # Wait for socket to be created (max 5 seconds)
        for i in {1..50}; do
            [ -S "$CREDENTIAL_SOCKET_PATH" ] && break
            sleep 0.1
        done
        
        if [ -S "$CREDENTIAL_SOCKET_PATH" ]; then
            echo "   ‚úÖ Credential proxy started (PID: $PROXY_PID)"
        else
            echo "   ‚ö†Ô∏è  Credential proxy started but socket not ready"
            echo "      Container will fall back to file-based credentials"
        fi
    else
        echo "‚ö†Ô∏è  Credential proxy script not found, using file-based credentials"
    fi
fi

# Start GPG proxy server on host if not already running and GPG signing is configured
GPG_SOCKET_PATH="${HOME}/.config/containai/gpg-proxy.sock"
GPG_PROXY_SCRIPT="$SCRIPT_DIR/../utils/gpg-proxy-server.sh"
GPG_SIGNING_ENABLED=false

if git config commit.gpgsign 2>/dev/null | grep -q "true"; then
    GPG_SIGNING_ENABLED=true
    if [ ! -S "$GPG_SOCKET_PATH" ]; then
        if [ -f "$GPG_PROXY_SCRIPT" ]; then
            echo "üîè Starting GPG proxy server for commit signing..."
            mkdir -p "$(dirname "$GPG_SOCKET_PATH")"
            
            # Start GPG proxy server in background
            nohup "$GPG_PROXY_SCRIPT" "$GPG_SOCKET_PATH" > /dev/null 2>&1 &
            GPG_PROXY_PID=$!
            
            # Wait for socket to be created
            for i in {1..50}; do
                [ -S "$GPG_SOCKET_PATH" ] && break
                sleep 0.1
            done
            
            if [ -S "$GPG_SOCKET_PATH" ]; then
                echo "   ‚úÖ GPG proxy started (PID: $GPG_PROXY_PID)"
            else
                echo "   ‚ö†Ô∏è  GPG proxy started but socket not ready"
            fi
        fi
    fi
fi

# Mount credential proxy socket (most secure - no files in container)
if [ -S "$CREDENTIAL_SOCKET_PATH" ]; then
    DOCKER_ARGS+=("-v" "$CREDENTIAL_SOCKET_PATH:/tmp/git-credential-proxy.sock:ro")
    DOCKER_ARGS+=("-e" "CREDENTIAL_SOCKET=/tmp/git-credential-proxy.sock")
fi

# Mount GPG proxy socket (secure signing - private keys stay on host)
if [ -S "$GPG_SOCKET_PATH" ]; then
    DOCKER_ARGS+=("-v" "$GPG_SOCKET_PATH:/tmp/gpg-proxy.sock:ro")
    DOCKER_ARGS+=("-e" "GPG_PROXY_SOCKET=/tmp/gpg-proxy.sock")
fi

# Fallback: Mount credential files (read-only for security)
# These are only used if socket proxy is not available
[ -f "${HOME}/.git-credentials" ] && DOCKER_ARGS+=("-v" "${HOME}/.git-credentials:/home/agentuser/.git-credentials:ro")

# SSH agent socket forwarding (supports any SSH agent via standard SSH_AUTH_SOCK)
SSH_AGENT_SOCKET_MOUNTED=false
if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "$SSH_AUTH_SOCK" ]; then
    # Forward SSH agent socket to container
    DOCKER_ARGS+=("-v" "$SSH_AUTH_SOCK:/tmp/ssh-agent.sock:ro")
    DOCKER_ARGS+=("-e" "SSH_AUTH_SOCK=/tmp/ssh-agent.sock")
    SSH_AGENT_SOCKET_MOUNTED=true
fi

if [ "$SSH_AGENT_SOCKET_MOUNTED" = false ] && [ -d "${HOME}/.ssh" ]; then
    echo "‚ö†Ô∏è  SSH agent socket not available; host SSH keys will not be forwarded. Start ssh-agent before running launch-agent."
fi

if [ "$GPG_SIGNING_ENABLED" = true ] && [ ! -S "$GPG_SOCKET_PATH" ]; then
    echo "‚ö†Ô∏è  Commit signing is enabled but gpg-proxy socket was not created. Signing will be disabled; run gpg-proxy-server.sh or disable commit.gpgsign."
fi

SECCOMP_PROFILE_PATH=""
if ! SECCOMP_PROFILE_PATH=$(resolve_seccomp_profile_path "$REPO_ROOT"); then
    echo "‚ùå Seccomp profile missing. Run scripts/install.sh to reinstall the host security assets and retry."
    exit 1
fi
if ! ensure_security_assets_current "$REPO_ROOT"; then
    exit 1
fi

APPARMOR_PROFILE_NAME=""
if APPARMOR_PROFILE_NAME=$(resolve_apparmor_profile_name "$REPO_ROOT"); then
    true
else
    APPARMOR_PROFILE_NAME=""
fi

# Final args
DOCKER_ARGS+=(
    "-w" "/workspace"
    "--network" "$NETWORK_MODE"
    "--read-only"
    "--cap-drop=ALL"
    "--security-opt" "no-new-privileges:true"
    "--pids-limit=4096"
    "--cpus=$CPU"
    "--memory=$MEMORY"
    "--memory-swap=$MEMORY"
)

if [ -n "$SECCOMP_PROFILE_PATH" ]; then
    DOCKER_ARGS+=("--security-opt" "seccomp=$SECCOMP_PROFILE_PATH")
fi

if [ -n "$APPARMOR_PROFILE_NAME" ]; then
    DOCKER_ARGS+=("--security-opt" "apparmor=$APPARMOR_PROFILE_NAME")
fi

# Add GPU if specified
if [ -n "$GPU" ]; then
    DOCKER_ARGS+=("--gpus=$GPU")
fi

if [ -n "${CONTAINAI_EXTRA_DOCKER_ARGS:-}" ]; then
    # shellcheck disable=SC2206
    EXTRA_DOCKER_ARGS=(${CONTAINAI_EXTRA_DOCKER_ARGS})
    DOCKER_ARGS+=("${EXTRA_DOCKER_ARGS[@]}")
fi

DOCKER_ARGS+=(
    "$IMAGE_NAME"
    "sleep" "infinity"
)

# Create container
echo "üì¶ Creating container..."
CONTAINER_ID=$(container_cli "${DOCKER_ARGS[@]}")

if [ -z "$CONTAINER_ID" ]; then
    echo "‚ùå Failed to create container"
    [ "$USE_SQUID" = true ] && container_cli rm -f "$PROXY_CONTAINER_NAME" >/dev/null 2>&1
    [ "$USE_SQUID" = true ] && container_cli network rm "$PROXY_NETWORK_NAME" >/dev/null 2>&1
    exit 1
fi

if [ "$SESSION_CONFIG_RENDERED" = true ] && [ -d "$SESSION_CONFIG_OUTPUT" ]; then
    if ! container_cli exec "$CONTAINER_NAME" mkdir -p "$SESSION_CONFIG_ROOT_IN_CONTAINER" >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  Failed to prepare session config directory inside container" >&2
    else
        container_cli cp "$SESSION_CONFIG_OUTPUT/." "$CONTAINER_NAME:$SESSION_CONFIG_ROOT_IN_CONTAINER" >/dev/null 2>&1 || \
            echo "‚ö†Ô∏è  Unable to copy session configs into container" >&2
    fi
fi

# Setup repository inside container
echo "üì• Setting up repository..."
SETUP_SCRIPT=$(generate_repo_setup_script "$SOURCE_TYPE" "$GIT_URL" "$WSL_PATH" "$AGENT_BRANCH")
if ! echo "$SETUP_SCRIPT" | container_cli exec -i "$CONTAINER_NAME" bash; then
    echo "‚ùå Failed to setup repository"
    container_cli rm -f "$CONTAINER_NAME"
    exit 1
fi

if [ "$SOURCE_TYPE" = "local" ] && [ "$NO_PUSH" != true ] && [ -n "$LOCAL_REMOTE_HOST_PATH" ] && [ "${CONTAINAI_DISABLE_AUTO_SYNC:-0}" != "1" ]; then
    SYNC_SCRIPT="$REPO_ROOT/host/utils/sync-local-remote.sh"
    if [ -x "$SYNC_SCRIPT" ]; then
        mkdir -p "${HOME}/.containai/logs"
        LOG_FILE="${HOME}/.containai/logs/${CONTAINER_NAME}-sync.log"
        "$SYNC_SCRIPT" \
            --bare "$LOCAL_REMOTE_HOST_PATH" \
            --repo "$SOURCE" \
            --branch "$AGENT_BRANCH" \
            --container "$CONTAINER_NAME" \
            >>"$LOG_FILE" 2>&1 &
    fi
fi

echo ""
echo "‚úÖ Container '$CONTAINER_NAME' is ready!"
echo ""
echo "Connect via:"
echo "  ‚Ä¢ VS Code: Attach to running container '$CONTAINER_NAME'"
echo "  ‚Ä¢ Terminal: $CONTAINER_CLI exec -it $CONTAINER_NAME bash"
echo ""
echo "Repository: /workspace"
echo "Branch: $AGENT_BRANCH"
