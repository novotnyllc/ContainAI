namespace ContainAI.Cli.Host;

internal interface IShellProfileScriptContentGenerator
{
    string BuildProfileScript(string homeDirectory, string binDirectory);
}

internal sealed class ShellProfileScriptContentGenerator : IShellProfileScriptContentGenerator
{
    public string BuildProfileScript(string homeDirectory, string binDirectory)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(homeDirectory);
        ArgumentException.ThrowIfNullOrWhiteSpace(binDirectory);

        var pathSegment = NormalizePathForShell(homeDirectory, binDirectory);
        return string.Join(
            Environment.NewLine,
            "# Generated by cai install. Manual edits may be overwritten.",
            $"if [ -d \"{pathSegment}\" ]; then",
            $"  case \":$PATH:\" in *\":{pathSegment}:\"*) ;; *) export PATH=\"{pathSegment}:$PATH\" ;; esac",
            "fi",
            "if command -v complete >/dev/null 2>&1; then",
            "  if [ -n \"${ZSH_VERSION-}\" ] && command -v bashcompinit >/dev/null 2>&1; then",
            "    bashcompinit >/dev/null 2>&1 || true",
            "  fi",
            "  _cai_complete()",
            "  {",
            "    local line point",
            "    line=\"${COMP_LINE:-}\"",
            "    point=\"${COMP_POINT:-${#line}}\"",
            "    local IFS=$'\\n'",
            "    COMPREPLY=($(cai completion suggest --line \"$line\" --position \"$point\" 2>/dev/null))",
            "  }",
            "  complete -o default -F _cai_complete cai",
            "  complete -o default -F _cai_complete containai-docker",
            "  complete -o default -F _cai_complete docker-containai",
            "fi",
            string.Empty);
    }

    private static string NormalizePathForShell(string homeDirectory, string path)
    {
        var normalizedHome = Path.GetFullPath(homeDirectory)
            .TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar)
            .Replace('\\', '/');
        var normalizedPath = Path.GetFullPath(path)
            .TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar)
            .Replace('\\', '/');

        if (string.Equals(normalizedPath, normalizedHome, StringComparison.Ordinal))
        {
            return "$HOME";
        }

        if (normalizedPath.StartsWith(normalizedHome + "/", StringComparison.Ordinal))
        {
            return "$HOME/" + normalizedPath[(normalizedHome.Length + 1)..];
        }

        return normalizedPath;
    }
}
