#!/usr/bin/env bash
# ══════════════════════════════════════════════════════════════════════
# cai-docker: Smart docker wrapper for ContainAI devcontainers
#
# Detects VS Code devcontainers with ContainAI feature and:
# - Enforces sysbox runtime at launch time
# - Mounts data volume for config sync
# - Validates credentials (defense-in-depth)
# - Allocates dynamic SSH port
# - Adds labels for cai ps/stop/gc integration
# - Updates SSH config via ~/.ssh/containai.d/
#
# Installation: ~/.local/bin/cai-docker (installed by cai setup)
# ══════════════════════════════════════════════════════════════════════
set -euo pipefail

# ──────────────────────────────────────────────────────────────────────
# Configuration
# ──────────────────────────────────────────────────────────────────────
readonly _CAI_DOCKER_CONTEXT="${CONTAINAI_DOCKER_CONTEXT:-containai-docker}"
readonly _CAI_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/containai"
readonly _CAI_PORT_DIR="$_CAI_CONFIG_DIR/ports"
readonly _CAI_LOCK_FILE="$_CAI_CONFIG_DIR/.ssh-port.lock"
readonly _CAI_SSH_PORT_RANGE_START=2400
readonly _CAI_SSH_PORT_RANGE_END=2499
readonly _CAI_DEFAULT_DATA_VOLUME="containai-data"
# ContainAI feature patterns to match in devcontainer.json
readonly _CAI_FEATURE_PATTERNS=(
    "ghcr.io/novotnyllc/containai"
    "containai/feature"
    '"containai"'
)

# Verbose/quiet flags (default: silent per Unix Rule of Silence)
_CAI_VERBOSE="${CONTAINAI_VERBOSE:-0}"
_CAI_QUIET=0

# ──────────────────────────────────────────────────────────────────────
# Logging (respects --verbose/--quiet flags)
# ──────────────────────────────────────────────────────────────────────
_cai_info() {
    [[ "$_CAI_QUIET" == "1" ]] && return
    [[ "$_CAI_VERBOSE" == "1" ]] && printf '[cai-docker] %s\n' "$*" >&2
}

_cai_warn() {
    [[ "$_CAI_QUIET" == "1" ]] && return
    printf '[cai-docker] Warning: %s\n' "$*" >&2
}

_cai_error() {
    printf '[cai-docker] Error: %s\n' "$*" >&2
}

# ──────────────────────────────────────────────────────────────────────
# JSONC Parsing via Python3 State Machine
# Handles: // line comments, /* block comments */, strings with comment-like content
# DO NOT use sed-based comment stripping which fails on edge cases like:
#   "url": "https://example.com" (// inside string looks like comment)
# ──────────────────────────────────────────────────────────────────────
_cai_strip_jsonc_comments() {
    python3 -c '
import sys

def strip_jsonc(content):
    """Strip JSONC comments using state machine (handles strings correctly)."""
    result = []
    i = 0
    n = len(content)
    in_string = False
    escape = False

    while i < n:
        c = content[i]

        if escape:
            result.append(c)
            escape = False
            i += 1
            continue

        if c == "\\" and in_string:
            result.append(c)
            escape = True
            i += 1
            continue

        if c == "\"" and not escape:
            in_string = not in_string
            result.append(c)
            i += 1
            continue

        if not in_string:
            # Check for // line comment
            if c == "/" and i + 1 < n and content[i + 1] == "/":
                # Skip to end of line
                while i < n and content[i] != "\n":
                    i += 1
                continue
            # Check for /* block comment */
            if c == "/" and i + 1 < n and content[i + 1] == "*":
                i += 2
                while i + 1 < n and not (content[i] == "*" and content[i + 1] == "/"):
                    i += 1
                i += 2  # Skip */
                continue

        result.append(c)
        i += 1

    return "".join(result)

content = sys.stdin.read()
print(strip_jsonc(content))
'
}

# ──────────────────────────────────────────────────────────────────────
# Extract VS Code devcontainer labels from docker command args
# VS Code Dev Containers passes:
#   --label devcontainer.config_file=/path/to/.devcontainer/devcontainer.json
#   --label devcontainer.local_folder=/path/to/workspace
# ──────────────────────────────────────────────────────────────────────
_cai_extract_devcontainer_labels() {
    local config_file="" local_folder=""
    local prev=""

    for arg in "$@"; do
        if [[ "$prev" == "--label" ]]; then
            case "$arg" in
                devcontainer.config_file=*) config_file="${arg#*=}" ;;
                devcontainer.local_folder=*) local_folder="${arg#*=}" ;;
            esac
        fi
        prev="$arg"
    done

    # Output: config_file on line 1, local_folder on line 2
    printf '%s\n%s\n' "$config_file" "$local_folder"
}

# ──────────────────────────────────────────────────────────────────────
# Check if devcontainer.json contains ContainAI feature
# Uses JSONC parsing and specifically checks .features object
# ──────────────────────────────────────────────────────────────────────
_cai_has_containai_feature() {
    local config_file="$1"

    [[ -f "$config_file" ]] || return 1

    # Parse JSON and specifically check .features object for containai
    local result
    result=$(_cai_strip_jsonc_comments < "$config_file" | python3 -c '
import sys, json
try:
    d = json.load(sys.stdin)
    features = d.get("features", {})
    if not isinstance(features, dict):
        sys.exit(1)
    # Check if any feature key contains "containai"
    for key in features:
        if "containai" in key.lower():
            print(key)
            sys.exit(0)
    sys.exit(1)
except Exception:
    sys.exit(1)
' 2>/dev/null) || return 1

    if [[ -n "$result" ]]; then
        _cai_info "ContainAI feature detected: $result"
        return 0
    fi

    return 1
}

# ──────────────────────────────────────────────────────────────────────
# Get data volume name from devcontainer.json or use default
# SECURITY: Validates that dataVolume is a valid Docker volume name, not a path
# ──────────────────────────────────────────────────────────────────────
_cai_get_data_volume() {
    local config_file="$1"
    local vol=""

    if [[ -f "$config_file" ]]; then
        vol=$(_cai_strip_jsonc_comments < "$config_file" | python3 -c '
import sys, json
try:
    d = json.load(sys.stdin)
    features = d.get("features", {})
    # Check all keys that might be ContainAI feature
    for key in features:
        if "containai" in key.lower():
            vol = features[key].get("dataVolume", "")
            if vol:
                print(vol)
                sys.exit(0)
except Exception:
    pass
' 2>/dev/null) || vol=""

        if [[ -n "$vol" ]]; then
            # SECURITY: Validate volume name - reject paths and bind mount syntax
            # Docker volume names: alphanumeric, underscores, hyphens, periods
            # Reject: paths (/, ~, .), bind mount syntax (:), special chars
            if [[ "$vol" =~ ^[a-zA-Z0-9][a-zA-Z0-9._-]*$ ]] && \
               [[ ! "$vol" =~ [/:~] ]] && \
               [[ "$vol" != "." ]] && [[ "$vol" != ".." ]]; then
                printf '%s' "$vol"
                return
            else
                _cai_warn "Invalid dataVolume '$vol' - must be a Docker volume name, not a path"
                _cai_warn "Using default volume instead"
            fi
        fi
    fi

    # Default: containai-data (matches existing cai volume naming)
    printf '%s' "$_CAI_DEFAULT_DATA_VOLUME"
}

# ──────────────────────────────────────────────────────────────────────
# Get enableCredentials from devcontainer.json (default: false)
# ──────────────────────────────────────────────────────────────────────
_cai_get_enable_credentials() {
    local config_file="$1"
    local enable="false"

    if [[ -f "$config_file" ]]; then
        enable=$(_cai_strip_jsonc_comments < "$config_file" | python3 -c '
import sys, json
try:
    d = json.load(sys.stdin)
    features = d.get("features", {})
    for key in features:
        if "containai" in key.lower():
            val = features[key].get("enableCredentials", False)
            # Handle both bool and string
            if val is True or val == "true":
                print("true")
            else:
                print("false")
            sys.exit(0)
    # No containai feature found
    print("false")
except Exception:
    print("false")
' 2>/dev/null) || enable="false"
    fi

    printf '%s' "$enable"
}

# ──────────────────────────────────────────────────────────────────────
# Cross-platform port-in-use check
# Linux: ss (iproute2)
# macOS: lsof (pre-installed)
# ──────────────────────────────────────────────────────────────────────
_cai_is_port_in_use() {
    local port="$1"

    if command -v ss &>/dev/null; then
        # Linux: use ss (faster, more reliable)
        ss -tln 2>/dev/null | grep -qE ":${port}[[:space:]]" && return 0
    elif command -v lsof &>/dev/null; then
        # macOS: use lsof
        lsof -iTCP:"$port" -sTCP:LISTEN &>/dev/null && return 0
    fi

    return 1
}

# ──────────────────────────────────────────────────────────────────────
# Allocate SSH port for devcontainer
# Uses shared lock file and port directory for coordination with cai
#
# IMPORTANT: This function must be called while holding the lock
# (acquired in main before calling this function)
# ──────────────────────────────────────────────────────────────────────
_cai_allocate_ssh_port() {
    local workspace_name="$1"
    # Sanitize for filename safety, but use original name for container label matching
    local workspace_name_safe
    workspace_name_safe=$(printf '%s' "$workspace_name" | tr -c 'A-Za-z0-9._-' '-' | sed 's/--*/-/g; s/^-//; s/-$//')
    local port_file="$_CAI_PORT_DIR/devcontainer-${workspace_name_safe}"

    mkdir -p "$_CAI_PORT_DIR" 2>/dev/null || true

    # Check if we already have a port for this workspace
    if [[ -f "$port_file" ]]; then
        local existing_port
        existing_port=$(cat "$port_file")
        if [[ "$existing_port" =~ ^[0-9]+$ ]]; then
            # Validate port is still reasonable (not claimed by another process)
            if ! _cai_is_port_in_use "$existing_port"; then
                _cai_info "Reusing existing port $existing_port for workspace $workspace_name"
                printf '%s' "$existing_port"
                return 0
            fi
            # Port in use - check if it's by a container with this workspace label
            # Use original workspace_name for label matching (matches what we set in labels)
            local existing_container_port
            existing_container_port=$(docker --context "$_CAI_DOCKER_CONTEXT" ps -a \
                --filter "label=containai.devcontainer.workspace=$workspace_name" \
                --filter "label=containai.ssh-port" \
                --format '{{.Label "containai.ssh-port"}}' 2>/dev/null | head -1) || true
            if [[ "$existing_container_port" == "$existing_port" ]]; then
                _cai_info "Reusing port $existing_port (container exists)"
                printf '%s' "$existing_port"
                return 0
            fi
        fi
    fi

    # Get reserved ports from docker labels (containai-docker context)
    local reserved_ports=""
    reserved_ports=$(docker --context "$_CAI_DOCKER_CONTEXT" ps -a \
        --filter "label=containai.ssh-port" \
        --format '{{.Label "containai.ssh-port"}}' 2>/dev/null | sort -u) || true

    # Also check port files from cai (shared directory)
    local f
    for f in "$_CAI_PORT_DIR"/*; do
        if [[ -f "$f" ]]; then
            reserved_ports="${reserved_ports}"$'\n'"$(cat "$f" 2>/dev/null || true)"
        fi
    done

    # Find next available port in range
    local port
    for port in $(seq "$_CAI_SSH_PORT_RANGE_START" "$_CAI_SSH_PORT_RANGE_END"); do
        # Check if port is reserved by another container or in our port files
        if printf '%s' "$reserved_ports" | grep -qw "$port"; then
            continue
        fi
        # Check if port is in use on the system
        if _cai_is_port_in_use "$port"; then
            continue
        fi

        # Found available port - write to port file
        printf '%s' "$port" > "$port_file"
        _cai_info "Allocated port $port for workspace $workspace_name"
        printf '%s' "$port"
        return 0
    done

    # Fallback (should not happen with 100 ports available)
    _cai_warn "Port range exhausted, using fallback port 2322"
    printf '2322'
}

# ──────────────────────────────────────────────────────────────────────
# Update SSH config via ~/.ssh/containai.d/ (reuses existing pattern from src/lib/ssh.sh)
# Creates workspace-specific config file with Include directive support
# ──────────────────────────────────────────────────────────────────────
_cai_update_ssh_config() {
    local workspace_name="$1"
    local ssh_port="$2"
    local host_alias="containai-devcontainer-${workspace_name}"
    local ssh_dir="$HOME/.ssh/containai.d"
    local config_file="$ssh_dir/devcontainer-${workspace_name}.conf"
    local main_config="$HOME/.ssh/config"

    # Create ~/.ssh directory if needed
    if [[ ! -d "$HOME/.ssh" ]]; then
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
    fi

    # Create containai.d directory if needed
    if [[ ! -d "$ssh_dir" ]]; then
        mkdir -p "$ssh_dir"
        chmod 700 "$ssh_dir"
    fi

    # Ensure Include directive exists at TOP of main config (SSH requires this)
    # Pattern matches Include directives for containai.d regardless of path style
    local include_line="Include ~/.ssh/containai.d/*.conf"
    local include_pattern='^[[:space:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:space:]]+[^#]*containai\.d/'

    if [[ ! -f "$main_config" ]]; then
        # Create new config with Include directive
        printf '%s\n' "$include_line" > "$main_config"
        chmod 600 "$main_config"
    else
        local include_present=false
        local include_at_top=false

        # Check if include directive exists
        if grep -qE "$include_pattern" "$main_config" 2>/dev/null; then
            include_present=true
            # Check if it's at the top (first non-empty, non-comment line)
            local first_effective_line
            first_effective_line=$(grep -v '^[[:space:]]*$' "$main_config" | grep -v '^[[:space:]]*#' | head -1)
            if printf '%s' "$first_effective_line" | grep -qE "$include_pattern"; then
                include_at_top=true
            fi
        fi

        if [[ "$include_present" != "true" ]] || [[ "$include_at_top" != "true" ]]; then
            # Add or move Include to top
            local temp_file
            temp_file=$(mktemp)
            {
                printf '%s\n\n' "$include_line"
                # Remove existing Include for containai.d to avoid duplicates
                grep -vE "$include_pattern" "$main_config" || true
            } > "$temp_file"
            cp "$temp_file" "$main_config"
            rm -f "$temp_file"
            chmod 600 "$main_config"
        fi
    fi

    # Write workspace-specific config with ContainAI markers for cleanup tooling
    cat > "$config_file" << EOF
# ContainAI SSH config for devcontainer: $workspace_name
# Auto-generated by cai-docker - do not edit manually
# Generated at: $(date -u +%Y-%m-%dT%H:%M:%SZ)

Host $host_alias
    HostName localhost
    Port $ssh_port
    User vscode
    StrictHostKeyChecking accept-new
    UserKnownHostsFile $ssh_dir/known_hosts
    # Disable password auth (VS Code uses its own auth method)
    PreferredAuthentications publickey,keyboard-interactive
EOF
    chmod 600 "$config_file"
    _cai_info "SSH config written: $config_file"
    printf 'SSH: ssh %s\n' "$host_alias" >&2
}

# ──────────────────────────────────────────────────────────────────────
# Check if this is a docker create/run command
# As a dockerPath wrapper, argv starts with the subcommand (no "docker" prefix)
# Handles: run, create, container run, container create
# ──────────────────────────────────────────────────────────────────────
_cai_is_container_create_command() {
    local first_token=""
    local second_token=""

    # Find first two non-flag tokens
    for arg in "$@"; do
        if [[ "$arg" != -* ]]; then
            if [[ -z "$first_token" ]]; then
                first_token="$arg"
            elif [[ -z "$second_token" ]]; then
                second_token="$arg"
                break
            fi
        fi
    done

    # Direct run/create
    if [[ "$first_token" == "run" || "$first_token" == "create" ]]; then
        return 0
    fi

    # "container run" or "container create"
    if [[ "$first_token" == "container" ]]; then
        if [[ "$second_token" == "run" || "$second_token" == "create" ]]; then
            return 0
        fi
    fi

    return 1
}

# ──────────────────────────────────────────────────────────────────────
# Decide whether to route non-create commands to containai-docker context
# - Respects explicit --context flags (do not override)
# - Uses containai context if devcontainer/containai filters are present
# - For container-targeting commands, checks if container exists in containai context
# ──────────────────────────────────────────────────────────────────────
_cai_should_use_containai_context() {
    local arg

    # Respect explicit context selection
    for arg in "$@"; do
        case "$arg" in
            --context|--context=*)
                return 1
                ;;
        esac
    done

    # If command uses devcontainer/containai filters, route to containai context
    for arg in "$@"; do
        case "$arg" in
            *devcontainer.*|*containai.*)
                return 0
                ;;
        esac
    done

    # Parse subcommand and attempt container existence check
    local subcmd=""
    local next=""
    for arg in "$@"; do
        if [[ "$arg" != -* ]]; then
            subcmd="$arg"
            break
        fi
    done

    # Handle "container <subcmd>"
    if [[ "$subcmd" == "container" ]]; then
        for arg in "$@"; do
            if [[ "$arg" != -* && "$arg" != "container" ]]; then
                next="$arg"
                break
            fi
        done
        subcmd="$next"
    fi

    case "$subcmd" in
        exec|inspect|start|stop|rm|logs|restart|kill|pause|unpause|port|stats|top)
            local container_name=""
            local seen_subcmd=false
            for arg in "$@"; do
                if [[ "$arg" == "$subcmd" && "$seen_subcmd" == "false" ]]; then
                    seen_subcmd=true
                    continue
                fi
                if [[ "$seen_subcmd" == "true" && "$arg" != -* ]]; then
                    container_name="$arg"
                    break
                fi
            done

            if [[ -n "$container_name" ]]; then
                if docker --context "$_CAI_DOCKER_CONTEXT" inspect "$container_name" &>/dev/null; then
                    return 0
                fi
            fi
            ;;
        *)
            ;;
    esac

    return 1
}

# ──────────────────────────────────────────────────────────────────────
# Validate that volume has no-secrets marker when enableCredentials=false
# Defense-in-depth: prevents mounting credential-containing volumes to
# untrusted workspaces
# ──────────────────────────────────────────────────────────────────────
_cai_validate_volume_credentials() {
    local data_volume="$1"
    local enable_credentials="$2"

    # If credentials are enabled, no validation needed
    if [[ "$enable_credentials" == "true" ]]; then
        return 0
    fi

    # Check for .containai-no-secrets marker in volume
    # Use a temporary container to check the volume contents
    if docker --context "$_CAI_DOCKER_CONTEXT" run --rm \
        -v "${data_volume}:/vol:ro" \
        alpine test -f /vol/.containai-no-secrets 2>/dev/null; then
        _cai_info "Volume $data_volume has no-secrets marker"
        return 0
    fi

    _cai_warn "Volume $data_volume may contain credentials"
    _cai_warn "Options:"
    _cai_warn "  1. Set enableCredentials: true in devcontainer.json (for trusted repos)"
    _cai_warn "  2. Recreate volume with: cai import --no-secrets"
    return 1
}

# ──────────────────────────────────────────────────────────────────────
# Sanitize workspace name for use in SSH host aliases and filenames
# Maps non-alphanumeric chars (except . _ -) to hyphens
# ──────────────────────────────────────────────────────────────────────
_cai_sanitize_workspace_name() {
    local name="$1"
    # Replace any char not in [A-Za-z0-9._-] with hyphen
    printf '%s' "$name" | tr -c 'A-Za-z0-9._-' '-' | sed 's/--*/-/g; s/^-//; s/-$//'
}

# ──────────────────────────────────────────────────────────────────────
# Main entry point
# ──────────────────────────────────────────────────────────────────────
main() {
    # Parse wrapper-specific flags - DO NOT pass to docker (docker has no --verbose/--quiet)
    local -a pass_args=()
    for arg in "$@"; do
        case "$arg" in
            --verbose)
                _CAI_VERBOSE=1
                # Consume for wrapper logging only - do not pass to docker
                ;;
            --quiet)
                _CAI_QUIET=1
                # Consume for wrapper logging only - do not pass to docker
                ;;
            *)
                pass_args+=("$arg")
                ;;
        esac
    done
    set -- "${pass_args[@]}"

    # For non-create commands, route to containai context only when appropriate
    if ! _cai_is_container_create_command "$@"; then
        if _cai_should_use_containai_context "$@"; then
            exec docker --context "$_CAI_DOCKER_CONTEXT" "$@"
        fi
        exec docker "$@"
    fi

    # Extract VS Code devcontainer labels
    local labels config_file local_folder
    labels=$(_cai_extract_devcontainer_labels "$@")
    config_file=$(printf '%s' "$labels" | head -1)
    local_folder=$(printf '%s' "$labels" | tail -1)

    # Check if this is a ContainAI devcontainer
    if [[ -z "$config_file" ]] || ! _cai_has_containai_feature "$config_file"; then
        # Not a ContainAI devcontainer - pass through to regular docker
        exec docker "$@"
    fi

    # Verify containai-docker context exists
    if ! docker context inspect "$_CAI_DOCKER_CONTEXT" &>/dev/null; then
        cat >&2 <<'EOF'
╔═══════════════════════════════════════════════════════════════════╗
║  ContainAI: Not set up. Run: cai setup                            ║
╚═══════════════════════════════════════════════════════════════════╝
EOF
        exit 1
    fi

    local workspace_name workspace_name_sanitized
    workspace_name=$(basename "$local_folder")
    workspace_name_sanitized=$(_cai_sanitize_workspace_name "$workspace_name")
    _cai_info "ContainAI devcontainer detected: $workspace_name"

    local data_volume
    data_volume=$(_cai_get_data_volume "$config_file")
    _cai_info "Data volume: $data_volume"

    local enable_credentials
    enable_credentials=$(_cai_get_enable_credentials "$config_file")
    _cai_info "Credentials enabled: $enable_credentials"

    # ──────────────────────────────────────────────────────────────────
    # Port allocation with lock coordination
    # IMPORTANT: Lock held across allocation AND docker exec to prevent
    # races where cai could allocate the same port before container is
    # created and labeled.
    #
    # Linux: flock on FD 200 (inherited by exec) - FULL COORDINATION
    # macOS: flock not available - V1 KNOWN LIMITATION
    # ──────────────────────────────────────────────────────────────────
    mkdir -p "$_CAI_CONFIG_DIR" 2>/dev/null || true

    # Acquire lock (held until exec or exit)
    local lock_acquired=false
    if command -v flock &>/dev/null; then
        exec 200>"$_CAI_LOCK_FILE"
        if flock -w 10 200; then
            lock_acquired=true
            _cai_info "Port allocation lock acquired"
        else
            _cai_warn "Could not acquire port lock (timeout)"
        fi
    else
        # V1 LIMITATION (macOS): Without flock, concurrent cai + cai-docker
        # operations may race on port allocation. Mitigation: port files
        # provide best-effort coordination. Full fix requires V2 enhancement.
        _cai_info "flock not available (macOS) - using best-effort coordination"
    fi

    local ssh_port
    # Use original workspace name for port allocation (matches container labels)
    # The port file path uses sanitized name internally
    ssh_port=$(_cai_allocate_ssh_port "$workspace_name")

    # Validate volume credentials (defense-in-depth)
    local mount_volume=true
    if ! _cai_validate_volume_credentials "$data_volume" "$enable_credentials"; then
        mount_volume=false
    fi

    # Build modified args with injected options
    local -a args=()

    for arg in "$@"; do
        args+=("$arg")

        # Inject after run/create command
        if [[ "$arg" == "run" || "$arg" == "create" ]]; then
            # Enforce sysbox runtime at launch time
            args+=("--runtime=sysbox-runc")

            # Mount data volume if validated (use --mount for explicit volume semantics)
            if [[ "$mount_volume" == "true" ]]; then
                if docker --context "$_CAI_DOCKER_CONTEXT" volume inspect "$data_volume" &>/dev/null; then
                    args+=("--mount" "type=volume,src=${data_volume},dst=/mnt/agent-data,readonly=false")
                    _cai_info "Mounting data volume: $data_volume"
                else
                    _cai_warn "Data volume $data_volume not found - skipping mount"
                fi
            fi

            # Pass SSH port to container via env var
            args+=("-e" "CONTAINAI_SSH_PORT=${ssh_port}")

            # Labels for cai ps/stop/gc integration (complete set)
            # Use original workspace_name for display, sanitized for identifiers
            args+=("--label" "containai.managed=true")
            args+=("--label" "containai.type=devcontainer")
            args+=("--label" "containai.devcontainer.workspace=${workspace_name}")
            args+=("--label" "containai.data-volume=${data_volume}")
            args+=("--label" "containai.ssh-port=${ssh_port}")
            # Use portable timestamp format (POSIX, not GNU-only date -Iseconds)
            args+=("--label" "containai.created=$(date -u +%Y-%m-%dT%H:%M:%SZ)")
        fi
    done

    # Update SSH config (use sanitized name for host alias and filename)
    _cai_update_ssh_config "$workspace_name_sanitized" "$ssh_port"

    _cai_info "Executing: docker --context $_CAI_DOCKER_CONTEXT ${args[*]}"

    # Execute with containai-docker context
    # Lock is released when exec replaces this process (FD 200 is closed)
    exec docker --context "$_CAI_DOCKER_CONTEXT" "${args[@]}"
}

main "$@"
