# syntax=docker/dockerfile:1
# ContainAI Full Layer - AI Agents and CLI Tools
#
# Includes: Claude Code, Gemini CLI, Copilot, Codex, OpenCode, agent-browser, gh CLI
#
# Usage (from repo root, requires BuildKit):
#   ./src/build.sh --layer full
#
# Manual docker build requires a prebuilt cai tarball:
#   dotnet msbuild ./src/cai/cai.csproj \
#     -t:BuildContainAITarballs \
#     -p:Configuration=Release \
#     -p:ContainAIRuntimeIdentifiers=linux-x64 \
#     -p:ContainAIVersion=<version> \
#     -p:ContainAIOutputDir=./artifacts/cai-tarballs
#   docker build -t containai/full -f src/container/Dockerfile.agents .
#
# Requires containai/sdks:latest to be built first (or use ./src/build.sh for all layers)
#
# Note: Requires Docker BuildKit (Docker 23.0+ or DOCKER_BUILDKIT=1)

ARG SDKS_IMAGE=ghcr.io/novotnyllc/containai/sdks:latest
FROM ${SDKS_IMAGE}

SHELL ["/bin/bash", "-o", "pipefail", "-c"]

# =============================================================================
# GITHUB CLI
# =============================================================================
USER root

RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    # Add GitHub CLI GPG key and repository
    curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
        -o /usr/share/keyrings/githubcli-archive-keyring.gpg && \
    chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg && \
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
        > /etc/apt/sources.list.d/github-cli.list && \
    apt-get update && \
    apt-get install -y --no-install-recommends gh && \
    # Verify gh installed correctly
    gh --version

# =============================================================================
# AI AGENTS
# Installed as agent user for proper permissions
# =============================================================================
USER agent
WORKDIR /home/agent

# Create agent data directories for config/auth file symlinks
# Note: Primary agents are pre-created; optional agent paths are still
# symlinked to the data volume so all agent data lives there, but remain
# empty until configured by the user.
RUN mkdir -p \
    /home/agent/.claude \
    /home/agent/.codex \
    /home/agent/.local/share/opencode

# Install Claude Code via official installer
RUN curl -fsSL https://claude.ai/install.sh | bash && \
    # Verify claude installed correctly
    /home/agent/.local/bin/claude --version

# Add Claude/local binaries to PATH via .bashrc.d (for interactive non-login shells)
# SSH login shells get PATH from /etc/profile.d/containai-agent-path.sh (set in base image)
RUN printf '%s\n' \
    'export PATH="/home/agent/.local/bin:${PATH}"' \
    > /home/agent/.bashrc.d/01-oai-env-vars.sh

# Configure bash history to persist in data volume (survives --fresh)
# History file is per-workspace since each workspace has its own data volume
RUN printf '%s\n' \
    '# Persist bash history to data volume' \
    'export HISTFILE=/mnt/agent-data/shell/history' \
    'export HISTSIZE=10000' \
    'export HISTFILESIZE=20000' \
    > /home/agent/.bashrc.d/02-shell-history.sh

ENV PATH="/home/agent/.local/bin:${PATH}"

# Install Gemini CLI, Codex, and agent-browser via bun
# Using --trust to allow postinstall scripts
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    . /home/agent/.nvm/nvm.sh && \
    bun install -g --trust @google/gemini-cli @openai/codex playwright agent-browser skills @mariozechner/pi-coding-agent && agent-browser install --with-deps \
    # Verify installations
    gemini --version && \
    codex --version

# Install Copilot CLI via official installer
RUN curl -fsSL https://gh.io/copilot-install | bash && \
    # Verify copilot installed correctly
    copilot --version && \
    # Remove optional agent home dir to avoid pollution when no config is present
    rm -rf /home/agent/.copilot

# Install OpenCode via official installer
RUN curl -fsSL https://opencode.ai/install | bash && \
    ln -snf /home/agent/.opencode/bin/opencode /home/agent/.local/bin/opencode && \
    # Verify opencode installed correctly (opencode may not have --version)
    /home/agent/.local/bin/opencode --version

# Install Kimi CLI
RUN uv tool install --python 3.13 kimi-cli && \
    # Verify kimi installed correctly
    kimi --version

# =============================================================================
# CONTAINAI CLI
# In-container cai command for sync and other operations
# =============================================================================
USER root
ARG TARGETARCH
RUN --mount=type=bind,source=artifacts/cai-tarballs,target=/tmp/cai,readonly \
    set -euo pipefail; \
    tarball=""; \
    case "${TARGETARCH:-}" in \
        amd64) tarball="$(ls -1 /tmp/cai/containai-*-linux-x64.tar.gz 2>/dev/null | head -n 1)" ;; \
        arm64) tarball="$(ls -1 /tmp/cai/containai-*-linux-arm64.tar.gz 2>/dev/null | head -n 1)" ;; \
        *) echo "ERROR: Unsupported TARGETARCH: ${TARGETARCH:-unset}" >&2; exit 1 ;; \
    esac; \
    if [[ -z "$tarball" || ! -f "$tarball" ]]; then \
        echo "ERROR: ContainAI CLI tarball not found: $tarball" >&2; \
        echo "Run dotnet msbuild src/cai/cai.csproj -t:BuildContainAITarballs before building this image." >&2; \
        exit 1; \
    fi; \
    rm -rf /opt/containai; \
    mkdir -p /opt/containai; \
    tar -xzf "$tarball" -C /opt/containai --strip-components 1
RUN ln -sf /opt/containai/cai /usr/local/bin/cai

# =============================================================================
# AGENT CONFIGURATION SYMLINKS
# Symlink config files to /mnt/agent-data for persistence across container restarts
# Uses native cai manifest apply logic from built-in manifests
# =============================================================================

# Pre-symlink setup: move installer-created files to data volume location
RUN if [ -f /home/agent/.claude.json ]; then \
        mkdir -p /mnt/agent-data/claude && \
        mv /home/agent/.claude.json /mnt/agent-data/claude/claude.json; \
    fi && \
    # Clean OpenCode installer state (selective sync requires clean slate)
    rm -rf /home/agent/.config/opencode && \
    mkdir -p /home/agent/.config/opencode

# Ensure /mnt/agent-data exists and is owned by agent user
# The base image creates this, but we verify here as a safeguard since
# manifest apply runs as USER agent and needs to create subdirectories
USER root
RUN mkdir -p /mnt/agent-data && chown agent:agent /mnt/agent-data

USER agent
RUN cai manifest apply container-links /opt/containai/manifests --home-dir /home/agent --data-dir /mnt/agent-data

# =============================================================================
# POST-SYMLINK SETUP
# Special configuration that must happen after symlinks are created
# =============================================================================

# SSH directory permissions (symlinks created by generated script)
RUN chmod 700 /home/agent/.ssh

# Add bashrc hooks for imported aliases and volume bashrc.d scripts
# Note: Build-time .bashrc.d scripts (like 01-claude.sh) are already sourced via base layer
# This adds sourcing for user-imported scripts from the data volume
RUN { grep -qxF '[ -f ~/.bash_aliases_imported ] && . ~/.bash_aliases_imported' /home/agent/.bashrc \
      || { echo '# Source imported bash_aliases if exists'; echo '[ -f ~/.bash_aliases_imported ] && . ~/.bash_aliases_imported'; } >> /home/agent/.bashrc; } && \
    { grep -qxF 'if [ -d /mnt/agent-data/shell/bashrc.d ]; then for f in /mnt/agent-data/shell/bashrc.d/*.sh; do [ -r "$f" ] && . "$f"; done; fi' /home/agent/.bashrc \
      || { echo '# Source user scripts from data volume'; echo 'if [ -d /mnt/agent-data/shell/bashrc.d ]; then for f in /mnt/agent-data/shell/bashrc.d/*.sh; do [ -r "$f" ] && . "$f"; done; fi'; } >> /home/agent/.bashrc; } && \
    { grep -qxF '[ -f /mnt/agent-data/shell/zsh-imported.sh ] && . /mnt/agent-data/shell/zsh-imported.sh' /home/agent/.bashrc \
      || { echo '# Source POSIX-compatible settings extracted from zsh config (Mac users)'; echo '[ -f /mnt/agent-data/shell/zsh-imported.sh ] && . /mnt/agent-data/shell/zsh-imported.sh'; } >> /home/agent/.bashrc; }

# =============================================================================
# AGENT WRAPPER FUNCTIONS
# Generated functions for running agents in autonomous mode
# Functions (not aliases) work in both interactive and non-interactive SSH
# =============================================================================

# Create .bash_env.d directory for modular BASH_ENV sourcing
RUN mkdir -p /home/agent/.bash_env.d

# Generate agent wrappers from manifests to .bash_env.d (for BASH_ENV non-interactive sourcing)
RUN cai manifest generate agent-wrappers /opt/containai/manifests /home/agent/.bash_env.d/containai-agents.sh

# Update .bash_env to source all .bash_env.d/*.sh files and set guard variable
# The base image creates .bash_env with just nvm setup; we extend it
RUN grep -qxF 'export _BASH_ENV_SOURCED=1' /home/agent/.bash_env || \
    printf '\n%s\n%s\n%s\n' \
    '# Guard to prevent double-sourcing' \
    'export _BASH_ENV_SOURCED=1' \
    '# Source all scripts in .bash_env.d/' \
    >> /home/agent/.bash_env && \
    grep -qxF 'if [ -d "$HOME/.bash_env.d" ]; then for f in "$HOME"/.bash_env.d/*.sh; do [ -r "$f" ] && . "$f"; done; fi' /home/agent/.bash_env || \
    printf '%s\n' \
    'if [ -d "$HOME/.bash_env.d" ]; then for f in "$HOME"/.bash_env.d/*.sh; do [ -r "$f" ] && . "$f"; done; fi' \
    >> /home/agent/.bash_env

# Source .bash_env from .bashrc for interactive shells (with guard to prevent double-sourcing)
# This ensures wrappers work in both: `ssh container 'claude --help'` (non-interactive via BASH_ENV)
# and `ssh container` + `claude --help` (interactive via .bashrc -> .bash_env)
RUN grep -qxF '[ -z "$_BASH_ENV_SOURCED" ] && [ -f ~/.bash_env ] && . ~/.bash_env' /home/agent/.bashrc || \
    printf '\n%s\n%s\n' \
    '# Source .bash_env for wrapper functions (if not already sourced via BASH_ENV)' \
    '[ -z "$_BASH_ENV_SOURCED" ] && [ -f ~/.bash_env ] && . ~/.bash_env' \
    >> /home/agent/.bashrc

# =============================================================================
# CONTAINAI-INIT SERVICE
# One-shot systemd service to prepare volume structure on first boot
# This handles the runtime setup that entrypoint.sh did in Docker sandbox mode
# =============================================================================
USER root

COPY src/container/containai-init.sh /usr/local/lib/containai/init.sh
COPY src/services/containai-init.service /etc/systemd/system/containai-init.service
RUN chmod +x /usr/local/lib/containai/init.sh && \
    # Enable the service via symlink (systemctl requires systemd as PID 1)
    mkdir -p /etc/systemd/system/multi-user.target.wants && \
    ln -sf /etc/systemd/system/containai-init.service /etc/systemd/system/multi-user.target.wants/containai-init.service

# =============================================================================
# LINK SPEC AND REPAIR TOOLS
# Runtime link verification/repair + generated JSON link spec
# =============================================================================
COPY src/container/link-repair.sh /usr/local/lib/containai/link-repair.sh
RUN chmod +x /usr/local/lib/containai/link-repair.sh && \
    cai manifest generate container-link-spec /opt/containai/manifests /usr/local/lib/containai/link-spec.json

# =============================================================================
# USER MANIFEST RUNTIME SUPPORT
# Runtime generators for user-defined agent manifests
# =============================================================================
COPY src/container/lib/gen-user-links.sh /usr/local/lib/containai/
COPY src/container/lib/gen-user-wrappers.sh /usr/local/lib/containai/
RUN chmod +x /usr/local/lib/containai/gen-user-links.sh /usr/local/lib/containai/gen-user-wrappers.sh

# =============================================================================
# LINK WATCHER SERVICE
# Monitors for new imports and auto-repairs symlinks
# =============================================================================
COPY src/container/link-watcher.sh /usr/local/lib/containai/link-watcher.sh
COPY src/services/containai-link-watcher.service /etc/systemd/system/containai-link-watcher.service
RUN chmod +x /usr/local/lib/containai/link-watcher.sh && \
    ln -sf /etc/systemd/system/containai-link-watcher.service /etc/systemd/system/multi-user.target.wants/containai-link-watcher.service

USER agent

# =============================================================================
# FINAL CONFIGURATION
# =============================================================================
USER root

# Clean up temporary files
RUN rm -rf /tmp/*

# Dynamic build args at end to avoid cache invalidation
ARG BUILD_DATE=unknown
ARG VCS_REF=unknown
ARG VERSION=unknown

LABEL org.opencontainers.image.title="ContainAI Full" \
      org.opencontainers.image.description="Complete AI agent sandbox with Claude, Gemini, Copilot, Codex, OpenCode, and gh CLI" \
      org.opencontainers.image.url="https://github.com/novotnyllc/containai" \
      org.opencontainers.image.source="https://github.com/novotnyllc/containai" \
      org.opencontainers.image.documentation="https://github.com/novotnyllc/containai#readme" \
      org.opencontainers.image.vendor="Claire Novotny LLC" \
      org.opencontainers.image.licenses="MIT" \
      org.opencontainers.image.version="${VERSION}" \
      org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.revision="${VCS_REF}"

# Inherit entrypoint from base (systemd as PID 1)
# Volume setup is handled by containai-init.service on first boot
