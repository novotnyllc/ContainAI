#!/usr/bin/env bash
# Launch an ephemeral coding agent session that auto-attaches to the agent CLI
# Containers auto-clean on exit but keep all git safeguards and host mounts

set -e

# Source shared functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../utils/common-functions.sh"

REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
maybe_check_launcher_updates "$REPO_ROOT" "run-agent"

# Default values
AGENT=""
SOURCE="."
BRANCH=""
BRANCH_FROM_FLAG=false
NAME=""
DOTNET_PREVIEW=""
NETWORK_PROXY="allow-all"
CPU="4"
MEMORY="8g"
GPU=""
NO_PUSH=false
FORCE=false
USE_CURRENT_BRANCH=false
LOCAL_REMOTE_HOST_PATH=""
LOCAL_REMOTE_WSL_PATH=""
LOCAL_REMOTE_URL=""
LOCAL_REPO_PATH_VALUE=""

# First argument must be agent type
if [[ $# -eq 0 || "$1" == "-"* ]]; then
    echo "‚ùå Error: Agent type is required as first argument"
    echo "Usage: run-agent <agent> [SOURCE] [OPTIONS]"
    echo "Agent types: copilot, codex, claude"
    exit 1
fi

AGENT="$1"
shift

# Validate agent
case "$AGENT" in
    copilot|codex|claude) ;;
    *)
        echo "‚ùå Error: Invalid agent type '$AGENT'"
        echo "Valid options: copilot, codex, claude"
        exit 1
        ;;
esac

# Parse remaining arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--branch)
            BRANCH="$2"
            BRANCH_FROM_FLAG=true
            shift 2
            ;;
        --name)
            NAME="$2"
            shift 2
            ;;
        --dotnet-preview)
            DOTNET_PREVIEW="$2"
            shift 2
            ;;
        --network-proxy)
            NETWORK_PROXY="$2"
            shift 2
            ;;
        --cpu)
            CPU="$2"
            shift 2
            ;;
        --memory)
            MEMORY="$2"
            shift 2
            ;;
        --gpu)
            GPU="$2"
            shift 2
            ;;
        --no-push)
            NO_PUSH=true
            shift
            ;;
        --use-current-branch)
            USE_CURRENT_BRANCH=true
            shift
            ;;
        -y|--force)
            FORCE=true
            shift
            ;;
        -h|--help)
            echo "Usage: run-agent <agent> [SOURCE] [OPTIONS]"
            echo ""
            echo "Agent types: copilot, codex, claude"
            echo ""
            echo "SOURCE can be:"
            echo "  ‚Ä¢ Local path to a git repository (default: current directory)"
            echo "  ‚Ä¢ Git URL (https://...)"
            echo ""
            echo "Options:"
            echo "  -b, --branch BRANCH         Branch name (creates <agent>/<branch>)"
            echo "  --name NAME                 Custom container name"
            echo "  --dotnet-preview CHANNEL    Install .NET preview SDK (e.g., 11.0)"
            echo "  --network-proxy MODE        Network proxy: allow-all, restricted, squid (default: allow-all)"
            echo "  --cpu NUM                   CPU limit (default: 4)"
            echo "  --memory SIZE               Memory limit (default: 8g)"
            echo "  --gpu SPEC                  GPU specification (e.g., 'all' or 'device=0')"
            echo "  --no-push                   Disable auto-push on container shutdown"
            echo "  --use-current-branch        Use current branch instead of creating agent branch (unsafe)"
            echo "  -y, --force                 Automatically replace existing agent branch without prompting"
            echo "  -h, --help                  Show this help"
            echo ""
            echo "Branch Behavior:"
            echo "  ‚Ä¢ Without --branch: creates unique session branch <agent>/session-N"
            echo "  ‚Ä¢ With --branch: creates <agent>/<branch>"
            echo "  ‚Ä¢ Already on agent branch: reuses that branch"
            echo "  ‚Ä¢ Use --use-current-branch to work directly on current branch"
            echo "  ‚Ä¢ Existing agent branches prompt for replacement"
            echo "  ‚Ä¢ Branches with unmerged commits are archived before replacement"
            echo ""
            echo "Examples:"
            echo "  run-agent copilot                              # Copilot in current directory"
            echo "  run-agent codex . -b refactor-db               # Codex in current dir, custom branch"
            echo "  run-agent copilot https://github.com/user/repo # Copilot from GitHub"
            echo "  run-agent claude /path/to/repo --name my-workspace"
            echo "  run-agent copilot . -b feature-api -y          # Auto-replace existing agent branch"
            exit 0
            ;;
        *)
            SOURCE="$1"
            shift
            ;;
    esac
done

# Validate network proxy option
case "$NETWORK_PROXY" in
    allow-all|none|restricted|squid) ;;
    *)
        echo "‚ùå Error: Invalid --network-proxy value '$NETWORK_PROXY'"
        exit 1
        ;;
esac

# Treat 'none' as alias for allow-all
[ "$NETWORK_PROXY" = "none" ] && NETWORK_PROXY="allow-all"

# Check Docker
check_docker_running || exit 1
CONTAINER_CLI=$(get_active_container_cmd)

# Determine if source is URL or local path
if [[ "$SOURCE" =~ ^https?:// ]]; then
    IS_URL=true
    SOURCE_TYPE="url"
    REPO_NAME=$(basename "$SOURCE" .git)
    GIT_URL="$SOURCE"
    ORIGIN_URL="$GIT_URL"
    WSL_PATH=""
else
    IS_URL=false
    SOURCE_TYPE="local"
    SOURCE=$(realpath "$SOURCE")
    
    # Check if git repository
    if [ ! -d "$SOURCE/.git" ]; then
        echo "‚ùå Error: $SOURCE is not a git repository"
        exit 1
    fi
    
    REPO_NAME=$(basename "$SOURCE")
    cd "$SOURCE"
    ORIGIN_URL=$(git remote get-url origin 2>/dev/null || echo "")
    cd - > /dev/null
    WSL_PATH=$(convert_to_wsl_path "$SOURCE")
    GIT_URL=""
    LOCAL_REPO_PATH_VALUE="$WSL_PATH"

    if [ "$NO_PUSH" != true ]; then
        REMOTE_HASH=$(printf "%s" "$SOURCE" | (command -v shasum >/dev/null 2>&1 && shasum -a 256 || sha256sum) | awk '{print $1}')
        REMOTE_HASH=${REMOTE_HASH:0:16}
        LOCAL_REMOTE_DIR="${CODING_AGENTS_LOCAL_REMOTES_DIR:-${HOME}/.coding-agents/local-remotes}"
        LOCAL_REMOTE_HOST_PATH="$LOCAL_REMOTE_DIR/${REMOTE_HASH}.git"
        mkdir -p "$LOCAL_REMOTE_DIR"
        if [ ! -d "$LOCAL_REMOTE_HOST_PATH" ]; then
            git init --bare "$LOCAL_REMOTE_HOST_PATH" >/dev/null
        fi
        LOCAL_REMOTE_WSL_PATH=$(convert_to_wsl_path "$LOCAL_REMOTE_HOST_PATH")
        LOCAL_REMOTE_URL="file:///tmp/local-remote"
        LOCAL_REPO_PATH_VALUE="$LOCAL_REMOTE_URL"
    fi

    if [ "$NO_PUSH" != true ] && [ -z "$LOCAL_REMOTE_URL" ]; then
        echo "‚ùå Failed to configure secure local remote for auto-push"
        exit 1
    fi
fi

if [ "$USE_CURRENT_BRANCH" = "true" ]; then
    if [ "$SOURCE_TYPE" != "local" ]; then
        echo "‚ùå Error: --use-current-branch is only supported for local repositories"
        exit 1
    fi
    if [ "$BRANCH_FROM_FLAG" = "true" ]; then
        echo "‚ùå Error: --use-current-branch cannot be combined with --branch"
        exit 1
    fi
fi

# Restricted network cannot clone URLs
if [ "$NETWORK_PROXY" = "restricted" ] && [ "$SOURCE_TYPE" = "url" ]; then
    echo "‚ùå Restricted network mode cannot clone from a URL. Provide a local path or use --network-proxy allow-all."
    exit 1
fi

# Helper: Check if branch name follows agent naming convention
is_agent_branch() {
    local branch_name="$1"
    [[ "$branch_name" =~ ^(copilot|codex|claude)/ ]]
}

# Helper: Find next available session number
find_next_session() {
    local repo_path="$1"
    local agent="$2"
    local n=1
    cd "$repo_path"
    while git show-ref --verify --quiet "refs/heads/${agent}/session-${n}" 2>/dev/null; do
        ((n++))
    done
    cd - > /dev/null
    echo "$n"
}

# Determine branch name with safety checks
if [ -z "$BRANCH" ]; then
    if [ "$SOURCE_TYPE" = "local" ]; then
        cd "$SOURCE"
        CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        cd - > /dev/null
        
        # Safety: Never use current branch unless explicitly allowed and available
        if [ "$USE_CURRENT_BRANCH" = "true" ]; then
            if [ -z "$CURRENT_BRANCH" ]; then
                echo "‚ùå Error: Repository is in detached HEAD state; cannot use --use-current-branch"
                exit 1
            fi
            BRANCH="$CURRENT_BRANCH"
            echo "‚ö†Ô∏è  Warning: Using current branch directly (--use-current-branch specified)"
        elif is_agent_branch "$CURRENT_BRANCH"; then
            # Current branch is already an agent branch, safe to use
            BRANCH="$CURRENT_BRANCH"
            echo "‚úì Current branch '$CURRENT_BRANCH' is an agent branch"
        else
            # Generate unique session branch
            SESSION_NUM=$(find_next_session "$SOURCE" "$AGENT")
            BRANCH="session-${SESSION_NUM}"
            echo "‚ÑπÔ∏è  Creating new branch '${AGENT}/${BRANCH}' (current: ${CURRENT_BRANCH:-main})"
        fi
    else
        BRANCH="main"
    fi
fi

if ! validate_branch_name "$BRANCH"; then
    echo "‚ùå Error: Invalid branch name '$BRANCH'"
    echo "   Branch names must start with alphanumeric characters and avoid spaces"
    exit 1
fi

# Sanitize branch name for container naming
SAFE_BRANCH=$(echo "$BRANCH" | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')

# Determine container names
if [ -n "$NAME" ]; then
    if ! validate_container_name "$NAME"; then
        echo "‚ùå Error: Invalid custom name '$NAME'"
        echo "   Container names must start with alphanumeric characters and may include . _ -"
        exit 1
    fi
    CONTAINER_NAME="${AGENT}-${NAME}"
    WORKSPACE_NAME="$NAME"
else
    CONTAINER_NAME="${AGENT}-${REPO_NAME}-${SAFE_BRANCH}"
    WORKSPACE_NAME="$REPO_NAME"
fi

if ! validate_container_name "$CONTAINER_NAME"; then
    echo "‚ùå Error: Generated container name '$CONTAINER_NAME' is invalid"
    echo "   Adjust --name, repository, or branch to avoid spaces and special characters"
    exit 1
fi

# Determine agent branch (handle case where BRANCH is already agent/branch format)
if [ "$USE_CURRENT_BRANCH" = "true" ]; then
    AGENT_BRANCH="$BRANCH"
elif is_agent_branch "$BRANCH"; then
    AGENT_BRANCH="$BRANCH"
else
    AGENT_BRANCH="${AGENT}/${BRANCH}"
fi

PROXY_CONTAINER_NAME="${CONTAINER_NAME}-proxy"
PROXY_NETWORK_NAME="${CONTAINER_NAME}-net"
PROXY_IMAGE="coding-agents-proxy:local"

# Pull latest image
pull_and_tag_image "$AGENT"
IMAGE_NAME="coding-agents-${AGENT}:local"

# Get timezone
TZ_VALUE="${TZ:-$(cat /etc/timezone 2>/dev/null || echo UTC)}"

# Squid allowed domains
SQUID_ALLOWED_DOMAINS="*.github.com,*.githubcopilot.com,*.nuget.org,*.npmjs.org,*.pypi.org,*.python.org,*.microsoft.com,*.docker.io,registry-1.docker.io,api.githubcopilot.com,learn.microsoft.com,platform.uno,*.githubusercontent.com,*.azureedge.net"

# Determine network mode
NETWORK_MODE="bridge"
NETWORK_POLICY_ENV="allow-all"
USE_SQUID=false
PROXY_URL=""

case "$NETWORK_PROXY" in
    restricted)
        NETWORK_MODE="none"
        NETWORK_POLICY_ENV="restricted"
        ;;
    squid)
        NETWORK_MODE="$PROXY_NETWORK_NAME"
        NETWORK_POLICY_ENV="squid"
        USE_SQUID=true
        PROXY_URL="http://${PROXY_CONTAINER_NAME}:3128"
        ;;
    *)
        NETWORK_POLICY_ENV="allow-all"
        ;;
esac

# Check for branch conflicts in local repos (only when creating isolated branches)
if [ "$SOURCE_TYPE" = "local" ] && [ "$USE_CURRENT_BRANCH" != "true" ]; then
    RESOLVED_PATH=$(realpath "$SOURCE")
    
    # Check if agent branch already exists
    if branch_exists "$RESOLVED_PATH" "$AGENT_BRANCH"; then
        echo "‚ö†Ô∏è  Branch '$AGENT_BRANCH' already exists in the repository"
        echo ""
        
        # Get current branch to check for unmerged commits
        cd "$RESOLVED_PATH"
        CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
        cd - > /dev/null
        
        # Check for unmerged commits
        UNMERGED_COMMITS=$(get_unmerged_commits "$RESOLVED_PATH" "$CURRENT_BRANCH" "$AGENT_BRANCH")
        
        if [ -n "$UNMERGED_COMMITS" ]; then
            echo "üìù Branch has unmerged commits:"
            echo "$UNMERGED_COMMITS" | head -5
            COMMIT_COUNT=$(echo "$UNMERGED_COMMITS" | wc -l)
            if [ "$COMMIT_COUNT" -gt 5 ]; then
                echo "   ... and $((COMMIT_COUNT - 5)) more"
            fi
            echo ""
            echo "   ‚ÑπÔ∏è  The branch will be archived before creating a new one."
            echo ""
        fi
        
        # Prompt for replacement unless force flag is set
        if [ "$FORCE" != "true" ]; then
            read -p "Replace existing branch? (y/N): " -n 1 -r REPLY
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "‚ùå Aborted. Use -y or --force to automatically replace."
                exit 1
            fi
        else
            echo "   üîÑ Force flag set - replacing automatically"
        fi
        
        # Archive or delete the branch
        if [ -n "$UNMERGED_COMMITS" ]; then
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            ARCHIVE_NAME="${AGENT_BRANCH}-archived-${TIMESTAMP}"
            echo "üì¶ Archiving to: $ARCHIVE_NAME"
            
            if rename_git_branch "$RESOLVED_PATH" "$AGENT_BRANCH" "$ARCHIVE_NAME"; then
                echo "   ‚úÖ Branch archived successfully"
            else
                echo "   ‚ùå Failed to archive branch"
                exit 1
            fi
        else
            echo "üóëÔ∏è  Removing existing branch (no unmerged commits)"
            if remove_git_branch "$RESOLVED_PATH" "$AGENT_BRANCH" "true"; then
                echo "   ‚úÖ Branch removed successfully"
            else
                echo "   ‚ùå Failed to remove branch"
                exit 1
            fi
        fi
        echo ""
    fi
fi

echo "üöÄ Launching Coding Agent..."
echo "üéØ Agent: $AGENT"
echo "üìÅ Source: $SOURCE ($SOURCE_TYPE)"
echo "üåø Branch: $AGENT_BRANCH"
echo "üè∑Ô∏è  Container: $CONTAINER_NAME"
echo "üê≥ Image: $IMAGE_NAME"
echo "üåê Network policy: $NETWORK_POLICY_ENV"
echo ""

# Check if container already exists
if container_exists "$CONTAINER_NAME"; then
    echo "üì¶ Container '$CONTAINER_NAME' already exists"
    STATE=$(get_container_status "$CONTAINER_NAME")
    
    # Handle existing proxy if squid mode
    if [ "$USE_SQUID" = true ]; then
        EXISTING_PROXY=$(container_cli inspect -f '{{ index .Config.Labels "coding-agents.proxy-container" }}' "$CONTAINER_NAME" 2>/dev/null || echo "$PROXY_CONTAINER_NAME")
        EXISTING_NETWORK=$(container_cli inspect -f '{{ index .Config.Labels "coding-agents.proxy-network" }}' "$CONTAINER_NAME" 2>/dev/null || echo "$PROXY_NETWORK_NAME")
        PROXY_CONTAINER_NAME="$EXISTING_PROXY"
        PROXY_NETWORK_NAME="$EXISTING_NETWORK"
        ensure_squid_proxy "$PROXY_NETWORK_NAME" "$PROXY_CONTAINER_NAME" "$PROXY_IMAGE" "$CONTAINER_NAME" "$SQUID_ALLOWED_DOMAINS"
    fi
    
    if [ "$STATE" = "running" ]; then
        echo "‚úÖ Container is already running"
        echo "   Connect via: $CONTAINER_CLI exec -it $CONTAINER_NAME bash"
        echo "   Or use VS Code Dev Containers extension"
        exit 0
    else
        echo "‚ñ∂Ô∏è  Starting existing container..."
        container_cli start "$CONTAINER_NAME"
        echo "‚úÖ Container started"
        exit 0
    fi
fi

# Setup squid proxy if needed
if [ "$USE_SQUID" = true ]; then
    ensure_squid_proxy "$PROXY_NETWORK_NAME" "$PROXY_CONTAINER_NAME" "$PROXY_IMAGE" "$CONTAINER_NAME" "$SQUID_ALLOWED_DOMAINS"
fi

# Build docker arguments
AUTO_PUSH_VALUE=$([ "$NO_PUSH" = true ] && echo "false" || echo "true")

DOCKER_ARGS=(
    "run" "-d" "--rm"
    "--name" "$CONTAINER_NAME"
    "--hostname" "$CONTAINER_NAME"
    "-e" "TZ=$TZ_VALUE"
    "-e" "SOURCE_TYPE=$SOURCE_TYPE"
    "-e" "REPO_NAME=$WORKSPACE_NAME"
    "-e" "AGENT_BRANCH=$AGENT_BRANCH"
    "-e" "NETWORK_POLICY=$NETWORK_POLICY_ENV"
    "-e" "AUTO_PUSH_ON_SHUTDOWN=$AUTO_PUSH_VALUE"
    "-e" "AGENT_SESSION_MODE=supervised"
    "-e" "AGENT_SESSION_NAME=agent"
    "--label" "coding-agents.type=agent"
    "--label" "coding-agents.agent=$AGENT"
    "--label" "coding-agents.repo=$REPO_NAME"
    "--label" "coding-agents.branch=$AGENT_BRANCH"
    "--label" "coding-agents.network-policy=$NETWORK_POLICY_ENV"
    "-v" "${HOME}/.gitconfig:/home/agentuser/.gitconfig:ro"
    "-v" "${HOME}/.config/gh:/home/agentuser/.config/gh:ro"
    "-v" "${HOME}/.config/github-copilot:/home/agentuser/.config/github-copilot:ro"
)

# Add source-specific vars
if [ "$SOURCE_TYPE" = "url" ]; then
    DOCKER_ARGS+=("-e" "GIT_URL=$GIT_URL")
else
    LOCAL_REPO_ENV_VALUE="${LOCAL_REPO_PATH_VALUE:-$WSL_PATH}"
    DOCKER_ARGS+=("-e" "LOCAL_REPO_PATH=$LOCAL_REPO_ENV_VALUE")
    DOCKER_ARGS+=("-v" "${WSL_PATH}:/tmp/source-repo:ro")
    DOCKER_ARGS+=("--label" "coding-agents.repo-path=$RESOLVED_PATH")
    if [ -n "${LOCAL_REMOTE_WSL_PATH:-}" ]; then
        DOCKER_ARGS+=("-e" "LOCAL_REMOTE_URL=${LOCAL_REMOTE_URL}")
        DOCKER_ARGS+=("-v" "${LOCAL_REMOTE_WSL_PATH}:/tmp/local-remote")
        DOCKER_ARGS+=("--label" "coding-agents.local-remote=$LOCAL_REMOTE_HOST_PATH")
    fi
fi

[ -n "$ORIGIN_URL" ] && DOCKER_ARGS+=("-e" "ORIGIN_URL=$ORIGIN_URL")
[ -n "$DOTNET_PREVIEW" ] && DOCKER_ARGS+=("-e" "DOTNET_PREVIEW_CHANNEL=$DOTNET_PREVIEW")

# Add proxy environment if squid
if [ "$USE_SQUID" = true ]; then
    DOCKER_ARGS+=(
        "-e" "HTTP_PROXY=$PROXY_URL"
        "-e" "HTTPS_PROXY=$PROXY_URL"
        "-e" "http_proxy=$PROXY_URL"
        "-e" "https_proxy=$PROXY_URL"
        "-e" "NO_PROXY=localhost,127.0.0.1,.internal,::1"
        "-e" "no_proxy=localhost,127.0.0.1,.internal,::1"
        "--label" "coding-agents.proxy-container=$PROXY_CONTAINER_NAME"
        "--label" "coding-agents.proxy-network=$PROXY_NETWORK_NAME"
        "--label" "coding-agents.proxy-image=$PROXY_IMAGE"
    )
fi

# Add optional agent configs
[ -d "${HOME}/.config/codex" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/codex:/home/agentuser/.config/codex:ro")
[ -d "${HOME}/.config/claude" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/claude:/home/agentuser/.config/claude:ro")
[ -f "${HOME}/.config/coding-agents/mcp-secrets.env" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/coding-agents/mcp-secrets.env:/home/agentuser/.mcp-secrets.env:ro")

# Start git credential proxy server on host if not already running
CREDENTIAL_SOCKET_PATH="${HOME}/.config/coding-agents/git-credential.sock"
CREDENTIAL_PROXY_SCRIPT="$SCRIPT_DIR/../runtime/git-credential-proxy-server.sh"

if [ ! -S "$CREDENTIAL_SOCKET_PATH" ]; then
    if [ -f "$CREDENTIAL_PROXY_SCRIPT" ]; then
        echo "üîê Starting git credential proxy server..."
        mkdir -p "$(dirname "$CREDENTIAL_SOCKET_PATH")"
        
        # Start proxy server in background with nohup
        nohup "$CREDENTIAL_PROXY_SCRIPT" "$CREDENTIAL_SOCKET_PATH" > /dev/null 2>&1 &
        PROXY_PID=$!
        
        # Wait for socket to be created (max 5 seconds)
        for i in {1..50}; do
            [ -S "$CREDENTIAL_SOCKET_PATH" ] && break
            sleep 0.1
        done
        
        if [ -S "$CREDENTIAL_SOCKET_PATH" ]; then
            echo "   ‚úÖ Credential proxy started (PID: $PROXY_PID)"
        else
            echo "   ‚ö†Ô∏è  Credential proxy started but socket not ready"
            echo "      Container will fall back to file-based credentials"
        fi
    else
        echo "‚ö†Ô∏è  Credential proxy script not found, using file-based credentials"
    fi
fi

# Start GPG proxy server on host if not already running and GPG signing is configured
GPG_SOCKET_PATH="${HOME}/.config/coding-agents/gpg-proxy.sock"
GPG_PROXY_SCRIPT="$SCRIPT_DIR/../runtime/gpg-proxy-server.sh"

if git config commit.gpgsign 2>/dev/null | grep -q "true"; then
    if [ ! -S "$GPG_SOCKET_PATH" ]; then
        if [ -f "$GPG_PROXY_SCRIPT" ]; then
            echo "üîè Starting GPG proxy server for commit signing..."
            mkdir -p "$(dirname "$GPG_SOCKET_PATH")"
            
            # Start GPG proxy server in background
            nohup "$GPG_PROXY_SCRIPT" "$GPG_SOCKET_PATH" > /dev/null 2>&1 &
            GPG_PROXY_PID=$!
            
            # Wait for socket to be created
            for i in {1..50}; do
                [ -S "$GPG_SOCKET_PATH" ] && break
                sleep 0.1
            done
            
            if [ -S "$GPG_SOCKET_PATH" ]; then
                echo "   ‚úÖ GPG proxy started (PID: $GPG_PROXY_PID)"
            else
                echo "   ‚ö†Ô∏è  GPG proxy started but socket not ready"
            fi
        fi
    fi
fi

# Mount credential proxy socket (most secure - no files in container)
if [ -S "$CREDENTIAL_SOCKET_PATH" ]; then
    DOCKER_ARGS+=("-v" "$CREDENTIAL_SOCKET_PATH:/tmp/git-credential-proxy.sock:ro")
    DOCKER_ARGS+=("-e" "CREDENTIAL_SOCKET=/tmp/git-credential-proxy.sock")
fi

# Mount GPG proxy socket (secure signing - private keys stay on host)
if [ -S "$GPG_SOCKET_PATH" ]; then
    DOCKER_ARGS+=("-v" "$GPG_SOCKET_PATH:/tmp/gpg-proxy.sock:ro")
    DOCKER_ARGS+=("-e" "GPG_PROXY_SOCKET=/tmp/gpg-proxy.sock")
fi

# Fallback: Mount credential files (read-only for security)
# These are only used if socket proxy is not available
[ -f "${HOME}/.git-credentials" ] && DOCKER_ARGS+=("-v" "${HOME}/.git-credentials:/home/agentuser/.git-credentials:ro")
[ -d "${HOME}/.ssh" ] && DOCKER_ARGS+=("-v" "${HOME}/.ssh:/home/agentuser/.ssh:ro")

# Mount GPG config for commit signing (read-only, no private keys)
# Only mount if GPG proxy socket not available (fallback to agent socket)
if [ -d "${HOME}/.gnupg" ] && [ ! -S "$GPG_SOCKET_PATH" ]; then
    # Mount GPG home directory read-only (contains config, public keys, not private keys)
    DOCKER_ARGS+=("-v" "${HOME}/.gnupg:/home/agentuser/.gnupg:ro")
    
    # Forward GPG agent socket if available (for direct signing without proxy)
    GPG_AGENT_SOCK="${HOME}/.gnupg/S.gpg-agent"
    if [ -S "$GPG_AGENT_SOCK" ]; then
        DOCKER_ARGS+=("-v" "$GPG_AGENT_SOCK:/home/agentuser/.gnupg/S.gpg-agent")
    fi
fi

# SSH agent socket forwarding (supports any SSH agent via standard SSH_AUTH_SOCK)
if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "$SSH_AUTH_SOCK" ]; then
    # Forward SSH agent socket to container
    DOCKER_ARGS+=("-v" "$SSH_AUTH_SOCK:/tmp/ssh-agent.sock:ro")
    DOCKER_ARGS+=("-e" "SSH_AUTH_SOCK=/tmp/ssh-agent.sock")
fi

# Final args
DOCKER_ARGS+=(
    "-w" "/workspace"
    "--network" "$NETWORK_MODE"
    "--security-opt" "no-new-privileges:true"
    "--cpus=$CPU"
    "--memory=$MEMORY"
)

# Add GPU if specified
if [ -n "$GPU" ]; then
    DOCKER_ARGS+=("--gpus=$GPU")
fi

DOCKER_ARGS+=("$IMAGE_NAME")

# Create container
echo "üì¶ Creating container..."
CONTAINER_ID=$(container_cli "${DOCKER_ARGS[@]}")

if [ $? -ne 0 ]; then
    echo "‚ùå Failed to create container"
    [ "$USE_SQUID" = true ] && container_cli rm -f "$PROXY_CONTAINER_NAME" >/dev/null 2>&1
    [ "$USE_SQUID" = true ] && container_cli network rm "$PROXY_NETWORK_NAME" >/dev/null 2>&1
    exit 1
fi

# Setup repository inside container
echo "üì• Setting up repository..."
SETUP_SCRIPT=$(generate_repo_setup_script "$SOURCE_TYPE" "$GIT_URL" "$WSL_PATH" "$ORIGIN_URL" "$AGENT_BRANCH")
echo "$SETUP_SCRIPT" | container_cli exec -i "$CONTAINER_NAME" bash

if [ $? -ne 0 ]; then
    echo "‚ùå Failed to setup repository"
    container_cli rm -f "$CONTAINER_NAME"
    exit 1
fi

if [ "$USE_SQUID" = true ]; then
    (
        container_cli wait "$CONTAINER_NAME" >/dev/null 2>&1 || true
        container_cli rm -f "$PROXY_CONTAINER_NAME" >/dev/null 2>&1 || true
        container_cli network rm "$PROXY_NETWORK_NAME" >/dev/null 2>&1 || true
    ) &
fi

echo ""
echo "‚úÖ Container '$CONTAINER_NAME' is ready!"
echo "üîó Attaching to agent session (detach with Ctrl+B, then D)..."
container_cli exec -it "$CONTAINER_NAME" agent-session attach
ATTACH_STATUS=$?

if [ $ATTACH_STATUS -ne 0 ]; then
    if container_cli ps --filter "name=^${CONTAINER_NAME}$" --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "‚ö†Ô∏è  Unable to attach. Re-run: $SCRIPT_DIR/connect-agent --name $CONTAINER_NAME"
    else
        echo "‚ùå Agent session exited before it was ready."
    fi
    exit $ATTACH_STATUS
fi

if container_cli ps --filter "name=^${CONTAINER_NAME}$" --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    echo ""
    echo "‚ÑπÔ∏è  Session detached but container is still running."
    echo "   Reconnect: $SCRIPT_DIR/connect-agent --name $CONTAINER_NAME"
    echo "   Stop later: $CONTAINER_CLI stop $CONTAINER_NAME"
else
    echo ""
    echo "‚úÖ Agent session complete. Container stopped."
fi

if [ "$SOURCE_TYPE" = "local" ] && [ "$NO_PUSH" != true ] && [ -n "$LOCAL_REMOTE_HOST_PATH" ]; then
    echo "üîÑ Syncing agent branch back to host repository..."
    sync_local_remote_to_host "$RESOLVED_PATH" "$LOCAL_REMOTE_HOST_PATH" "$AGENT_BRANCH"
fi
