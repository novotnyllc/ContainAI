#!/usr/bin/env bash
# Launch an ephemeral coding agent session that auto-attaches to the agent CLI
# Containers auto-clean on exit but keep all git safeguards and host mounts

set -e

# Source shared functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../utils/common-functions.sh"

print_run_agent_usage() {
        cat <<'EOF'
Usage: run-agent <agent> [SOURCE] [OPTIONS]

Agent types: copilot, codex, claude

SOURCE can be:
    ‚Ä¢ Local path to a git repository (default: current directory)
    ‚Ä¢ Git URL (https://...)

Options:
    -b, --branch BRANCH         Branch name (creates <agent>/<branch>)
    --name NAME                 Custom container name
    --dotnet-preview CHANNEL    Install .NET preview SDK (e.g., 11.0)
    --network-proxy MODE        Network proxy: allow-all, restricted, squid (default: allow-all)
    --cpu NUM                   CPU limit (default: 4)
    --memory SIZE               Memory limit (default: 8g)
    --gpu SPEC                  GPU specification (e.g., 'all' or 'device=0')
    --no-push                   Disable auto-push on container shutdown
    --use-current-branch        Use current branch instead of creating agent branch (unsafe)
    --prompt PROMPT             Prompt execution (reuses current repo when available)
    -y, --force                 Automatically replace existing agent branch without prompting
    -h, --help                  Show this help

Branch Behavior:
    ‚Ä¢ Without --branch: creates unique session branch <agent>/session-N
    ‚Ä¢ With --branch: creates <agent>/<branch>
    ‚Ä¢ Already on agent branch: reuses that branch
    ‚Ä¢ Use --use-current-branch to work directly on current branch
    ‚Ä¢ Existing agent branches prompt for replacement
    ‚Ä¢ Branches with unmerged commits are archived before replacement

Examples:
    run-agent copilot                              # Copilot in current directory
    run-agent codex . -b refactor-db               # Codex in current dir, custom branch
    run-agent copilot https://github.com/user/repo # Copilot from GitHub
    run-agent claude /path/to/repo --name my-workspace
    run-agent copilot . -b feature-api -y          # Auto-replace existing agent branch
EOF
}

REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
maybe_check_launcher_updates "$REPO_ROOT" "run-agent"

WANTS_HELP=false
for arg in "$@"; do
        case "$arg" in
                -h|--help)
                        WANTS_HELP=true
                        break
                        ;;
        esac
done

if $WANTS_HELP; then
        if [[ $# -eq 0 || "$1" == "-"* ]]; then
                print_run_agent_usage
                exit 0
        fi
        help_agent="$1"
        case "$help_agent" in
                copilot|codex|claude) ;;
                *)
                        echo "‚ùå Error: Invalid agent type '$help_agent'"
                        exit 1
                        ;;
        esac
        print_run_agent_usage
        exit 0
fi

if ! ensure_prerequisites_verified "$REPO_ROOT"; then
    exit 1
fi

if ! verify_host_security_prereqs "$REPO_ROOT"; then
    exit 1
fi

# Default values
AGENT=""
SOURCE="."
BRANCH=""
BRANCH_FROM_FLAG=false
NAME=""
DOTNET_PREVIEW=""
NETWORK_PROXY="allow-all"
CPU="4"
MEMORY="8g"
GPU=""
NO_PUSH=false
FORCE=false
USE_CURRENT_BRANCH=false
PROMPT_MODE=false
PROMPT_TEXT=""
SOURCE_SPECIFIED=false
SOURCE_TYPE=""
REPO_NAME=""
GIT_URL=""
WSL_PATH=""
LOCAL_REMOTE_HOST_PATH=""
LOCAL_REMOTE_WSL_PATH=""
LOCAL_REMOTE_URL=""
LOCAL_REPO_PATH_VALUE=""
TMPFS_LARGE_SIZE="${CODING_AGENTS_TMPFS_LARGE:-2g}"
TMPFS_SMALL_SIZE="${CODING_AGENTS_TMPFS_SMALL:-512m}"
SESSION_ARTIFACT_DIR=""
SESSION_CONFIG_OUTPUT=""
SESSION_MANIFEST_PATH=""
SESSION_CONFIG_SHA256=""
SESSION_CONFIG_SOURCE=""
SESSION_CONFIG_RENDERED=false
SESSION_ID_BASE=$(date -u +"%Y%m%dT%H%M%SZ")
SESSION_CONFIG_ROOT_IN_CONTAINER="/run/coding-agents"
DEFAULT_BROKER_STUBS=("github" "uno" "msftdocs" "playwright" "context7" "serena" "sequential-thinking" "fetch")
BROKER_STUBS=("${DEFAULT_BROKER_STUBS[@]}")
declare -A MCP_SECRET_VALUES=()
declare -A SESSION_STUB_SECRETS=()
LAUNCHER_HEAD_HASH=$(get_git_head_hash "$REPO_ROOT" 2>/dev/null || echo "")
TRUSTED_PATHS=("scripts/launchers" "scripts/runtime" "docker/profiles")
TRUSTED_TREE_HASHES_RAW=$(collect_trusted_tree_hashes "$REPO_ROOT" "${TRUSTED_PATHS[@]}")
TRUSTED_TREE_HASHES_ENV=$(printf '%s' "$TRUSTED_TREE_HASHES_RAW" | tr '\n' ',' | sed 's/,$//')
if [ -n "$LAUNCHER_HEAD_HASH" ]; then
    echo "üîí Launcher commit: $LAUNCHER_HEAD_HASH"
fi
if [ -n "$TRUSTED_TREE_HASHES_RAW" ]; then
    echo "   Trusted tree hashes:"
    while IFS= read -r entry; do
        [ -z "$entry" ] && continue
        echo "     ‚Ä¢ $entry"
    done <<< "$TRUSTED_TREE_HASHES_RAW"
fi

cleanup_run_agent_volumes() {
    local container_name="${CONTAINER_NAME:-}"
    if [ -z "$container_name" ]; then
        return 0
    fi

    if container_exists "$container_name" >/dev/null 2>&1; then
        return 0
    fi

    local suffix volume
    for suffix in workspace home toolcache; do
        volume=$(get_container_volume_name "$container_name" "$suffix")
        if container_cli volume inspect "$volume" >/dev/null 2>&1; then
            container_cli volume rm "$volume" >/dev/null 2>&1 || true
        fi
    done

    if [ -n "$SESSION_ARTIFACT_DIR" ] && [ -d "$SESSION_ARTIFACT_DIR" ]; then
        rm -rf "$SESSION_ARTIFACT_DIR"
    fi
}
trap cleanup_run_agent_volumes EXIT

trim_whitespace() {
    local value="$1"
    value="${value#${value%%[![:space:]]*}}"
    value="${value%${value##*[![:space:]]}}"
    printf '%s' "$value"
}

load_mcp_secret_values() {
    local -a candidates=()
    declare -A seen_map=()
    if [ -n "${CODING_AGENTS_MCP_SECRETS_FILE:-}" ]; then
        candidates+=("${CODING_AGENTS_MCP_SECRETS_FILE}")
    fi
    if [ -n "${MCP_SECRETS_FILE:-}" ]; then
        candidates+=("${MCP_SECRETS_FILE}")
    fi
    candidates+=("${HOME}/.config/coding-agents/mcp-secrets.env" "${HOME}/.mcp-secrets.env")
    local candidate resolved
    for candidate in "${candidates[@]}"; do
        [ -n "$candidate" ] || continue
        resolved=$(realpath "$candidate" 2>/dev/null || echo "$candidate")
        if [ -n "${seen_map[$resolved]:-}" ]; then
            continue
        fi
        seen_map["$resolved"]=1
        if [ ! -f "$candidate" ]; then
            continue
        fi
        while IFS= read -r line || [ -n "$line" ]; do
            line=$(trim_whitespace "$line")
            [ -n "$line" ] || continue
            [[ "$line" == \#* ]] && continue
            if [[ "$line" == export* ]]; then
                line="${line#export }"
                line=$(trim_whitespace "$line")
            fi
            if [[ "$line" != *=* ]]; then
                continue
            fi
            local name="${line%%=*}"
            local value="${line#*=}"
            name=$(trim_whitespace "$name")
            value=$(trim_whitespace "$value")
            [ -n "$name" ] || continue
            if [ -n "$value" ] && [[ ( "$value" == "\""*"\"" ) || ( "$value" == "'"*"'" ) ]]; then
                value="${value:1:${#value}-2}"
            fi
            if [ -z "${MCP_SECRET_VALUES[$name]+x}" ]; then
                MCP_SECRET_VALUES["$name"]="$value"
            fi
        done < "$candidate"
    done
}

resolve_secret_value() {
    local key="$1"
    if [ -z "$key" ]; then
        return 1
    fi
    if [ -n "${MCP_SECRET_VALUES[$key]:-}" ]; then
        printf '%s' "${MCP_SECRET_VALUES[$key]}"
        return 0
    fi
    if [ -n "${!key:-}" ]; then
        MCP_SECRET_VALUES["$key"]="${!key}"
        printf '%s' "${!key}"
        return 0
    fi
    return 1
}

parse_stub_secret_manifest() {
    local file="$1"
    [ -f "$file" ] || return 0
    while IFS= read -r line || [ -n "$line" ]; do
        line=${line%%#*}
        line=$(trim_whitespace "$line")
        [ -n "$line" ] || continue
        local stub="${line%% *}"
        local rest="${line#${stub}}"
        rest=$(trim_whitespace "$rest")
        [ -n "$stub" ] || continue
        [ -n "$rest" ] || continue
        SESSION_STUB_SECRETS["$stub"]="$rest"
    done < "$file"
}

store_stub_secrets() {
    local broker_script="$1"
    local stub
    for stub in "${!SESSION_STUB_SECRETS[@]}"; do
        local names="${SESSION_STUB_SECRETS[$stub]}"
        [ -n "$names" ] || continue
        local name
        for name in $names; do
            local value
            value=$(resolve_secret_value "$name") || value=""
            if [ -z "$value" ]; then
                echo "‚ö†Ô∏è  Missing secret '$name' for stub '$stub'" >&2
                continue
            fi
            if ! CODING_AGENTS_SECRET_VALUE="$value" run_python_tool "$broker_script" -- store --stub "$stub" --name "$name" --from-env CODING_AGENTS_SECRET_VALUE >/dev/null 2>&1; then
                echo "‚ùå Failed to store secret '$name' for stub '$stub'" >&2
                return 1
            fi
        done
    done
    return 0
}

seal_stub_capabilities() {
    local broker_script="$1"
    local cap_root="$2"
    local stub
    for stub in "${!SESSION_STUB_SECRETS[@]}"; do
        local names="${SESSION_STUB_SECRETS[$stub]}"
        [ -n "$names" ] || continue
        local cap_dir="$cap_root/$stub"
        if [ ! -d "$cap_dir" ]; then
            echo "‚ö†Ô∏è  Capability directory missing for stub '$stub'" >&2
            continue
        fi
        local cap_file
        cap_file=$(find "$cap_dir" -maxdepth 1 -name '*.json' | head -n1)
        if [ -z "$cap_file" ]; then
            echo "‚ö†Ô∏è  No capability token found for stub '$stub'" >&2
            continue
        fi
        local redeem_args=("--capability" "$cap_file")
        local name
        for name in $names; do
            redeem_args+=("--secret" "$name")
        done
        if ! run_python_tool "$broker_script" --mount "$cap_root" -- "redeem" "${redeem_args[@]}" >/dev/null 2>&1; then
            echo "‚ùå Failed to seal secrets for stub '$stub'" >&2
            return 1
        fi
    done
    return 0
}

run_prompt_session() {
    echo ""
    echo "üí° Running prompt session inside container"
    echo "   Prompt: $PROMPT_TEXT"

    local exec_cmd status=0
    case "$AGENT" in
        copilot)
            exec_cmd='github-copilot-cli exec "$PROMPT_INPUT"'
            ;;
        codex)
            exec_cmd='codex exec "$PROMPT_INPUT"'
            ;;
        claude)
            exec_cmd='claude -p "$PROMPT_INPUT"'
            ;;
        *)
            echo "‚ùå Prompt mode is not supported for agent '$AGENT'" >&2
            return 1
            ;;
    esac

    if container_cli exec -e PROMPT_INPUT="$PROMPT_TEXT" "$CONTAINER_NAME" bash -lc "$exec_cmd"; then
        status=0
        echo ""
        echo "‚úÖ Prompt session completed"
    else
        status=$?
        echo ""
        echo "‚ùå Prompt session failed inside container (exit $status)" >&2
    fi

    container_cli stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
    return $status
}

# First argument must be agent type
if [[ $# -eq 0 || "$1" == "-"* ]]; then
    echo "‚ùå Error: Agent type is required as first argument"
    echo "Usage: run-agent <agent> [SOURCE] [OPTIONS]"
    echo "Agent types: copilot, codex, claude"
    exit 1
fi

AGENT="$1"
shift

# Validate agent
case "$AGENT" in
    copilot|codex|claude) ;;
    *)
        echo "‚ùå Error: Invalid agent type '$AGENT'"
        echo "Valid options: copilot, codex, claude"
        exit 1
        ;;
esac

# Parse remaining arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--branch)
            BRANCH="$2"
            BRANCH_FROM_FLAG=true
            shift 2
            ;;
        --name)
            NAME="$2"
            shift 2
            ;;
        --dotnet-preview)
            DOTNET_PREVIEW="$2"
            shift 2
            ;;
        --network-proxy)
            NETWORK_PROXY="$2"
            shift 2
            ;;
        --cpu)
            CPU="$2"
            shift 2
            ;;
        --memory)
            MEMORY="$2"
            shift 2
            ;;
        --gpu)
            GPU="$2"
            shift 2
            ;;
        --no-push)
            NO_PUSH=true
            shift
            ;;
        --use-current-branch)
            USE_CURRENT_BRANCH=true
            shift
            ;;
        -y|--force)
            FORCE=true
            shift
            ;;
        --prompt)
            if [[ $# -lt 2 ]]; then
                echo "‚ùå Error: --prompt requires a prompt" >&2
                exit 1
            fi
            PROMPT_MODE=true
            PROMPT_TEXT="$2"
            shift 2
            ;;
        -h|--help)
            print_run_agent_usage
            exit 0
            ;;
        *)
            SOURCE="$1"
            SOURCE_SPECIFIED=true
            shift
            ;;
    esac
done

# Validate network proxy option
case "$NETWORK_PROXY" in
    allow-all|none|restricted|squid) ;;
    *)
        echo "‚ùå Error: Invalid --network-proxy value '$NETWORK_PROXY'"
        exit 1
        ;;
esac

# Treat 'none' as alias for allow-all
[ "$NETWORK_PROXY" = "none" ] && NETWORK_PROXY="allow-all"


if [ "$PROMPT_MODE" = true ]; then
    NO_PUSH=true
fi

# Check Docker
check_docker_running || exit 1
if ! verify_container_security_support; then
    exit 1
fi
CONTAINER_CLI=$(get_active_container_cmd)

# Determine if source is URL or local path
if [[ "$SOURCE" =~ ^https?:// ]]; then
    SOURCE_TYPE="url"
    REPO_NAME=$(basename "$SOURCE" .git)
    GIT_URL="$SOURCE"
    WSL_PATH=""
else
    if ! SOURCE=$(realpath "$SOURCE" 2>/dev/null); then
        echo "‚ùå Error: Source path does not exist: $SOURCE"
        exit 1
    fi

    # Auto-detect repo root when using default SOURCE
    if [ ! -d "$SOURCE/.git" ] && [ "$SOURCE_SPECIFIED" != true ]; then
        AUTO_ROOT=$(git -C "$SOURCE" rev-parse --show-toplevel 2>/dev/null || true)
        if [ -n "$AUTO_ROOT" ]; then
            SOURCE=$(realpath "$AUTO_ROOT" 2>/dev/null || echo "$AUTO_ROOT")
        fi
    fi

    if [ ! -d "$SOURCE/.git" ]; then
        if [ "$PROMPT_MODE" = true ]; then
            SOURCE_TYPE="prompt"
            REPO_NAME="prompt"
            SOURCE="prompt-only"
        else
            echo "‚ùå Error: $SOURCE is not a git repository"
            exit 1
        fi
    fi

    if [ "$SOURCE_TYPE" != "prompt" ]; then
        SOURCE_TYPE="local"
        REPO_NAME=$(basename "$SOURCE")
        cd "$SOURCE"
        cd - > /dev/null
        WSL_PATH=$(convert_to_wsl_path "$SOURCE")
        GIT_URL=""
        LOCAL_REPO_PATH_VALUE="$WSL_PATH"

        if [ "$NO_PUSH" != true ]; then
            REMOTE_HASH=$(printf "%s" "$SOURCE" | (command -v shasum >/dev/null 2>&1 && shasum -a 256 || sha256sum) | awk '{print $1}')
            REMOTE_HASH=${REMOTE_HASH:0:16}
            LOCAL_REMOTE_DIR="${CODING_AGENTS_LOCAL_REMOTES_DIR:-${HOME}/.coding-agents/local-remotes}"
            LOCAL_REMOTE_HOST_PATH="$LOCAL_REMOTE_DIR/${REMOTE_HASH}.git"
            mkdir -p "$LOCAL_REMOTE_DIR"
            if [ ! -d "$LOCAL_REMOTE_HOST_PATH" ]; then
                git init --bare "$LOCAL_REMOTE_HOST_PATH" >/dev/null
            fi
            LOCAL_REMOTE_WSL_PATH=$(convert_to_wsl_path "$LOCAL_REMOTE_HOST_PATH")
            LOCAL_REMOTE_URL="file:///tmp/local-remote"
            LOCAL_REPO_PATH_VALUE="$LOCAL_REMOTE_URL"
        fi

        if [ "$NO_PUSH" != true ] && [ -z "$LOCAL_REMOTE_URL" ]; then
            echo "‚ùå Failed to configure secure local remote for auto-push"
            exit 1
        fi
    fi
fi

if [ "$SOURCE_TYPE" = "prompt" ] && [ -z "$BRANCH" ]; then
    BRANCH="prompt-session"
fi

[ -n "$REPO_NAME" ] || REPO_NAME="prompt"

if [ -z "$SESSION_CONFIG_SOURCE" ] && [ "$SOURCE_TYPE" = "local" ] && [ -f "$SOURCE/config.toml" ]; then
    SESSION_CONFIG_SOURCE="$SOURCE/config.toml"
fi

if [ -z "$SESSION_CONFIG_SOURCE" ] && [ -f "${HOME}/.config/coding-agents/config.toml" ]; then
    SESSION_CONFIG_SOURCE="${HOME}/.config/coding-agents/config.toml"
fi

if [ "$USE_CURRENT_BRANCH" = "true" ]; then
    if [ "$SOURCE_TYPE" != "local" ]; then
        echo "‚ùå Error: --use-current-branch is only supported for local repositories"
        exit 1
    fi
    if [ "$BRANCH_FROM_FLAG" = "true" ]; then
        echo "‚ùå Error: --use-current-branch cannot be combined with --branch"
        exit 1
    fi
fi

# Restricted network cannot clone URLs
if [ "$NETWORK_PROXY" = "restricted" ] && [ "$SOURCE_TYPE" = "url" ]; then
    echo "‚ùå Restricted network mode cannot clone from a URL. Provide a local path or use --network-proxy allow-all."
    exit 1
fi

# Helper: Check if branch name follows agent naming convention
is_agent_branch() {
    local branch_name="$1"
    [[ "$branch_name" =~ ^(copilot|codex|claude)/ ]]
}

# Helper: Find next available session number
find_next_session() {
    local repo_path="$1"
    local agent="$2"
    local n=1
    cd "$repo_path"
    while git show-ref --verify --quiet "refs/heads/${agent}/session-${n}" 2>/dev/null; do
        ((n++))
    done
    cd - > /dev/null
    echo "$n"
}

# Determine branch name with safety checks
if [ -z "$BRANCH" ]; then
    if [ "$SOURCE_TYPE" = "local" ]; then
        cd "$SOURCE"
        CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        cd - > /dev/null
        
        # Safety: Never use current branch unless explicitly allowed and available
        if [ "$USE_CURRENT_BRANCH" = "true" ]; then
            if [ -z "$CURRENT_BRANCH" ]; then
                echo "‚ùå Error: Repository is in detached HEAD state; cannot use --use-current-branch"
                exit 1
            fi
            BRANCH="$CURRENT_BRANCH"
            echo "‚ö†Ô∏è  Warning: Using current branch directly (--use-current-branch specified)"
        elif is_agent_branch "$CURRENT_BRANCH"; then
            # Current branch is already an agent branch, safe to use
            BRANCH="$CURRENT_BRANCH"
            echo "‚úì Current branch '$CURRENT_BRANCH' is an agent branch"
        else
            # Generate unique session branch
            SESSION_NUM=$(find_next_session "$SOURCE" "$AGENT")
            BRANCH="session-${SESSION_NUM}"
            echo "‚ÑπÔ∏è  Creating new branch '${AGENT}/${BRANCH}' (current: ${CURRENT_BRANCH:-main})"
        fi
    else
        BRANCH="main"
    fi
fi

if ! validate_branch_name "$BRANCH"; then
    echo "‚ùå Error: Invalid branch name '$BRANCH'"
    echo "   Branch names must start with alphanumeric characters and avoid spaces"
    exit 1
fi

# Sanitize branch name for container naming
SAFE_BRANCH=$(echo "$BRANCH" | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')

# Determine container names
if [ -n "$NAME" ]; then
    if ! validate_container_name "$NAME"; then
        echo "‚ùå Error: Invalid custom name '$NAME'"
        echo "   Container names must start with alphanumeric characters and may include . _ -"
        exit 1
    fi
    CONTAINER_NAME="${AGENT}-${NAME}"
    WORKSPACE_NAME="$NAME"
else
    CONTAINER_NAME="${AGENT}-${REPO_NAME}-${SAFE_BRANCH}"
    WORKSPACE_NAME="$REPO_NAME"
fi

if ! validate_container_name "$CONTAINER_NAME"; then
    echo "‚ùå Error: Generated container name '$CONTAINER_NAME' is invalid"
    echo "   Adjust --name, repository, or branch to avoid spaces and special characters"
    exit 1
fi

SESSION_ARTIFACT_DIR=$(mktemp -d "${TMPDIR:-/tmp}/coding-agents-session.XXXXXXXX" 2>/dev/null || mktemp -d)
SESSION_CONFIG_OUTPUT="$SESSION_ARTIFACT_DIR/session-config"
mkdir -p "$SESSION_CONFIG_OUTPUT"
SESSION_ID="${CONTAINER_NAME}-${SESSION_ID_BASE}-${RANDOM}"

if [ -z "$WORKSPACE_VOLUME" ]; then
    WORKSPACE_VOLUME=$(get_container_volume_name "$CONTAINER_NAME" "workspace")
fi
if [ -z "$HOME_VOLUME" ]; then
    HOME_VOLUME=$(get_container_volume_name "$CONTAINER_NAME" "home")
fi
if [ -z "$TOOLCACHE_VOLUME" ]; then
    TOOLCACHE_VOLUME=$(get_container_volume_name "$CONTAINER_NAME" "toolcache")
fi

# Determine agent branch (handle case where BRANCH is already agent/branch format)
if [ "$USE_CURRENT_BRANCH" = "true" ]; then
    AGENT_BRANCH="$BRANCH"
elif is_agent_branch "$BRANCH"; then
    AGENT_BRANCH="$BRANCH"
else
    AGENT_BRANCH="${AGENT}/${BRANCH}"
fi

PROXY_CONTAINER_NAME="${CONTAINER_NAME}-proxy"
PROXY_NETWORK_NAME="${CONTAINER_NAME}-net"
PROXY_IMAGE="coding-agents-proxy:local"

# Pull latest image
pull_and_tag_image "$AGENT"
IMAGE_NAME="coding-agents-${AGENT}:local"

# Get timezone
TZ_VALUE="${TZ:-$(cat /etc/timezone 2>/dev/null || echo UTC)}"

# Squid allowed domains
SQUID_ALLOWED_DOMAINS="*.github.com,*.githubcopilot.com,*.nuget.org,*.npmjs.org,*.pypi.org,*.python.org,*.microsoft.com,*.docker.io,registry-1.docker.io,api.githubcopilot.com,learn.microsoft.com,platform.uno,*.githubusercontent.com,*.azureedge.net"

# Determine network mode
NETWORK_MODE="bridge"
NETWORK_POLICY_ENV="allow-all"
USE_SQUID=false
PROXY_URL=""

case "$NETWORK_PROXY" in
    restricted)
        NETWORK_MODE="none"
        NETWORK_POLICY_ENV="restricted"
        ;;
    squid)
        NETWORK_MODE="$PROXY_NETWORK_NAME"
        NETWORK_POLICY_ENV="squid"
        USE_SQUID=true
        PROXY_URL="http://${PROXY_CONTAINER_NAME}:3128"
        ;;
    *)
        NETWORK_POLICY_ENV="allow-all"
        ;;
esac

if [ "$USE_SQUID" = true ]; then
    pull_and_tag_image "proxy"
fi

RENDERER_SCRIPT="$REPO_ROOT/scripts/utils/render-session-config.py"
TRUSTED_HASH_ARGS=()
if [ -n "$TRUSTED_TREE_HASHES_RAW" ]; then
    while IFS= read -r entry; do
        [ -z "$entry" ] && continue
        TRUSTED_HASH_ARGS+=("--trusted-hash" "$entry")
    done <<< "$TRUSTED_TREE_HASHES_RAW"
fi

if [ -f "$RENDERER_SCRIPT" ]; then
    RENDER_ARGS=("--output" "$SESSION_CONFIG_OUTPUT" "--session-id" "$SESSION_ID" "--network-policy" "$NETWORK_POLICY_ENV" "--repo" "$REPO_NAME" "--agent" "$AGENT" "--container" "$CONTAINER_NAME")
    if [ -n "$SESSION_CONFIG_SOURCE" ]; then
        RENDER_ARGS+=("--config" "$SESSION_CONFIG_SOURCE")
    fi
    if [ -n "$LAUNCHER_HEAD_HASH" ]; then
        RENDER_ARGS+=("--git-head" "$LAUNCHER_HEAD_HASH")
    fi
    RENDER_ARGS+=("${TRUSTED_HASH_ARGS[@]}")
    RUNNER_MOUNTS=("--mount" "$SESSION_CONFIG_OUTPUT")
    if [ -n "$SESSION_CONFIG_SOURCE" ]; then
        RUNNER_MOUNTS+=("--mount" "$SESSION_CONFIG_SOURCE")
    fi
    if run_python_tool "$RENDERER_SCRIPT" "${RUNNER_MOUNTS[@]}" -- "${RENDER_ARGS[@]}" >/dev/null 2>&1; then
        SESSION_MANIFEST_PATH="$SESSION_CONFIG_OUTPUT/manifest.json"
        if [ -f "$SESSION_MANIFEST_PATH" ]; then
            if command -v shasum >/dev/null 2>&1; then
                SESSION_CONFIG_SHA256=$(shasum -a 256 "$SESSION_MANIFEST_PATH" | awk '{print $1}')
            elif command -v sha256sum >/dev/null 2>&1; then
                SESSION_CONFIG_SHA256=$(sha256sum "$SESSION_MANIFEST_PATH" | awk '{print $1}')
            else
                SESSION_CONFIG_SHA256=""
            fi
            SESSION_CONFIG_RENDERED=true
            echo "üîê Session MCP config manifest: ${SESSION_CONFIG_SHA256:-unknown}"
            log_session_config_manifest "$SESSION_ID" "${SESSION_CONFIG_SHA256:-}" "$REPO_ROOT" "$TRUSTED_TREE_HASHES_RAW"
            servers_file="$SESSION_CONFIG_OUTPUT/servers.txt"
            if [ -f "$servers_file" ]; then
                mapfile -t MANIFEST_STUBS < <(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' "$servers_file" | grep -v '^$')
                if [ ${#MANIFEST_STUBS[@]} -gt 0 ]; then
                    BROKER_STUBS=("${MANIFEST_STUBS[@]}")
                fi
            fi
            stub_secret_file="$SESSION_CONFIG_OUTPUT/stub-secrets.txt"
            if [ -f "$stub_secret_file" ]; then
                parse_stub_secret_manifest "$stub_secret_file"
            fi
        fi
    else
        echo "‚ö†Ô∏è  Failed to render session MCP config via python runner" >&2
    fi
else
    echo "‚ö†Ô∏è  Session config renderer missing at $RENDERER_SCRIPT" >&2
fi

if ! ensure_broker_ready; then
    echo "‚ùå Secret broker health check failed" >&2
    exit 1
fi

BROKER_SCRIPT=$(get_secret_broker_script)
if [ -z "$BROKER_SCRIPT" ]; then
    echo "‚ùå Secret broker script not found" >&2
    exit 1
fi

if [ ${#SESSION_STUB_SECRETS[@]} -gt 0 ]; then
    load_mcp_secret_values
    if ! store_stub_secrets "$BROKER_SCRIPT"; then
        echo "‚ùå Failed to stage broker-managed secrets" >&2
        exit 1
    fi
fi

BROKER_CAP_DIR="$SESSION_CONFIG_OUTPUT/capabilities"
mkdir -p "$BROKER_CAP_DIR"
export CODING_AGENTS_SESSION_CONFIG_SHA256="${SESSION_CONFIG_SHA256:-}"
if ! issue_session_capabilities "$SESSION_ID" "$BROKER_CAP_DIR" "${BROKER_STUBS[@]}"; then
    echo "‚ùå Failed to issue capability tokens" >&2
    exit 1
fi

if [ ${#SESSION_STUB_SECRETS[@]} -gt 0 ]; then
    if ! seal_stub_capabilities "$BROKER_SCRIPT" "$BROKER_CAP_DIR"; then
        echo "‚ùå Failed to seal stub secrets" >&2
        exit 1
    fi
fi

# Check for branch conflicts in local repos (only when creating isolated branches)
if [ "$SOURCE_TYPE" = "local" ] && [ "$USE_CURRENT_BRANCH" != "true" ]; then
    RESOLVED_PATH=$(realpath "$SOURCE")
    
    # Check if agent branch already exists
    if branch_exists "$RESOLVED_PATH" "$AGENT_BRANCH"; then
        echo "‚ö†Ô∏è  Branch '$AGENT_BRANCH' already exists in the repository"
        echo ""
        
        # Get current branch to check for unmerged commits
        cd "$RESOLVED_PATH"
        CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
        cd - > /dev/null
        
        # Check for unmerged commits
        UNMERGED_COMMITS=$(get_unmerged_commits "$RESOLVED_PATH" "$CURRENT_BRANCH" "$AGENT_BRANCH")
        
        if [ -n "$UNMERGED_COMMITS" ]; then
            echo "üìù Branch has unmerged commits:"
            echo "$UNMERGED_COMMITS" | head -5
            COMMIT_COUNT=$(echo "$UNMERGED_COMMITS" | wc -l)
            if [ "$COMMIT_COUNT" -gt 5 ]; then
                echo "   ... and $((COMMIT_COUNT - 5)) more"
            fi
            echo ""
            echo "   ‚ÑπÔ∏è  The branch will be archived before creating a new one."
            echo ""
        fi
        
        # Prompt for replacement unless force flag is set
        if [ "$FORCE" != "true" ]; then
            read -p "Replace existing branch? (y/N): " -n 1 -r REPLY
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "‚ùå Aborted. Use -y or --force to automatically replace."
                exit 1
            fi
        else
            echo "   üîÑ Force flag set - replacing automatically"
        fi
        
        # Archive or delete the branch
        if [ -n "$UNMERGED_COMMITS" ]; then
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            ARCHIVE_NAME="${AGENT_BRANCH}-archived-${TIMESTAMP}"
            echo "üì¶ Archiving to: $ARCHIVE_NAME"
            
            if rename_git_branch "$RESOLVED_PATH" "$AGENT_BRANCH" "$ARCHIVE_NAME"; then
                echo "   ‚úÖ Branch archived successfully"
            else
                echo "   ‚ùå Failed to archive branch"
                exit 1
            fi
        else
            echo "üóëÔ∏è  Removing existing branch (no unmerged commits)"
            if remove_git_branch "$RESOLVED_PATH" "$AGENT_BRANCH" "true"; then
                echo "   ‚úÖ Branch removed successfully"
            else
                echo "   ‚ùå Failed to remove branch"
                exit 1
            fi
        fi
        echo ""
    fi
fi

echo "üöÄ Launching Coding Agent..."
echo "üéØ Agent: $AGENT"
echo "üìÅ Source: $SOURCE ($SOURCE_TYPE)"
echo "üåø Branch: $AGENT_BRANCH"
echo "üè∑Ô∏è  Container: $CONTAINER_NAME"
echo "üê≥ Image: $IMAGE_NAME"
echo "üåê Network policy: $NETWORK_POLICY_ENV"
echo ""

# Check if container already exists
if container_exists "$CONTAINER_NAME"; then
    echo "üì¶ Container '$CONTAINER_NAME' already exists"
    STATE=$(get_container_status "$CONTAINER_NAME")
    
    # Handle existing proxy if squid mode
    if [ "$USE_SQUID" = true ]; then
        EXISTING_PROXY=$(container_cli inspect -f '{{ index .Config.Labels "coding-agents.proxy-container" }}' "$CONTAINER_NAME" 2>/dev/null || echo "$PROXY_CONTAINER_NAME")
        EXISTING_NETWORK=$(container_cli inspect -f '{{ index .Config.Labels "coding-agents.proxy-network" }}' "$CONTAINER_NAME" 2>/dev/null || echo "$PROXY_NETWORK_NAME")
        PROXY_CONTAINER_NAME="$EXISTING_PROXY"
        PROXY_NETWORK_NAME="$EXISTING_NETWORK"
        ensure_squid_proxy "$PROXY_NETWORK_NAME" "$PROXY_CONTAINER_NAME" "$PROXY_IMAGE" "$CONTAINER_NAME" "$SQUID_ALLOWED_DOMAINS"
    fi
    
    if [ "$STATE" = "running" ]; then
        echo "‚úÖ Container is already running"
        echo "   Connect via: $CONTAINER_CLI exec -it $CONTAINER_NAME bash"
        echo "   Or use VS Code Dev Containers extension"
        exit 0
    else
        echo "‚ñ∂Ô∏è  Starting existing container..."
        container_cli start "$CONTAINER_NAME"
        echo "‚úÖ Container started"
        exit 0
    fi
fi

# Setup squid proxy if needed
if [ "$USE_SQUID" = true ]; then
    ensure_squid_proxy "$PROXY_NETWORK_NAME" "$PROXY_CONTAINER_NAME" "$PROXY_IMAGE" "$CONTAINER_NAME" "$SQUID_ALLOWED_DOMAINS"
fi

# Build docker arguments
AUTO_PUSH_VALUE=$([ "$NO_PUSH" = true ] && echo "false" || echo "true")

DOCKER_ARGS=(
    "run" "-d" "--rm"
    "--name" "$CONTAINER_NAME"
    "--hostname" "$CONTAINER_NAME"
    "-e" "TZ=$TZ_VALUE"
    "-e" "SOURCE_TYPE=$SOURCE_TYPE"
    "-e" "REPO_NAME=$WORKSPACE_NAME"
    "-e" "AGENT_BRANCH=$AGENT_BRANCH"
    "-e" "NETWORK_POLICY=$NETWORK_POLICY_ENV"
    "-e" "AUTO_PUSH_ON_SHUTDOWN=$AUTO_PUSH_VALUE"
    "-e" "AGENT_SESSION_MODE=supervised"
    "-e" "AGENT_SESSION_NAME=agent"
    "-e" "HOST_SESSION_ID=$SESSION_ID"
    "-e" "HOST_SESSION_CONFIG_SHA256=$SESSION_CONFIG_SHA256"
    "-e" "HOST_TRUSTED_TREES=$TRUSTED_TREE_HASHES_ENV"
    "-e" "HOST_LAUNCHER_HEAD=$LAUNCHER_HEAD_HASH"
    "-e" "HOST_SESSION_CONFIG_ROOT=$SESSION_CONFIG_ROOT_IN_CONTAINER"
    "-e" "HOST_CAPABILITY_ROOT=${SESSION_CONFIG_ROOT_IN_CONTAINER}/capabilities"
    "--label" "coding-agents.type=agent"
    "--label" "coding-agents.agent=$AGENT"
    "--label" "coding-agents.repo=$REPO_NAME"
    "--label" "coding-agents.branch=$AGENT_BRANCH"
    "--label" "coding-agents.network-policy=$NETWORK_POLICY_ENV"
    "--label" "coding-agents.volume.workspace=$WORKSPACE_VOLUME"
    "--label" "coding-agents.volume.home=$HOME_VOLUME"
    "--label" "coding-agents.volume.toolcache=$TOOLCACHE_VOLUME"
    "-v" "${HOME}/.gitconfig:/home/agentuser/.gitconfig:ro"
    "-v" "${HOME}/.config/gh:/home/agentuser/.config/gh:ro"
    "-v" "${HOME}/.config/github-copilot:/home/agentuser/.config/github-copilot:ro"
)

DOCKER_ARGS+=(
    "--mount" "type=volume,src=${WORKSPACE_VOLUME},dst=/workspace"
    "--mount" "type=volume,src=${HOME_VOLUME},dst=/home/agentuser"
    "--mount" "type=volume,src=${TOOLCACHE_VOLUME},dst=/toolcache"
)

# Add source-specific vars
if [ "$SOURCE_TYPE" = "url" ]; then
    DOCKER_ARGS+=("-e" "GIT_URL=$GIT_URL")
elif [ "$SOURCE_TYPE" = "local" ]; then
    LOCAL_REPO_ENV_VALUE="${LOCAL_REPO_PATH_VALUE:-$WSL_PATH}"
    DOCKER_ARGS+=("-e" "LOCAL_REPO_PATH=$LOCAL_REPO_ENV_VALUE")
    DOCKER_ARGS+=("-v" "${WSL_PATH}:/tmp/source-repo:ro")
    DOCKER_ARGS+=("--label" "coding-agents.repo-path=$RESOLVED_PATH")
    if [ -n "${LOCAL_REMOTE_WSL_PATH:-}" ]; then
        DOCKER_ARGS+=("-e" "LOCAL_REMOTE_URL=${LOCAL_REMOTE_URL}")
        DOCKER_ARGS+=("-v" "${LOCAL_REMOTE_WSL_PATH}:/tmp/local-remote")
        DOCKER_ARGS+=("--label" "coding-agents.local-remote=$LOCAL_REMOTE_HOST_PATH")
    fi
elif [ "$SOURCE_TYPE" = "prompt" ]; then
    DOCKER_ARGS+=("-e" "PROMPT_ONLY_MODE=true")
else
    echo "‚ùå Internal error: unknown SOURCE_TYPE '$SOURCE_TYPE'" >&2
    exit 1
fi

[ -n "$DOTNET_PREVIEW" ] && DOCKER_ARGS+=("-e" "DOTNET_PREVIEW_CHANNEL=$DOTNET_PREVIEW")

# Add proxy environment if squid
if [ "$USE_SQUID" = true ]; then
    DOCKER_ARGS+=(
        "-e" "HTTP_PROXY=$PROXY_URL"
        "-e" "HTTPS_PROXY=$PROXY_URL"
        "-e" "http_proxy=$PROXY_URL"
        "-e" "https_proxy=$PROXY_URL"
        "-e" "NO_PROXY=localhost,127.0.0.1,.internal,::1"
        "-e" "no_proxy=localhost,127.0.0.1,.internal,::1"
        "--label" "coding-agents.proxy-container=$PROXY_CONTAINER_NAME"
        "--label" "coding-agents.proxy-network=$PROXY_NETWORK_NAME"
        "--label" "coding-agents.proxy-image=$PROXY_IMAGE"
    )
fi

# Add optional agent configs
[ -d "${HOME}/.config/codex" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/codex:/home/agentuser/.config/codex:ro")
[ -d "${HOME}/.config/claude" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/claude:/home/agentuser/.config/claude:ro")
[ -f "${HOME}/.config/coding-agents/mcp-secrets.env" ] && DOCKER_ARGS+=("-v" "${HOME}/.config/coding-agents/mcp-secrets.env:/home/agentuser/.mcp-secrets.env:ro")

TMPFS_MOUNTS=(
    "/tmp:rw,nosuid,nodev,size=${TMPFS_LARGE_SIZE},mode=1777"
    "/var/tmp:rw,nosuid,nodev,size=${TMPFS_LARGE_SIZE},mode=1777"
    "/run:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/log:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/lib/apt:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/lib/apt/lists:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/cache/apt:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/cache/debconf:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "/var/lib/dpkg:rw,nosuid,nodev,size=${TMPFS_SMALL_SIZE},mode=755"
    "${SESSION_CONFIG_ROOT_IN_CONTAINER}:rw,nosuid,nodev,noexec,mode=750"
)

for tmpfs_mount in "${TMPFS_MOUNTS[@]}"; do
    DOCKER_ARGS+=("--tmpfs" "$tmpfs_mount")
done

# Start git credential proxy server on host if not already running
CREDENTIAL_SOCKET_PATH="${HOME}/.config/coding-agents/git-credential.sock"
CREDENTIAL_PROXY_SCRIPT="$SCRIPT_DIR/../runtime/git-credential-proxy-server.sh"

if [ ! -S "$CREDENTIAL_SOCKET_PATH" ]; then
    if [ -f "$CREDENTIAL_PROXY_SCRIPT" ]; then
        echo "üîê Starting git credential proxy server..."
        mkdir -p "$(dirname "$CREDENTIAL_SOCKET_PATH")"
        
        # Start proxy server in background with nohup
        nohup "$CREDENTIAL_PROXY_SCRIPT" "$CREDENTIAL_SOCKET_PATH" > /dev/null 2>&1 &
        PROXY_PID=$!
        
        # Wait for socket to be created (max 5 seconds)
        for i in {1..50}; do
            [ -S "$CREDENTIAL_SOCKET_PATH" ] && break
            sleep 0.1
        done
        
        if [ -S "$CREDENTIAL_SOCKET_PATH" ]; then
            echo "   ‚úÖ Credential proxy started (PID: $PROXY_PID)"
        else
            echo "   ‚ö†Ô∏è  Credential proxy started but socket not ready"
            echo "      Container will fall back to file-based credentials"
        fi
    else
        echo "‚ö†Ô∏è  Credential proxy script not found, using file-based credentials"
    fi
fi

# Start GPG proxy server on host if not already running and GPG signing is configured
GPG_SOCKET_PATH="${HOME}/.config/coding-agents/gpg-proxy.sock"
GPG_PROXY_SCRIPT="$SCRIPT_DIR/../runtime/gpg-proxy-server.sh"
GPG_SIGNING_ENABLED=false

if git config commit.gpgsign 2>/dev/null | grep -q "true"; then
    GPG_SIGNING_ENABLED=true
    if [ ! -S "$GPG_SOCKET_PATH" ]; then
        if [ -f "$GPG_PROXY_SCRIPT" ]; then
            echo "üîè Starting GPG proxy server for commit signing..."
            mkdir -p "$(dirname "$GPG_SOCKET_PATH")"
            
            # Start GPG proxy server in background
            nohup "$GPG_PROXY_SCRIPT" "$GPG_SOCKET_PATH" > /dev/null 2>&1 &
            GPG_PROXY_PID=$!
            
            # Wait for socket to be created
            for i in {1..50}; do
                [ -S "$GPG_SOCKET_PATH" ] && break
                sleep 0.1
            done
            
            if [ -S "$GPG_SOCKET_PATH" ]; then
                echo "   ‚úÖ GPG proxy started (PID: $GPG_PROXY_PID)"
            else
                echo "   ‚ö†Ô∏è  GPG proxy started but socket not ready"
            fi
        fi
    fi
fi

# Mount credential proxy socket (most secure - no files in container)
if [ -S "$CREDENTIAL_SOCKET_PATH" ]; then
    DOCKER_ARGS+=("-v" "$CREDENTIAL_SOCKET_PATH:/tmp/git-credential-proxy.sock:ro")
    DOCKER_ARGS+=("-e" "CREDENTIAL_SOCKET=/tmp/git-credential-proxy.sock")
fi

# Mount GPG proxy socket (secure signing - private keys stay on host)
if [ -S "$GPG_SOCKET_PATH" ]; then
    DOCKER_ARGS+=("-v" "$GPG_SOCKET_PATH:/tmp/gpg-proxy.sock:ro")
    DOCKER_ARGS+=("-e" "GPG_PROXY_SOCKET=/tmp/gpg-proxy.sock")
fi

# Fallback: Mount credential files (read-only for security)
# These are only used if socket proxy is not available
[ -f "${HOME}/.git-credentials" ] && DOCKER_ARGS+=("-v" "${HOME}/.git-credentials:/home/agentuser/.git-credentials:ro")

# SSH agent socket forwarding (supports any SSH agent via standard SSH_AUTH_SOCK)
SSH_AGENT_SOCKET_MOUNTED=false
if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "$SSH_AUTH_SOCK" ]; then
    # Forward SSH agent socket to container
    DOCKER_ARGS+=("-v" "$SSH_AUTH_SOCK:/tmp/ssh-agent.sock:ro")
    DOCKER_ARGS+=("-e" "SSH_AUTH_SOCK=/tmp/ssh-agent.sock")
    SSH_AGENT_SOCKET_MOUNTED=true
fi

if [ "$SSH_AGENT_SOCKET_MOUNTED" = false ] && [ -d "${HOME}/.ssh" ]; then
    echo "‚ö†Ô∏è  SSH agent socket not available; host SSH keys will not be forwarded. Start ssh-agent before running run-agent."
fi

if [ "$GPG_SIGNING_ENABLED" = true ] && [ ! -S "$GPG_SOCKET_PATH" ]; then
    echo "‚ö†Ô∏è  Commit signing is enabled but gpg-proxy socket was not created. Signing will be disabled; run gpg-proxy-server.sh or disable commit.gpgsign."
fi

SECCOMP_PROFILE_PATH=""
if [ "${CODING_AGENTS_DISABLE_SECCOMP:-0}" != "1" ]; then
    if ! SECCOMP_PROFILE_PATH=$(resolve_seccomp_profile_path "$REPO_ROOT"); then
        echo "‚ùå Unable to locate seccomp profile. Set CODING_AGENTS_SECCOMP_PROFILE to a valid file or export CODING_AGENTS_DISABLE_SECCOMP=1 to bypass (not recommended)."
        exit 1
    fi
else
    echo "‚ö†Ô∏è  Seccomp enforcement disabled via CODING_AGENTS_DISABLE_SECCOMP=1" >&2
fi

APPARMOR_PROFILE_NAME=""
if APPARMOR_PROFILE_NAME=$(resolve_apparmor_profile_name "$REPO_ROOT"); then
    :
else
    APPARMOR_PROFILE_NAME=""
fi

# Final args
DOCKER_ARGS+=(
    "-w" "/workspace"
    "--network" "$NETWORK_MODE"
    "--read-only"
    "--cap-drop=ALL"
    "--security-opt" "no-new-privileges:true"
    "--pids-limit=4096"
    "--cpus=$CPU"
    "--memory=$MEMORY"
    "--memory-swap=$MEMORY"
)

if [ -n "$SECCOMP_PROFILE_PATH" ]; then
    DOCKER_ARGS+=("--security-opt" "seccomp=$SECCOMP_PROFILE_PATH")
fi

if [ -n "$APPARMOR_PROFILE_NAME" ]; then
    DOCKER_ARGS+=("--security-opt" "apparmor=$APPARMOR_PROFILE_NAME")
fi

# Add GPU if specified
if [ -n "$GPU" ]; then
    DOCKER_ARGS+=("--gpus=$GPU")
fi

if [ -n "${CODING_AGENTS_EXTRA_DOCKER_ARGS:-}" ]; then
    # shellcheck disable=SC2206
    EXTRA_DOCKER_ARGS=(${CODING_AGENTS_EXTRA_DOCKER_ARGS})
    DOCKER_ARGS+=("${EXTRA_DOCKER_ARGS[@]}")
fi

DOCKER_ARGS+=("$IMAGE_NAME")

# Create container
echo "üì¶ Creating container..."
CONTAINER_ID=$(container_cli "${DOCKER_ARGS[@]}")

if [ $? -ne 0 ]; then
    echo "‚ùå Failed to create container"
    [ "$USE_SQUID" = true ] && container_cli rm -f "$PROXY_CONTAINER_NAME" >/dev/null 2>&1
    [ "$USE_SQUID" = true ] && container_cli network rm "$PROXY_NETWORK_NAME" >/dev/null 2>&1
    exit 1
fi

if [ "$SESSION_CONFIG_RENDERED" = true ] && [ -d "$SESSION_CONFIG_OUTPUT" ]; then
    if ! container_cli exec "$CONTAINER_NAME" mkdir -p "$SESSION_CONFIG_ROOT_IN_CONTAINER" >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  Failed to prepare session config directory inside container" >&2
    else
        container_cli cp "$SESSION_CONFIG_OUTPUT/." "$CONTAINER_NAME:$SESSION_CONFIG_ROOT_IN_CONTAINER" >/dev/null 2>&1 || \
            echo "‚ö†Ô∏è  Unable to copy session configs into container" >&2
    fi
fi

# Setup repository inside container
echo "üì• Setting up repository..."
SETUP_SCRIPT=$(generate_repo_setup_script "$SOURCE_TYPE" "$GIT_URL" "$WSL_PATH" "$AGENT_BRANCH")
echo "$SETUP_SCRIPT" | container_cli exec -i "$CONTAINER_NAME" bash

if [ $? -ne 0 ]; then
    echo "‚ùå Failed to setup repository"
    container_cli rm -f "$CONTAINER_NAME"
    exit 1
fi

if [ "$SOURCE_TYPE" = "local" ] && [ "$NO_PUSH" != true ] && [ -n "$LOCAL_REMOTE_HOST_PATH" ] && [ "${CODING_AGENTS_DISABLE_AUTO_SYNC:-0}" != "1" ]; then
    SYNC_SCRIPT="$REPO_ROOT/scripts/runtime/sync-local-remote.sh"
    if [ -x "$SYNC_SCRIPT" ]; then
        mkdir -p "${HOME}/.coding-agents/logs"
        LOG_FILE="${HOME}/.coding-agents/logs/${CONTAINER_NAME}-sync.log"
        "$SYNC_SCRIPT" \
            --bare "$LOCAL_REMOTE_HOST_PATH" \
            --repo "$RESOLVED_PATH" \
            --branch "$AGENT_BRANCH" \
            --container "$CONTAINER_NAME" \
            >>"$LOG_FILE" 2>&1 &
    fi
fi

if [ "$USE_SQUID" = true ]; then
    (
        container_cli wait "$CONTAINER_NAME" >/dev/null 2>&1 || true
        container_cli rm -f "$PROXY_CONTAINER_NAME" >/dev/null 2>&1 || true
        container_cli network rm "$PROXY_NETWORK_NAME" >/dev/null 2>&1 || true
    ) &
fi

echo ""
echo "‚úÖ Container '$CONTAINER_NAME' is ready!"
if [ "$PROMPT_MODE" = true ]; then
    run_prompt_session
    exit $?
fi

echo "üîó Attaching to agent session (detach with Ctrl+B, then D)..."
container_cli exec -it "$CONTAINER_NAME" agent-session attach
ATTACH_STATUS=$?

if [ $ATTACH_STATUS -ne 0 ]; then
    if container_cli ps --filter "name=^${CONTAINER_NAME}$" --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "‚ö†Ô∏è  Unable to attach. Re-run: $SCRIPT_DIR/connect-agent --name $CONTAINER_NAME"
    else
        echo "‚ùå Agent session exited before it was ready."
    fi
    exit $ATTACH_STATUS
fi

if container_cli ps --filter "name=^${CONTAINER_NAME}$" --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    echo ""
    echo "‚ÑπÔ∏è  Session detached but container is still running."
    echo "   Reconnect: $SCRIPT_DIR/connect-agent --name $CONTAINER_NAME"
    echo "   Stop later: $CONTAINER_CLI stop $CONTAINER_NAME"
else
    echo ""
    echo "‚úÖ Agent session complete. Container stopped."
fi

if [ "$SOURCE_TYPE" = "local" ] && [ "$NO_PUSH" != true ] && [ -n "$LOCAL_REMOTE_HOST_PATH" ]; then
    echo "üîÑ Syncing agent branch back to host repository..."
    sync_local_remote_to_host "$RESOLVED_PATH" "$LOCAL_REMOTE_HOST_PATH" "$AGENT_BRANCH"
fi
