#!/usr/bin/env sh
set -eu

clear_containai_env() {
    for name in $(env | sed -n 's/^\(CONTAINAI_[^=]*\)=.*/\1/p'); do
        unset "$name"
    done
}
clear_containai_env

SQUID_CONF=${SQUID_CONF:-/etc/squid/squid.conf}
SQUID_CACHE_DIR=${SQUID_CACHE_DIR:-/var/spool/squid}
SQUID_LOG_DIR=${SQUID_LOG_DIR:-/var/log/squid}
SQUID_SSL_DB_DIR=${SQUID_SSL_DB_DIR:-/var/spool/squid/ssl_db}
# Runtime config files go in /var/run/squid (tmpfs) for read-only root filesystem support
SQUID_RUN_DIR=${SQUID_RUN_DIR:-/var/run/squid}
ALLOWED_DOMAINS_FILE="$SQUID_RUN_DIR/allowed-domains.txt"
# Helper ACLs may be bind-mounted to /etc/squid/helper-acls.conf, will be copied to runtime dir
HELPER_ACLS_SOURCE=${SQUID_HELPER_ACLS_FILE:-/etc/squid/helper-acls.conf}
HELPER_ACLS_FILE="$SQUID_RUN_DIR/helper-acls.conf"
AGENT_HEADERS_FILE="$SQUID_RUN_DIR/agent-headers.conf"
# Source CA files - may be bind-mounted with restricted permissions
MITM_CA_CERT_SOURCE=${SQUID_MITM_CA_CERT:-/etc/squid/mitm/ca.crt}
MITM_CA_KEY_SOURCE=${SQUID_MITM_CA_KEY:-/etc/squid/mitm/ca.key}
# Runtime CA files - copied to tmpfs with correct permissions for proxy user
MITM_CA_CERT="$SQUID_RUN_DIR/mitm-ca.crt"
MITM_CA_KEY="$SQUID_RUN_DIR/mitm-ca.key"

# Ensure runtime directories exist FIRST before any file operations
# Note: CAP_DAC_OVERRIDE is dropped, so root cannot write to directories owned by others.
# We must create/copy files AS ROOT before chowning directories to proxy.
mkdir -p "$SQUID_CACHE_DIR" "$SQUID_LOG_DIR" "$SQUID_RUN_DIR" "$(dirname "$SQUID_SSL_DB_DIR")"

# Copy MITM CA files from bind mount to runtime dir
# The CA MUST be provided by the launcher - generating here would break trust chain
# (agent wouldn't have the matching cert to trust the proxy's MITM certificates)
if [ ! -f "$MITM_CA_CERT_SOURCE" ] || [ ! -f "$MITM_CA_KEY_SOURCE" ]; then
    echo "‚ùå MITM CA files not provided!" >&2
    echo "   Expected cert: $MITM_CA_CERT_SOURCE" >&2
    echo "   Expected key:  $MITM_CA_KEY_SOURCE" >&2
    echo "   The launcher must generate and bind-mount these files." >&2
    exit 1
fi
cp "$MITM_CA_CERT_SOURCE" "$MITM_CA_CERT"
cp "$MITM_CA_KEY_SOURCE" "$MITM_CA_KEY"
chmod 644 "$MITM_CA_CERT"
# Key is 640, owned by root:proxy - readable by root (for validation) and proxy group (for squid)
chown root:proxy "$MITM_CA_KEY" 2>/dev/null || true
chmod 640 "$MITM_CA_KEY"
echo "‚úÖ MITM CA copied to runtime directory"

# Generate allowed domains file from environment variable
if [ -n "${SQUID_ALLOWED_DOMAINS:-}" ]; then
    echo "üåê Configuring allowed domains for Squid proxy..."
    # Process domains: split by comma, remove empty lines
    # Note: grep -v returns exit code 1 if no matches, which would fail in set -e mode
    # So we use || true to ignore that case (which shouldn't happen with valid input)
    printf '%s\n' "$SQUID_ALLOWED_DOMAINS" | tr ',' '\n' | grep -v '^[[:space:]]*$' > "$ALLOWED_DOMAINS_FILE" || true
    # Verify we got at least one domain
    if [ ! -s "$ALLOWED_DOMAINS_FILE" ]; then
        echo "‚ö†Ô∏è  SQUID_ALLOWED_DOMAINS produced no valid domains, defaulting to allow all" >&2
        echo "." > "$ALLOWED_DOMAINS_FILE"
    fi
    echo "‚úÖ Allowed domains configured: $(wc -l < "$ALLOWED_DOMAINS_FILE") domains"
else
    echo "‚ö†Ô∏è  No SQUID_ALLOWED_DOMAINS set - defaulting to allow all"
    echo "." > "$ALLOWED_DOMAINS_FILE"
fi

# Copy or create helper ACL file in runtime directory
# If a bind-mounted source exists, copy it; otherwise create default
if [ -f "$HELPER_ACLS_SOURCE" ]; then
    cp "$HELPER_ACLS_SOURCE" "$HELPER_ACLS_FILE"
else
    cat > "$HELPER_ACLS_FILE" <<'EOF'
# default helper ACLs - allow any helper header using allowed-domains list
acl helper_default req_header X-CA-Helper .
acl helper_default_domains dstdomain "/var/run/squid/allowed-domains.txt"
http_access allow helper_default helper_default_domains
EOF
fi

# Generate agent headers to stamp outbound requests (agent/session)
cat > "$AGENT_HEADERS_FILE" <<EOF
# Auto-generated by entrypoint.sh
request_header_add X-CA-Agent ${CA_AGENT_ID:-unknown} all
request_header_add X-CA-Session ${CA_SESSION_ID:-unknown} all
EOF

# Initialize ssl_crtd cache
if [ ! -d "$SQUID_SSL_DB_DIR" ] || [ -z "$(ls -A "$SQUID_SSL_DB_DIR" 2>/dev/null)" ]; then
    echo "üîê Initializing ssl_crtd cache at $SQUID_SSL_DB_DIR..."
    # Remove the directory if it exists but is empty
    rm -rf "$SQUID_SSL_DB_DIR" 2>/dev/null || true
    # Create the ssl_db structure manually instead of using security_file_certgen
    # This avoids potential hangs in container environments (DinD, entropy issues)
    # The structure is: ssl_db/{certs/, index.txt, size}
    mkdir -p "$SQUID_SSL_DB_DIR/certs"
    touch "$SQUID_SSL_DB_DIR/index.txt"
    echo "0" > "$SQUID_SSL_DB_DIR/size"
    chown -R proxy:proxy "$SQUID_SSL_DB_DIR" 2>/dev/null || true
    echo "‚úÖ ssl_crtd cache initialized"
fi

# Initialize cache only if cache is enabled in config (not when "cache deny all" is set)
# Skip cache initialization for the MITM proxy - we use "cache deny all" anyway
# This avoids issues with squid -z in container environments
if grep -q '^cache deny all' "$SQUID_CONF" 2>/dev/null; then
    echo "‚ÑπÔ∏è  Cache disabled in config - skipping cache directory initialization"
elif [ ! -f "$SQUID_CACHE_DIR/00/00000000" ]; then
    echo "üß± Initializing Squid cache directories..."
    /usr/sbin/squid -z -f "$SQUID_CONF"
    # squid -z might leave a pid file, remove it to avoid "Squid is already running" error
    rm -f /run/squid.pid
fi

# Ensure proxy user can write to stderr (for cache.log)
# Note: This may fail in some container environments (e.g., DinD) - ignore errors
if [ -e /dev/stderr ]; then
    chown proxy:proxy /dev/stderr 2>/dev/null || true
fi

# NOW that all files are written, chown runtime directories to proxy user
# This must be AFTER all file writes since we dropped CAP_DAC_OVERRIDE
# Note: We don't chown the MITM key - it stays root:proxy with mode 640
chown -hR proxy:proxy "$SQUID_CACHE_DIR" "$SQUID_LOG_DIR" 2>/dev/null || true
# For SQUID_RUN_DIR, chown everything EXCEPT the key
find "$SQUID_RUN_DIR" -mindepth 1 ! -name 'mitm-ca.key' -exec chown proxy:proxy {} \; 2>/dev/null || true

# Validate config before starting
echo "üîç Validating Squid configuration..."
if ! /usr/sbin/squid -k parse -f "$SQUID_CONF" 2>&1; then
    echo "‚ùå Squid configuration validation failed" >&2
    exit 1
fi
echo "‚úÖ Configuration validated"

# Start Squid in foreground so docker can manage lifecycle
echo "üõ°Ô∏è  Starting Squid proxy (listening on 3128)..."
exec /usr/sbin/squid -N -f "$SQUID_CONF"
