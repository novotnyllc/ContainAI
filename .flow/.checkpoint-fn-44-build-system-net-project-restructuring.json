{
  "created_at": "2026-02-02T18:26:57.461787Z",
  "epic": {
    "data": {
      "branch_name": "fn-44-build-system-net-project-restructuring",
      "completion_review_status": "unknown",
      "completion_reviewed_at": null,
      "created_at": "2026-02-02T15:08:49.661617Z",
      "default_impl": null,
      "default_review": null,
      "default_sync": null,
      "depends_on_epics": [],
      "id": "fn-44-build-system-net-project-restructuring",
      "next_task": 1,
      "plan_review_status": "unknown",
      "plan_reviewed_at": null,
      "spec_path": ".flow/specs/fn-44-build-system-net-project-restructuring.md",
      "status": "open",
      "title": "Build System & .NET Project Restructuring",
      "updated_at": "2026-02-02T15:44:17.043738Z"
    },
    "spec": "# Build System & .NET Project Restructuring\n\n## Overview\n\nFix failing Docker builds, improve local build experience, modernize the .NET project structure, establish unified NBGV versioning, and create a proper release/packaging system that doesn't require repo clones.\n\n**Problems being solved:**\n1. Build fails looking for `docker.io/containai/base:latest` (incorrect default prefix)\n2. Local builds (build.sh) check local images, but `cai update` always pulls\n3. Single monolithic Program.cs (1029 lines) is an anti-pattern\n4. No version management (hardcoded `0.1.0`)\n5. No central package management\n6. Traditional .sln format instead of modern slnx\n7. E2E tests don't run in CI (sysbox not installed)\n8. Install requires repo clone (fragile, heavy)\n9. PR builds can't test install flow (no PR-specific artifact location)\n10. No .NET unit tests\n\n## Scope\n\n**In scope:**\n- Fix Docker image prefix/registry defaults in build.sh\n- Add local image check to `cai update` (not just build.sh)\n- Restructure .NET code into ACP library + CLI projects\n- Use NuGet packages instead of re-inventing (CliWrap, etc.)\n- Add xUnit 3 unit tests for .NET code\n- Add NBGV for unified versioning (all builds - .NET, Docker, shell)\n- Add Central Package Management (Directory.Packages.props)\n- Migrate to slnx solution format\n- Enable ArtifactsOutput for cleaner build paths\n- Run install.sh in GitHub Actions to install/configure sysbox\n- Create flat release tarballs per architecture (runtime only)\n- install.sh works both as standalone wget AND from inside tarball\n- PR builds publish to PR-specific artifact location for testing\n- Ensure all tests run including e2e\n\n**Out of scope:**\n- Publishing ACP library to NuGet (future work)\n- New ACP features\n- Docker image size optimization\n- Documentation epic (separate epic, follows this one)\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"GitHub Actions CI\"\n        A[Push/PR] --> B[NBGV: Set version env vars]\n        B --> C[Build acp-proxy multi-arch]\n        C --> C2[Run dotnet test xUnit]\n        C2 --> D[Create release tarball per arch]\n        D --> E{PR or Release?}\n        E -->|PR| F[Upload to PR artifacts]\n        E -->|Release| G[Publish tarball + install.sh to Releases]\n        F --> H[\"Extract, run ./install.sh --local\"]\n        G --> H\n        H --> I[Run all tests including E2E]\n    end\n\n    subgraph \"User Install - Path A (curl)\"\n        J[\"curl install.sh | bash\"] --> K[install.sh detects arch]\n        K --> L[Download tarball from Releases]\n        L --> M[Extract and install]\n    end\n\n    subgraph \"User Install - Path B (manual)\"\n        N[Download tarball manually] --> O[tar xzf ...]\n        O --> P[cd containai-*/]\n        P --> Q[\"./install.sh --local\"]\n    end\n\n    subgraph \"Local Dev / cai update\"\n        R[build.sh or cai update] --> S{Local image exists?}\n        S -->|Yes| T[Use local]\n        S -->|No| U{Registry pull works?}\n        U -->|Yes| V[Use pulled]\n        U -->|No| W[Build from scratch]\n    end\n```\n\n## Release Structure\n\n**install.sh** - Dual-mode script:\n```bash\n# Path A: Standalone (downloads tarball)\ncurl -fsSL https://github.com/.../releases/latest/download/install.sh | bash\n\n# Path B: From extracted tarball\ntar xzf containai-0.2.0-linux-x64.tar.gz\ncd containai-0.2.0-linux-x64\n./install.sh --local   # or just ./install.sh (auto-detects)\n```\n\n**Per-architecture tarballs** - Runtime only (e.g., `containai-0.2.0-linux-x64.tar.gz`):\n```\ncontainai-0.2.0-linux-x64/\n\u251c\u2500\u2500 containai.sh            # Main CLI entry point\n\u251c\u2500\u2500 lib/                    # Shell libraries\n\u251c\u2500\u2500 templates/              # User templates\n\u251c\u2500\u2500 acp-proxy               # Pre-built AOT binary\n\u251c\u2500\u2500 install.sh              # Same script, works locally too\n\u251c\u2500\u2500 VERSION                 # Version file\n\u2514\u2500\u2500 LICENSE\n```\n\n**What's NOT in the tarball:**\n- Dockerfiles (contributors clone repo)\n- Tests (contributors clone repo)\n- Build scripts (contributors clone repo)\n- Documentation (published separately)\n\n## .NET Project Structure\n\n```\nsrc/\n\u251c\u2500\u2500 ContainAI.Acp/              # Library (publishable)\n\u2502   \u251c\u2500\u2500 Protocol/               # JSON-RPC types\n\u2502   \u251c\u2500\u2500 Sessions/               # Session management (uses CliWrap)\n\u2502   \u2514\u2500\u2500 PathTranslation/        # Path mapping\n\u2514\u2500\u2500 acp-proxy/                  # CLI (AOT executable)\n\ntests/\n\u2514\u2500\u2500 ContainAI.Acp.Tests/        # xUnit 3 tests\n```\n\n**NuGet packages to use** (don't reinvent):\n- `StreamJsonRpc` - JSON-RPC protocol handling\n- `CliWrap` - Process execution\n- `xunit.v3` - Testing (VSTest v2 native)\n- `Nerdbank.GitVersioning` - Versioning\n- `Microsoft.SourceLink.GitHub` - Source linking\n\n## NBGV Version Strategy\n\nNBGV sets environment variables that ALL build steps can use:\n\n| Variable | Example | Used By |\n|----------|---------|---------|\n| `NBGV_SemVer2` | `0.2.0-alpha.5` | Docker image tags, release names, tarball names |\n| `NBGV_SimpleVersion` | `0.2.0` | Stable release tags |\n| `NBGV_GitCommitId` | `abc1234` | OCI image labels, VERSION file |\n| `NBGV_BuildNumber` | `42` | CI build identification |\n\nShell scripts access via: `$NBGV_SemVer2` after NBGV GitHub Action runs.\n\n## Quick commands\n\n```bash\n# Install via curl (most users)\ncurl -fsSL https://github.com/novotnyllc/containai/releases/latest/download/install.sh | bash\n\n# Install via manual tarball download\ntar xzf containai-0.2.0-linux-x64.tar.gz\ncd containai-0.2.0-linux-x64 && ./install.sh\n\n# Build Docker images (uses local images if available)\n./src/build.sh\n\n# Build .NET projects\ndotnet build\n\n# Run .NET unit tests\ndotnet test\n\n# Run all integration tests\n./tests/integration/test-acp-proxy.sh\n./tests/integration/test-sync-integration.sh\n./tests/integration/test-dind.sh  # requires sysbox\n\n# Check NBGV version\nnbgv get-version\n```\n\n## Acceptance\n\n- [ ] `./src/build.sh` uses local images when available\n- [ ] `cai update` uses local images when available (not just build.sh)\n- [ ] `./src/build.sh` uses correct image prefix (ghcr.io/novotnyllc/containai/)\n- [ ] .NET solution uses slnx format\n- [ ] ACP functionality split into library (ContainAI.Acp) and CLI (acp-proxy)\n- [ ] .NET code uses NuGet packages (CliWrap, etc.) instead of reinventing\n- [ ] xUnit 3 unit tests for .NET library pass\n- [ ] `dotnet test` runs in CI\n- [ ] NBGV provides version env vars for ALL build steps\n- [ ] Central Package Management configured\n- [ ] ArtifactsOutput enabled with artifacts/ directory\n- [ ] All integration tests pass in CI\n- [ ] E2E tests run in CI (sysbox installed via install.sh)\n- [ ] install.sh works both standalone (curl) AND from inside tarball\n- [ ] Release tarballs contain runtime only (no Dockerfiles, tests, build scripts)\n- [ ] install.sh included in both release assets AND each tarball\n- [ ] PR builds upload artifacts to PR-specific location\n- [ ] PR test stage extracts and tests from PR artifacts\n- [ ] No binaries checked into repo\n\n## References\n\n- `src/build.sh:349-352` - Current auto-load logic\n- `src/lib/update.sh:2248` - Current pull-always logic\n- `src/acp-proxy/Program.cs` - Code to refactor\n- `tests/integration/test-dind.sh:121-128` - Local image check pattern\n- `.github/workflows/docker.yml` - CI workflow\n- `.github/workflows/build-sysbox.yml` - Sysbox build workflow\n- `install.sh` - Current installer (clones repo)\n\n## Follow-up Epic\n\nDocumentation updates will be a separate epic following this one.\n"
  },
  "epic_id": "fn-44-build-system-net-project-restructuring",
  "schema_version": 2,
  "tasks": [
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-02T15:09:13.769393Z",
        "depends_on": [],
        "epic": "fn-44-build-system-net-project-restructuring",
        "id": "fn-44-build-system-net-project-restructuring.1",
        "priority": null,
        "spec_path": ".flow/tasks/fn-44-build-system-net-project-restructuring.1.md",
        "status": "todo",
        "title": "Fix Docker build image prefix and local fallback",
        "updated_at": "2026-02-02T15:21:02.801595Z"
      },
      "id": "fn-44-build-system-net-project-restructuring.1",
      "runtime": null,
      "spec": "# fn-44-build-system-net-project-restructuring.1 Fix Docker build image prefix and local fallback\n\n## Description\nFix the Docker build to use correct image prefix and add local image fallback before pulling from registry - for BOTH `build.sh` AND `cai update`.\n\n**Size:** M\n**Files:**\n- `src/build.sh`\n- `src/lib/update.sh`\n\n## Approach\n\n1. **Fix image prefix**: The default `--image-prefix containai` resolves to `docker.io/containai/` which doesn't exist. Change default to `ghcr.io/novotnyllc/containai` or make registry explicit.\n\n2. **Add local image fallback to build.sh**: Before pulling from registry, check if image exists locally using the pattern from `tests/integration/test-dind.sh:121-128`:\n   ```bash\n   if docker image inspect \"$IMAGE\" >/dev/null 2>&1; then\n       # Use local image\n   elif docker pull \"$REGISTRY/$IMAGE\" 2>/dev/null; then\n       # Use pulled image\n   else\n       # Build from scratch\n   fi\n   ```\n\n3. **Add local image fallback to cai update**: The `_cai_refresh_pull_base()` at `src/lib/update.sh:2248` always pulls. Add the same cascade pattern so it checks local first.\n\n4. **Update layer build functions** at `src/build.sh:470-532` to use this cascade pattern.\n\n## Key context\n\n- Build uses buildx with `--load` for single-platform (line 349-352)\n- Layer builds: base -> sdks -> agents -> final (line 470-532)\n- `cai update` has `--rebuild` flag that rebuilds default template\n- Each Dockerfile has ARG for upstream image (e.g., `Dockerfile.sdks:15` has `BASE_IMAGE` ARG)\n## Approach\n\n1. **Fix image prefix**: The default `--image-prefix containai` resolves to `docker.io/containai/` which doesn't exist. Change default to `ghcr.io/novotnyllc/containai` or make registry explicit.\n\n2. **Add local image fallback**: Before pulling from registry, check if image exists locally using the pattern from `tests/integration/test-dind.sh:121-128`:\n   ```bash\n   if docker image inspect \"$IMAGE\" >/dev/null 2>&1; then\n       # Use local image\n   elif docker pull \"$REGISTRY/$IMAGE\" 2>/dev/null; then\n       # Use pulled image\n   else\n       # Build from scratch\n   fi\n   ```\n\n3. **Update layer build functions** at `src/build.sh:470-532` to use this cascade pattern.\n\n## Key context\n\n- Build uses buildx with `--load` for single-platform (line 349-352)\n- Layer builds: base -> sdks -> agents -> final (line 470-532)\n- Each Dockerfile has ARG for upstream image (e.g., `Dockerfile.sdks:15` has `BASE_IMAGE` ARG)\n## Acceptance\n- [ ] `./src/build.sh` without arguments uses correct registry prefix\n- [ ] `./src/build.sh` uses existing local images without pulling\n- [ ] `cai update` uses existing local images without pulling\n- [ ] Build/update falls back to registry pull if local image missing\n- [ ] Build/update falls back to building from scratch if pull fails\n- [ ] `--image-prefix` flag still works for custom registries\n- [ ] Verbose mode shows which path was taken (local/pull/build)\n- [ ] Existing tests pass (`tests/integration/test-secure-engine.sh`)\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-02T15:09:17.161665Z",
        "depends_on": [],
        "epic": "fn-44-build-system-net-project-restructuring",
        "id": "fn-44-build-system-net-project-restructuring.2",
        "priority": null,
        "spec_path": ".flow/tasks/fn-44-build-system-net-project-restructuring.2.md",
        "status": "todo",
        "title": "Set up .NET project infrastructure (CPM, NBGV, ArtifactsOutput, slnx)",
        "updated_at": "2026-02-02T15:45:08.494006Z"
      },
      "id": "fn-44-build-system-net-project-restructuring.2",
      "runtime": null,
      "spec": "# fn-44-build-system-net-project-restructuring.2 Set up .NET project infrastructure (CPM, NBGV, ArtifactsOutput, slnx)\n\n## Description\nSet up modern .NET project infrastructure with Central Package Management, NBGV versioning (for ALL build versions, not just .NET), ArtifactsOutput, and slnx solution format.\n\n**Size:** M\n**Files:**\n- `Directory.Build.props` (new)\n- `Directory.Packages.props` (new)\n- `version.json` (new)\n- `ContainAI.slnx` (new, replaces `ContainAI.sln`)\n- `src/acp-proxy/acp-proxy.csproj` (update)\n- `nuget.config` (new or update)\n- `.github/workflows/docker.yml` (add NBGV action)\n\n## Approach\n\n1. **NBGV for unified versioning**: NBGV sets environment variables (`NBGV_SemVer2`, `NBGV_SimpleVersion`, `NBGV_GitCommitId`, etc.) that ALL build steps can use - shell scripts, Docker builds, release tags, etc.\n\n2. **Central Package Management**: Create `Directory.Packages.props` at repo root with all package versions including:\n   - `Nerdbank.GitVersioning` (GlobalPackageReference)\n   - `Microsoft.SourceLink.GitHub`\n   - `StreamJsonRpc` - JSON-RPC protocol handling\n   - `CliWrap` - Process execution\n   - `xunit.v3` - Testing (VSTest v2 native)\n   - `Microsoft.NET.Test.Sdk`\n\n3. **ArtifactsOutput**: Add `UseArtifactsOutput` to `Directory.Build.props`. Output goes to `artifacts/` directory.\n\n4. **slnx migration**: Run `dotnet sln migrate` to convert `ContainAI.sln` to `ContainAI.slnx`.\n\n5. **GitHub Actions NBGV setup**:\n   ```yaml\n   - uses: dotnet/nbgv@master\n     id: nbgv\n   # All subsequent steps can use ${{ steps.nbgv.outputs.SemVer2 }}\n   # Or env: NBGV_SemVer2, NBGV_SimpleVersion, etc.\n   ```\n\n## Key context\n\n- NBGV requires `fetch-depth: 0` in GitHub Actions checkout (critical!)\n- NBGV outputs are available as both step outputs AND environment variables\n- Shell scripts in CI can use `$NBGV_SemVer2` directly after the NBGV action runs\n- Docker build can use `--build-arg VERSION=$NBGV_SemVer2`\n- StreamJsonRpc is Microsoft's production JSON-RPC implementation\n- xUnit 3 uses VSTest v2 natively - no separate runner needed\n- CliWrap provides fluent API for process execution\n## Approach\n\n1. **NBGV for unified versioning**: NBGV sets environment variables (`NBGV_SemVer2`, `NBGV_SimpleVersion`, `NBGV_GitCommitId`, etc.) that ALL build steps can use - shell scripts, Docker builds, release tags, etc.\n\n2. **Central Package Management**: Create `Directory.Packages.props` at repo root with all package versions including:\n   - `Nerdbank.GitVersioning` (GlobalPackageReference)\n   - `Microsoft.SourceLink.GitHub`\n   - `CliWrap` (process management, replaces ProcessStartInfo)\n   - `xunit.v3` (xUnit 3 with VSTest v2 integration - no separate runner needed)\n   - `Microsoft.NET.Test.Sdk`\n\n3. **ArtifactsOutput**: Add `UseArtifactsOutput` to `Directory.Build.props`. Output goes to `artifacts/` directory.\n\n4. **slnx migration**: Run `dotnet sln migrate` to convert `ContainAI.sln` to `ContainAI.slnx`.\n\n5. **GitHub Actions NBGV setup**:\n   ```yaml\n   - uses: dotnet/nbgv@master\n     id: nbgv\n   # All subsequent steps can use ${{ steps.nbgv.outputs.SemVer2 }}\n   # Or env: NBGV_SemVer2, NBGV_SimpleVersion, etc.\n   ```\n\n## Key context\n\n- NBGV requires `fetch-depth: 0` in GitHub Actions checkout (critical!)\n- NBGV outputs are available as both step outputs AND environment variables\n- Shell scripts in CI can use `$NBGV_SemVer2` directly after the NBGV action runs\n- Docker build can use `--build-arg VERSION=$NBGV_SemVer2`\n- xUnit 3 uses VSTest v2 natively - no `xunit.runner.visualstudio` package needed\n- CliWrap provides fluent API for process execution, better than raw ProcessStartInfo\n## Approach\n\n1. **NBGV for unified versioning**: NBGV sets environment variables (`NBGV_SemVer2`, `NBGV_SimpleVersion`, `NBGV_GitCommitId`, etc.) that ALL build steps can use - shell scripts, Docker builds, release tags, etc.\n\n2. **Central Package Management**: Create `Directory.Packages.props` at repo root with all package versions including:\n   - `Nerdbank.GitVersioning` (GlobalPackageReference)\n   - `Microsoft.SourceLink.GitHub`\n   - `CliWrap` (process management, replaces ProcessStartInfo)\n   - `xunit` (3.x)\n   - `xunit.runner.visualstudio`\n   - `Microsoft.NET.Test.Sdk`\n\n3. **ArtifactsOutput**: Add `UseArtifactsOutput` to `Directory.Build.props`. Output goes to `artifacts/` directory.\n\n4. **slnx migration**: Run `dotnet sln migrate` to convert `ContainAI.sln` to `ContainAI.slnx`.\n\n5. **GitHub Actions NBGV setup**:\n   ```yaml\n   - uses: dotnet/nbgv@master\n     id: nbgv\n   # All subsequent steps can use ${{ steps.nbgv.outputs.SemVer2 }}\n   # Or env: NBGV_SemVer2, NBGV_SimpleVersion, etc.\n   ```\n\n## Key context\n\n- NBGV requires `fetch-depth: 0` in GitHub Actions checkout (critical!)\n- NBGV outputs are available as both step outputs AND environment variables\n- Shell scripts in CI can use `$NBGV_SemVer2` directly after the NBGV action runs\n- Docker build can use `--build-arg VERSION=$NBGV_SemVer2`\n- xUnit 3 is the latest major version with improved performance and features\n- CliWrap provides fluent API for process execution, better than raw ProcessStartInfo\n## Approach\n\n1. **NBGV for unified versioning**: NBGV sets environment variables (`NBGV_SemVer2`, `NBGV_SimpleVersion`, `NBGV_GitCommitId`, etc.) that ALL build steps can use - shell scripts, Docker builds, release tags, etc.\n\n2. **Central Package Management**: Create `Directory.Packages.props` at repo root with all package versions including:\n   - `Nerdbank.GitVersioning` (GlobalPackageReference)\n   - `Microsoft.SourceLink.GitHub`\n   - `xunit` (3.x)\n   - `xunit.runner.visualstudio`\n   - `Microsoft.NET.Test.Sdk`\n\n3. **ArtifactsOutput**: Add `UseArtifactsOutput` to `Directory.Build.props`. Output goes to `artifacts/` directory.\n\n4. **slnx migration**: Run `dotnet sln migrate` to convert `ContainAI.sln` to `ContainAI.slnx`.\n\n5. **GitHub Actions NBGV setup**:\n   ```yaml\n   - uses: dotnet/nbgv@master\n     id: nbgv\n   # All subsequent steps can use ${{ steps.nbgv.outputs.SemVer2 }}\n   # Or env: NBGV_SemVer2, NBGV_SimpleVersion, etc.\n   ```\n\n## Key context\n\n- NBGV requires `fetch-depth: 0` in GitHub Actions checkout (critical!)\n- NBGV outputs are available as both step outputs AND environment variables\n- Shell scripts in CI can use `$NBGV_SemVer2` directly after the NBGV action runs\n- Docker build can use `--build-arg VERSION=$NBGV_SemVer2`\n- xUnit 3 is the latest major version with improved performance and features\n## Approach\n\n1. **NBGV for unified versioning**: NBGV sets environment variables (`NBGV_SemVer2`, `NBGV_SimpleVersion`, `NBGV_GitCommitId`, etc.) that ALL build steps can use - shell scripts, Docker builds, release tags, etc.\n\n2. **Central Package Management**: Create `Directory.Packages.props` at repo root with all package versions.\n\n3. **ArtifactsOutput**: Add `UseArtifactsOutput` to `Directory.Build.props`. Output goes to `artifacts/` directory.\n\n4. **slnx migration**: Run `dotnet sln migrate` to convert `ContainAI.sln` to `ContainAI.slnx`.\n\n5. **GitHub Actions NBGV setup**:\n   ```yaml\n   - uses: dotnet/nbgv@master\n     id: nbgv\n   # All subsequent steps can use ${{ steps.nbgv.outputs.SemVer2 }}\n   # Or env: NBGV_SemVer2, NBGV_SimpleVersion, etc.\n   ```\n\n## Key context\n\n- NBGV requires `fetch-depth: 0` in GitHub Actions checkout (critical!)\n- NBGV outputs are available as both step outputs AND environment variables\n- Shell scripts in CI can use `$NBGV_SemVer2` directly after the NBGV action runs\n- Docker build can use `--build-arg VERSION=$NBGV_SemVer2`\n## Approach\n\n1. **Central Package Management**: Create `Directory.Packages.props` at repo root with all package versions. Update csproj to remove version attributes from PackageReference items.\n\n2. **NBGV**: Create `version.json` with initial version `0.1` and configure `publicReleaseRefSpec` for main branch. Add NBGV as GlobalPackageReference.\n\n3. **ArtifactsOutput**: Add `UseArtifactsOutput` to `Directory.Build.props`. Output goes to `artifacts/` directory.\n\n4. **slnx migration**: Run `dotnet sln migrate` to convert `ContainAI.sln` to `ContainAI.slnx`. Delete old .sln file.\n\n5. **SourceLink**: Add Microsoft.SourceLink.GitHub for debugging support.\n\n## Key context\n\n- NBGV requires `fetch-depth: 0` in GitHub Actions checkout (critical!)\n- CPM with `CentralPackageTransitivePinningEnabled` for transitive control\n- ArtifactsOutput structure: `artifacts/bin/<project>/<config>/`, `artifacts/publish/<project>/<config>/`\n- Current packages in acp-proxy.csproj: no external packages (all BCL)\n## Acceptance\n- [ ] `Directory.Build.props` exists with ArtifactsOutput enabled\n- [ ] `Directory.Packages.props` exists with CPM enabled\n- [ ] `Directory.Packages.props` includes StreamJsonRpc package\n- [ ] `Directory.Packages.props` includes CliWrap package\n- [ ] `Directory.Packages.props` includes xunit.v3 (no separate runner package)\n- [ ] `version.json` exists with NBGV configuration\n- [ ] `ContainAI.slnx` exists and builds successfully\n- [ ] Old `ContainAI.sln` removed\n- [ ] `dotnet build` produces output in `artifacts/bin/`\n- [ ] `nbgv get-version` returns valid version\n- [ ] GitHub Actions workflow uses NBGV action with fetch-depth: 0\n- [ ] NBGV env vars available to all subsequent CI steps (not just .NET)\n- [ ] Docker build uses NBGV version for OCI labels\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-02T15:09:20.959751Z",
        "depends_on": [
          "fn-44-build-system-net-project-restructuring.2"
        ],
        "epic": "fn-44-build-system-net-project-restructuring",
        "id": "fn-44-build-system-net-project-restructuring.3",
        "priority": null,
        "spec_path": ".flow/tasks/fn-44-build-system-net-project-restructuring.3.md",
        "status": "todo",
        "title": "Refactor ACP code into ContainAI.Acp library and acp-proxy CLI",
        "updated_at": "2026-02-02T15:45:27.275457Z"
      },
      "id": "fn-44-build-system-net-project-restructuring.3",
      "runtime": null,
      "spec": "# fn-44-build-system-net-project-restructuring.3 Refactor ACP code into ContainAI.Acp library and acp-proxy CLI\n\n## Description\nRefactor the monolithic Program.cs (1029 lines) into a proper library/CLI structure with ContainAI.Acp library and acp-proxy CLI application. Use StreamJsonRpc for JSON-RPC protocol, CliWrap for process management. Add xUnit 3 unit tests.\n\n**Size:** M\n**Files:**\n- `src/ContainAI.Acp/ContainAI.Acp.csproj` (new library)\n- `src/ContainAI.Acp/Protocol/` (new - StreamJsonRpc integration)\n- `src/ContainAI.Acp/Sessions/` (new - session management with CliWrap)\n- `src/ContainAI.Acp/PathTranslation/` (new - path translation)\n- `src/acp-proxy/acp-proxy.csproj` (update - reference library)\n- `src/acp-proxy/Program.cs` (simplify to CLI entry point)\n- `tests/ContainAI.Acp.Tests/ContainAI.Acp.Tests.csproj` (new - xUnit 3 tests)\n- `tests/ContainAI.Acp.Tests/*.cs` (new - test files)\n- `ContainAI.slnx` (add new projects)\n\n## Approach\n\n1. **Create ContainAI.Acp library project** with proper structure:\n   - `Protocol/` - Use StreamJsonRpc for JSON-RPC message handling\n   - `Sessions/` - Session management using CliWrap for process spawning\n   - `PathTranslation/` - Host/container path mapping\n   - Keep AOT-compatible\n\n2. **Use StreamJsonRpc for JSON-RPC**:\n   - Microsoft's production JSON-RPC implementation\n   - Handles message framing, serialization, request/response correlation\n   - Supports NDJSON (newline-delimited) format\n   - Properly handles bidirectional communication\n\n3. **Use CliWrap for process execution**:\n   - Fluent API for spawning MCP server processes\n   - Clean stdin/stdout piping\n   - Proper cancellation support\n\n4. **Update acp-proxy CLI** to be thin wrapper:\n   - Parse command line arguments\n   - Initialize and run the ACP server from library\n   - Handle process lifecycle\n\n5. **Create xUnit 3 test project**:\n   - Test protocol handling with StreamJsonRpc\n   - Test path translation logic\n   - Test session state management\n   - Use `[Fact]` and `[Theory]` attributes\n\n## Key context\n\n- StreamJsonRpc handles JSON-RPC 2.0 protocol correctly\n- Current code has manual JSON-RPC handling that StreamJsonRpc replaces\n- Session management handles multiple concurrent MCP sessions\n- Path translation maps between host and container paths\n- Race condition pitfall: StreamJsonRpc handles request/response correlation properly\n- CliWrap is AOT-compatible\n## Approach\n\n1. **Create ContainAI.Acp library project** with proper structure:\n   - `Protocol/` - JSON-RPC message types, serialization\n   - `Sessions/` - Session management using CliWrap for process spawning\n   - `PathTranslation/` - Host/container path mapping\n   - Keep AOT-compatible (no reflection)\n\n2. **Replace ProcessStartInfo with CliWrap**:\n   - Use `Cli.Wrap()` fluent API for spawning MCP server processes\n   - Use `PipeTarget` for stdout/stderr handling\n   - Use `CancellationToken` for process cancellation\n   - CliWrap handles stdin/stdout piping cleanly\n\n3. **Update acp-proxy CLI** to be thin wrapper:\n   - Parse command line arguments\n   - Initialize and run the ACP server from library\n   - Handle process lifecycle\n\n4. **Create xUnit 3 test project**:\n   - Add `tests/ContainAI.Acp.Tests/ContainAI.Acp.Tests.csproj`\n   - Use xUnit 3.x (latest) with `Microsoft.NET.Test.Sdk`\n   - Test protocol serialization/deserialization\n   - Test path translation logic\n   - Test session state management\n   - Use `[Fact]` and `[Theory]` attributes\n\n5. **Preserve AOT compatibility**: Use `[JsonSerializable]` attributes, avoid reflection. CliWrap is AOT-compatible.\n\n## Key context\n\n- Current code uses System.Text.Json source generators for AOT\n- Session management handles multiple concurrent MCP sessions\n- Path translation maps between host and container paths\n- NDJSON framing for message protocol (per `.flow/memory/conventions.md`)\n- Race condition pitfall: Register TCS before sending request (per `.flow/memory/pitfalls.md:381`)\n- CliWrap: https://github.com/Tyrrrz/CliWrap - fluent process execution library\n- CliWrap is AOT-compatible and has no reflection usage\n## Approach\n\n1. **Create ContainAI.Acp library project** with proper structure:\n   - `Protocol/` - JSON-RPC message types, serialization\n   - `Sessions/` - Session management, process spawning\n   - `PathTranslation/` - Host/container path mapping\n   - Keep AOT-compatible (no reflection)\n\n2. **Update acp-proxy CLI** to be thin wrapper:\n   - Parse command line arguments\n   - Initialize and run the ACP server from library\n   - Handle process lifecycle\n\n3. **Create xUnit 3 test project**:\n   - Add `tests/ContainAI.Acp.Tests/ContainAI.Acp.Tests.csproj`\n   - Use xUnit 3.x (latest) with `Microsoft.NET.Test.Sdk`\n   - Test protocol serialization/deserialization\n   - Test path translation logic\n   - Test session state management\n   - Use `[Fact]` and `[Theory]` attributes\n\n4. **Preserve AOT compatibility**: Use `[JsonSerializable]` attributes, avoid reflection.\n\n## Key context\n\n- Current code uses System.Text.Json source generators for AOT\n- Session management handles multiple concurrent MCP sessions\n- Path translation maps between host and container paths\n- NDJSON framing for message protocol (per `.flow/memory/conventions.md`)\n- Race condition pitfall: Register TCS before sending request (per `.flow/memory/pitfalls.md:381`)\n- xUnit 3 supports parallel test execution and modern .NET features\n## Approach\n\n1. **Create ContainAI.Acp library project** with proper structure:\n   - `Protocol/` - JSON-RPC message types, serialization\n   - `Sessions/` - Session management, process spawning\n   - `PathTranslation/` - Host/container path mapping\n   - Keep AOT-compatible (no reflection)\n\n2. **Update acp-proxy CLI** to be thin wrapper:\n   - Parse command line arguments\n   - Initialize and run the ACP server from library\n   - Handle process lifecycle\n\n3. **Preserve AOT compatibility**: Use `[JsonSerializable]` attributes, avoid reflection.\n\n## Key context\n\n- Current code uses System.Text.Json source generators for AOT\n- Session management handles multiple concurrent MCP sessions\n- Path translation maps between host and container paths\n- NDJSON framing for message protocol (per `.flow/memory/conventions.md`)\n- Race condition pitfall: Register TCS before sending request (per `.flow/memory/pitfalls.md:381`)\n## Acceptance\n- [ ] ContainAI.Acp library project exists and builds\n- [ ] Library uses StreamJsonRpc for JSON-RPC protocol\n- [ ] Library uses CliWrap for all process execution (no raw ProcessStartInfo)\n- [ ] Library is AOT-compatible (no trimming warnings)\n- [ ] acp-proxy CLI references ContainAI.Acp library\n- [ ] acp-proxy CLI builds as self-contained AOT binary\n- [ ] xUnit 3 test project exists at tests/ContainAI.Acp.Tests/\n- [ ] Unit tests cover JSON-RPC message handling\n- [ ] Unit tests cover path translation\n- [ ] Unit tests cover session management\n- [ ] `dotnet test` passes all unit tests\n- [ ] All existing ACP functionality preserved\n- [ ] `tests/integration/test-acp-proxy.sh` passes\n- [ ] Library can be referenced by external projects (future NuGet publishing)\n- [ ] Code follows project conventions (no single 1000+ line files)\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-02T15:09:24.092204Z",
        "depends_on": [
          "fn-44-build-system-net-project-restructuring.1"
        ],
        "epic": "fn-44-build-system-net-project-restructuring",
        "id": "fn-44-build-system-net-project-restructuring.4",
        "priority": null,
        "spec_path": ".flow/tasks/fn-44-build-system-net-project-restructuring.4.md",
        "status": "todo",
        "title": "Enable sysbox in GitHub Actions for E2E tests",
        "updated_at": "2026-02-02T15:15:26.079831Z"
      },
      "id": "fn-44-build-system-net-project-restructuring.4",
      "runtime": null,
      "spec": "# fn-44-build-system-net-project-restructuring.4 Enable sysbox in GitHub Actions for E2E tests\n\n## Description\nConfigure GitHub Actions to run E2E tests with sysbox by running `install.sh` on the runner VM (just like a normal user would). GitHub Actions runners are raw VMs with passwordless sudo, not containers.\n\n**Size:** M\n**Files:**\n- `.github/workflows/docker.yml` (update test job)\n- `install.sh` (may need updates to work in CI context)\n\n## Approach\n\n1. **Run install.sh in CI**: The install script should detect that sysbox is needed and install/configure it. This tests the real installation path that users will follow.\n\n2. **GitHub Actions runner context**:\n   - Runners are VMs (ubuntu-latest, ubuntu-22.04), not containers\n   - Have passwordless sudo\n   - Can install kernel modules and system services\n   - sysbox installation will work normally\n\n3. **Test execution flow**:\n   ```yaml\n   - name: Install ContainAI (includes sysbox)\n     run: ./install.sh\n\n   - name: Run E2E tests\n     run: ./tests/integration/test-dind.sh\n   ```\n\n4. **Architecture matrix**: Use appropriate runners for each arch (ubuntu-22.04 for amd64, ubuntu-24.04-arm for arm64).\n\n## Key context\n\n- GitHub-hosted runners have passwordless sudo\n- Runners are fresh VMs, not containers - sysbox kernel module installation works\n- Running install.sh validates the real user experience\n- `build-sysbox.yml` already handles sysbox package building (can use those artifacts or upstream releases)\n## Approach\n\n1. **Install sysbox in workflow**: Use the sysbox deb packages from `build-sysbox.yml` artifacts or install from nestybox releases.\n\n2. **Configure Docker with sysbox runtime**: Add sysbox-runc as a runtime option.\n\n3. **Run E2E tests**: Execute `tests/integration/test-dind.sh` with sysbox runtime.\n\n4. **Use matrix strategy** for architecture (amd64/arm64) following pattern from `build-sysbox.yml:484-597`.\n\n## Key context\n\n- GitHub-hosted runners have passwordless sudo (per user request)\n- Sysbox requires kernel module loading (may need specific runner configuration)\n- `build-sysbox.yml` already builds sysbox-ce deb packages for ubuntu-22.04 and ubuntu-24.04-arm\n- E2E tests use `CONTAINAI_TEST_IMAGE` env var\n- Test resource cleanup uses `containai.test=1` label\n## Acceptance\n- [ ] CI runs install.sh to set up the environment\n- [ ] Sysbox installed and configured via install.sh (not manual steps)\n- [ ] `tests/integration/test-dind.sh` runs successfully in CI\n- [ ] E2E tests run on both amd64 and arm64\n- [ ] Test artifacts collected on failure\n- [ ] CI logs show sysbox runtime being used\n- [ ] install.sh works in CI context (handles non-interactive mode)\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-02T15:09:27.259223Z",
        "depends_on": [
          "fn-44-build-system-net-project-restructuring.3"
        ],
        "epic": "fn-44-build-system-net-project-restructuring",
        "id": "fn-44-build-system-net-project-restructuring.5",
        "priority": null,
        "spec_path": ".flow/tasks/fn-44-build-system-net-project-restructuring.5.md",
        "status": "todo",
        "title": "Update CI to build and publish multi-arch .NET binaries",
        "updated_at": "2026-02-02T15:43:29.481515Z"
      },
      "id": "fn-44-build-system-net-project-restructuring.5",
      "runtime": null,
      "spec": "# fn-44-build-system-net-project-restructuring.5 Update CI to build and publish multi-arch .NET binaries\n\n## Description\nCreate release packaging system: build multi-arch .NET binaries, package into flat per-architecture tarballs (runtime only), publish tarball + standalone install.sh to GitHub Releases. PR builds upload to PR-specific artifact location for testing.\n\n**Size:** M\n**Files:**\n- `.github/workflows/docker.yml` (update build and test jobs)\n- `.github/workflows/release.yml` (new workflow for releases)\n- `install.sh` (rewrite as standalone wget-able script)\n- `scripts/package-release.sh` (new - creates tarball)\n\n## Approach\n\n1. **Two install paths:**\n\n   **Path A - curl/wget (most users):**\n   ```bash\n   curl -fsSL https://github.com/.../releases/latest/download/install.sh | bash\n   ```\n   - install.sh detects arch, downloads tarball, extracts, configures\n\n   **Path B - manual tarball download:**\n   ```bash\n   # User downloads tarball manually, then:\n   tar xzf containai-0.2.0-linux-x64.tar.gz\n   cd containai-0.2.0-linux-x64\n   ./install.sh --local   # Install from extracted directory\n   ```\n\n2. **install.sh dual-mode behavior:**\n   - If run standalone (no local files): download tarball from Releases\n   - If run from extracted tarball (`--local` or detects local files): install from current directory\n   - Same script works both ways\n\n3. **Flat tarball structure - runtime only** (e.g., `containai-0.2.0-linux-x64.tar.gz`):\n   ```\n   containai-0.2.0-linux-x64/\n   \u251c\u2500\u2500 containai.sh            # Main CLI\n   \u251c\u2500\u2500 lib/                    # Shell libraries\n   \u251c\u2500\u2500 templates/              # User templates\n   \u251c\u2500\u2500 acp-proxy               # AOT binary\n   \u251c\u2500\u2500 install.sh              # Same script, works locally too\n   \u251c\u2500\u2500 VERSION\n   \u2514\u2500\u2500 LICENSE\n   ```\n\n   **NOT included** (contributors clone repo):\n   - Dockerfiles\n   - Tests\n   - Build scripts\n   - Documentation\n\n4. **Multi-arch matrix build**:\n   - linux-x64 on ubuntu-latest\n   - linux-arm64 on ubuntu-24.04-arm\n   - Build AOT binaries with `dotnet publish --self-contained`\n\n5. **PR artifact flow**:\n   - PR builds upload tarball to GitHub Actions artifacts\n   - Test job downloads, extracts, runs `./install.sh --local`\n\n6. **Release flow**:\n   - Tag push triggers release workflow\n   - Upload install.sh + tarballs as release assets\n   - install.sh included in both release assets AND inside each tarball\n\n## Key context\n\n- install.sh must work both as standalone download AND from inside tarball\n- Detect mode: check if `containai.sh` exists in same directory\n- `--local` flag forces local install even if files look like they might be elsewhere\n- Tarballs are for end users, not contributors\n## Approach\n\n1. **Standalone install.sh** - Published as release asset, wget-able:\n   ```bash\n   # User runs:\n   curl -fsSL https://github.com/.../releases/latest/download/install.sh | bash\n   ```\n   - Detects architecture\n   - Downloads appropriate tarball from same release\n   - Extracts to ~/.local/share/containai\n   - Creates cai wrapper in ~/.local/bin\n   - Installs sysbox if needed\n\n2. **Flat tarball structure - runtime only** (e.g., `containai-0.2.0-linux-x64.tar.gz`):\n   ```\n   containai-0.2.0-linux-x64/\n   \u251c\u2500\u2500 containai.sh            # Main CLI\n   \u251c\u2500\u2500 lib/                    # Shell libraries\n   \u251c\u2500\u2500 templates/              # User templates\n   \u251c\u2500\u2500 acp-proxy               # AOT binary\n   \u251c\u2500\u2500 VERSION\n   \u2514\u2500\u2500 LICENSE\n   ```\n\n   **NOT included** (contributors clone repo):\n   - Dockerfiles\n   - Tests\n   - Build scripts\n   - Documentation\n\n3. **Multi-arch matrix build**:\n   - linux-x64 on ubuntu-latest\n   - linux-arm64 on ubuntu-24.04-arm\n   - Build AOT binaries with `dotnet publish --self-contained`\n\n4. **PR artifact flow**:\n   - PR builds upload tarball + install.sh to GitHub Actions artifacts\n   - Test job downloads and runs install.sh\n   - install.sh can accept artifact URL override for PR testing\n\n5. **Release flow**:\n   - Tag push triggers release workflow\n   - Upload install.sh + tarballs as release assets\n   - install.sh published at predictable URL: `.../releases/latest/download/install.sh`\n\n## Key context\n\n- install.sh must be standalone - can't be inside tarball (chicken-egg)\n- Tarballs are for end users, not contributors\n- Contributors clone repo to access Dockerfiles, tests, build scripts\n- GitHub releases have `latest/download/` URL pattern for latest release\n## Approach\n\n1. **Standalone install.sh** - Published as release asset, wget-able:\n   ```bash\n   # User runs:\n   curl -fsSL https://github.com/.../releases/latest/download/install.sh | bash\n   ```\n   - Detects architecture\n   - Downloads appropriate tarball from same release\n   - Extracts to ~/.local/share/containai\n   - Creates cai wrapper in ~/.local/bin\n   - Installs sysbox if needed\n\n2. **Flat tarball structure** (e.g., `containai-0.2.0-linux-x64.tar.gz`):\n   ```\n   containai-0.2.0-linux-x64/\n   \u251c\u2500\u2500 containai.sh            # Main CLI\n   \u251c\u2500\u2500 lib/                    # Shell libraries\n   \u251c\u2500\u2500 container/              # Dockerfiles\n   \u251c\u2500\u2500 acp-proxy               # AOT binary (flat, not in bin/)\n   \u251c\u2500\u2500 VERSION\n   \u2514\u2500\u2500 README.md\n   ```\n   No nested `bin/` or `src/` - flat and simple.\n\n3. **Multi-arch matrix build**:\n   - linux-x64 on ubuntu-latest\n   - linux-arm64 on ubuntu-24.04-arm\n   - Build AOT binaries with `dotnet publish --self-contained`\n\n4. **PR artifact flow**:\n   - PR builds upload tarball + install.sh to GitHub Actions artifacts\n   - Test job downloads and runs install.sh\n   - install.sh can accept artifact URL override for PR testing\n\n5. **Release flow**:\n   - Tag push triggers release workflow\n   - Upload install.sh + tarballs as release assets\n   - install.sh published at predictable URL: `.../releases/latest/download/install.sh`\n\n## Key context\n\n- install.sh must be standalone - can't be inside tarball (chicken-egg)\n- Flat tarball structure is simpler to extract and navigate\n- GitHub releases have `latest/download/` URL pattern for latest release\n- PR artifacts accessible via `actions/download-artifact`\n## Approach\n\n1. **Create release tarball structure**:\n   ```\n   containai-${VERSION}-${ARCH}/\n   \u251c\u2500\u2500 bin/acp-proxy          # Pre-built AOT binary\n   \u251c\u2500\u2500 src/                   # Shell libraries\n   \u251c\u2500\u2500 install.sh             # Standalone installer\n   \u251c\u2500\u2500 VERSION                # Version from NBGV\n   \u2514\u2500\u2500 README.md\n   ```\n\n2. **Multi-arch matrix build**:\n   - linux-x64 on ubuntu-latest\n   - linux-arm64 on ubuntu-24.04-arm\n   - Build AOT binaries with `dotnet publish --self-contained`\n\n3. **PR artifact flow**:\n   - PR builds upload tarball to GitHub Actions artifacts\n   - Test job downloads artifact and runs install.sh from it\n   - This validates the full install flow before merge\n\n4. **Release flow**:\n   - Tag push triggers release workflow\n   - Upload tarballs as release assets\n   - Use NBGV version for release tag and tarball names\n\n5. **Update install.sh**:\n   - Detect architecture\n   - Download tarball from GitHub Releases (or PR artifact URL if provided)\n   - Extract to ~/.local/share/containai\n   - Create cai wrapper\n   - No repo clone needed\n\n## Key context\n\n- Current install.sh clones repo to ~/.local/share/containai\n- Tarballs eliminate git dependency for end users\n- PR artifacts accessible via: `actions/download-artifact`\n- Release assets accessible via: `https://github.com/{owner}/{repo}/releases/download/{tag}/{filename}`\n## Approach\n\n1. **Multi-arch matrix build**: Use matrix strategy for RIDs (linux-x64, linux-arm64).\n\n2. **Self-contained AOT publish**: Use `dotnet publish --self-contained` to create standalone binaries that don't need .NET runtime.\n\n3. **Publish to GitHub Releases**:\n   - On tag push or release creation, upload binaries as release assets\n   - Use NBGV version for release tag\n   - Binary naming: `acp-proxy-<version>-<rid>` (e.g., `acp-proxy-0.2.0-linux-x64`)\n\n4. **Update install.sh to download binaries**:\n   - Detect architecture\n   - Download appropriate binary from GitHub Releases\n   - No need to clone repo or have .NET installed\n   - Example: `curl -L https://github.com/org/repo/releases/download/v${VERSION}/acp-proxy-${VERSION}-linux-x64 -o /usr/local/bin/acp-proxy`\n\n5. **Docker build uses downloaded binary**: Don't build .NET in Dockerfile, copy pre-built binary.\n\n## Key context\n\n- Binaries must NOT be checked into repo (download at install time)\n- install.sh is the primary way users get ContainAI\n- AOT binaries are self-contained, no .NET runtime needed\n- NBGV version used for release tags and binary names\n## Approach\n\n1. **Multi-arch matrix build**: Use matrix strategy for RIDs (linux-x64, linux-arm64, osx-x64, osx-arm64, win-x64).\n\n2. **Self-contained publish**: Use `dotnet publish --self-contained` to create standalone binaries.\n\n3. **Upload as release artifacts**: Attach binaries to GitHub releases.\n\n4. **Update Docker build**: Copy pre-built binary instead of building during Docker image creation.\n\nFollow pattern from `Tyrrrz/YoutubeDownloader` and `JustArchiNET/ArchiSteamFarm` workflows.\n\n## Key context\n\n- Current build at `.github/workflows/docker.yml:285-295` uses `dotnet publish -c Release -r linux-x64`\n- AOT publishing requires building on target platform (can't cross-compile AOT)\n- For AOT: use ubuntu-latest for linux, macos-latest for osx, windows-latest for win\n- ArtifactsOutput puts publish output in `artifacts/publish/acp-proxy/<config>_<rid>/`\n## Acceptance\n- [ ] CI builds acp-proxy for linux-x64, linux-arm64\n- [ ] Binaries are self-contained AOT (no .NET runtime needed)\n- [ ] Release tarballs contain runtime only (CLI, lib, templates, binary, install.sh)\n- [ ] Release tarballs do NOT contain Dockerfiles, tests, or build scripts\n- [ ] install.sh works when curl'd standalone (downloads tarball)\n- [ ] install.sh works from inside extracted tarball (--local or auto-detect)\n- [ ] install.sh included in each tarball\n- [ ] install.sh published as standalone release asset too\n- [ ] PR builds upload tarball to Actions artifacts\n- [ ] PR test job extracts tarball and runs ./install.sh --local\n- [ ] Release workflow publishes all assets to GitHub Releases\n- [ ] `curl ... | bash` install works for end users\n- [ ] Manual tarball download + extract + ./install.sh works\n- [ ] Version from NBGV used for tarball names\n- [ ] No binaries or tarballs in git history\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-02T15:09:30.895986Z",
        "depends_on": [],
        "epic": "fn-44-build-system-net-project-restructuring",
        "id": "fn-44-build-system-net-project-restructuring.6",
        "priority": null,
        "spec_path": ".flow/tasks/fn-44-build-system-net-project-restructuring.6.md",
        "status": "todo",
        "title": "[DEFERRED] Documentation updates - separate epic",
        "updated_at": "2026-02-02T15:36:44.152050Z"
      },
      "id": "fn-44-build-system-net-project-restructuring.6",
      "runtime": null,
      "spec": "# fn-44-build-system-net-project-restructuring.6 Update documentation for build and project changes\n\n## Description\n**DEFERRED TO SEPARATE EPIC** - Documentation updates will be handled in a follow-up documentation epic after this build system epic is complete.\n\n**Size:** S (deferred)\n**Files:** None in this epic\n\n## Approach\n\nThis task is a placeholder noting that documentation will be addressed separately.\n## Approach\n\n1. **AGENTS.md**: Update Quick Commands section with new build flags and .NET build commands.\n\n2. **src/README.md**:\n   - Update project structure to show new ContainAI.Acp library\n   - Update build instructions for slnx\n   - Document ArtifactsOutput paths\n\n3. **docs/testing.md**: Add E2E test section explaining sysbox requirements and CI coverage.\n\n4. **CHANGELOG.md**: Add entries under Unreleased for all changes.\n\n## Key context\n\n- AGENTS.md is built-in reference, must stay current\n- Documentation uses Keep-a-Changelog format\n- Per docs-gap-scout: AGENTS.md, src/README.md, docs/testing.md are highest priority\n## Acceptance\n- [ ] Documented in follow-up epic\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    }
  ]
}
