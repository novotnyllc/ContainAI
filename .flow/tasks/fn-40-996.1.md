# fn-40-996.1 Build ACP Terminating Proxy

## Description
Build a native binary that acts as a terminating ACP proxy with multi-session support. It handles the ACP handshake, tracks multiple sessions, routes messages by sessionId, and passes MCP server config through to agents (with path translation).

## Acceptance
- [ ] Native binary compiles (C# .NET 10 Native AOT or Rust)
- [ ] Handles `initialize` request, responds with proxy capabilities
- [ ] Handles multiple `session/new` requests (multi-session)
- [ ] Translates paths in `mcpServers` args (host â†’ container)
- [ ] Routes `session/prompt`, `session/end` by sessionId
- [ ] Forwards agent responses/notifications back to editor
- [ ] Clean session cleanup on `session/end`
- [ ] Clean exit when all sessions end or stdin closes

## Implementation Notes

### Core Flow

```csharp
async Task RunAsync() {
    // 1. Handle initialize (cache for later)
    var initReq = await ReadRequestAsync(stdin);
    _cachedInit = initReq;
    await WriteResponseAsync(stdout, MakeInitResponse(initReq.Id));

    // 2. Main message loop
    while (true) {
        var msg = await ReadRequestAsync(stdin);

        switch (msg.Method) {
            case "session/new":
                await HandleSessionNewAsync(msg);
                break;

            case "session/prompt":
            case "session/end":
                await RouteToSessionAsync(msg);
                break;

            default:
                // Forward or handle other methods
                break;
        }
    }
}
```

### Session Manager

```csharp
class Session {
    string Id { get; }
    string Workspace { get; }
    string Container { get; }
    Process SshProcess { get; }
    Stream AgentStdin { get; }
    Stream AgentStdout { get; }
}

class SessionManager {
    ConcurrentDictionary<string, Session> _sessions = new();

    async Task<Session> CreateSessionAsync(SessionNewParams params, string agent) {
        var workspace = params.Cwd;

        // Find/create container
        var container = await _containerMgr.EnsureContainerAsync(workspace);

        // Connect to agent via SSH
        var ssh = await ConnectSshAsync(container, $"{agent} --acp");

        // Initialize agent
        await WriteRequestAsync(ssh.Stdin, _cachedInit);
        await ReadResponseAsync(ssh.Stdout);

        // Translate MCP paths and create session
        var translatedParams = TranslateMcpPaths(params, workspace);
        await WriteRequestAsync(ssh.Stdin, MakeSessionNew(translatedParams));
        var response = await ReadResponseAsync(ssh.Stdout);

        var session = new Session {
            Id = response.SessionId,
            Workspace = workspace,
            Container = container,
            SshProcess = ssh.Process,
            AgentStdin = ssh.Stdin,
            AgentStdout = ssh.Stdout,
        };

        _sessions[session.Id] = session;

        // Start reading agent output in background
        _ = Task.Run(() => ForwardAgentOutputAsync(session));

        return session;
    }
}
```

### Path Translation for MCP

```csharp
SessionNewParams TranslateMcpPaths(SessionNewParams params, string hostWorkspace) {
    if (params.McpServers == null) return params;

    var translated = params.McpServers.Select(server => {
        if (server.Type != "stdio" || server.Args == null)
            return server;

        // Replace host workspace with container path
        var newArgs = server.Args.Select(arg =>
            arg.Replace(hostWorkspace, "/home/agent/workspace")
        ).ToArray();

        return server with { Args = newArgs };
    }).ToArray();

    return params with { McpServers = translated };
}
```

### Container Manager

```csharp
async Task<string> EnsureContainerAsync(string workspace) {
    // Check for existing container
    var result = await RunAsync("docker", "ps", "-q",
        "--filter", $"label=containai.workspace={workspace}");

    if (!string.IsNullOrEmpty(result.Stdout.Trim()))
        return result.Stdout.Trim();

    // Create new container with host.docker.internal for MCP HTTP servers
    result = await RunAsync("cai", "shell", "--detach",
        "--mount", $"{workspace}:/home/agent/workspace",
        "--label", $"containai.workspace={workspace}");

    return result.Stdout.Trim();
}
```

### Agent Output Forwarding

```csharp
async Task ForwardAgentOutputAsync(Session session) {
    await foreach (var msg in ReadMessagesAsync(session.AgentStdout)) {
        // Forward all agent messages to editor
        await WriteMessageAsync(stdout, msg);

        // If session ended, clean up
        if (msg.Method == "session/end") {
            _sessions.TryRemove(session.Id, out _);
            session.SshProcess.Kill();
        }
    }
}
```

## Dependencies
- **fn-10-vep.35** (workspace symlink strategy) - Container creates symlink from host path to mount point.

## Done summary
TBD

## Evidence
- Commits:
- Tests:
- PRs:
