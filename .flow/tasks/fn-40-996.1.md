# fn-40-996.1 Build ACP Terminating Proxy

## Description
Build a native binary that acts as a terminating ACP proxy with multi-session support. Integrate with existing `cai` CLI as `--acp` entry point. Uses `cai exec` for container management rather than reimplementing container discovery.

## Acceptance
- [ ] `--acp` entry point added to `containai()` in containai.sh (before update checks)
- [ ] `CAI_NO_UPDATE_CHECK=1` guard added to `_cai_update_check` function
- [ ] Native binary compiles (C# .NET 10 Native AOT or Rust)
- [ ] Binary installs to `${_CAI_SCRIPT_DIR}/bin/acp-proxy`
- [ ] Uses NDJSON framing (newline-delimited JSON, not Content-Length headers)
- [ ] Handles `initialize` request, responds with proxy capabilities
- [ ] Handles multiple `session/new` requests (multi-session)
- [ ] Session IDs namespaced (proxy UUID → agent ID mapping)
- [ ] Workspace resolution: finds `.containai/config.toml` or git root
- [ ] Spawns `cai exec --workspace <root> --quiet -- <agent> --acp` per session
- [ ] Test mode: `CAI_ACP_TEST_MODE=1` allows any agent, `CAI_ACP_DIRECT_SPAWN=1` bypasses containers
- [ ] Output serialization: single writer task for stdout (prevents interleaving)
- [ ] Path-aware MCP arg translation (only absolute paths in workspace, not naive string replace)
- [ ] Routes `session/prompt`, `session/end` by sessionId
- [ ] Forwards agent responses/notifications back to editor
- [ ] Clean session cleanup on `session/end` (forward, wait with timeout, terminate)
- [ ] Clean exit when stdin EOF (end all sessions gracefully)

## Implementation Notes

### Directory Layout

```
src/
├── containai.sh           # Main CLI
├── lib/                   # Shell libraries
├── bin/                   # Native binaries (NEW)
│   └── acp-proxy          # ACP proxy binary
└── acp-proxy/             # ACP proxy source code
    ├── Program.cs
    └── ...
```

### CLI Entry Point (containai.sh)

Add to `containai()` BEFORE `_cai_update_check`:

```bash
containai() {
    # CRITICAL: --acp must be detected BEFORE update checks to avoid stdout pollution
    if [[ "${1:-}" == "--acp" ]]; then
        shift
        _containai_acp_proxy "$@"
        return $?
    fi

    # Normal flow continues...
}

_containai_acp_proxy() {
    local agent="${1:-claude}"

    # Validate agent (or allow test mode)
    if [[ "${CAI_ACP_TEST_MODE:-}" == "1" ]]; then
        : # Allow any agent in test mode
    else
        case "$agent" in
            claude|gemini) ;;
            *)
                echo "Unsupported agent: $agent" >&2
                return 1
                ;;
        esac
    fi

    # Binary location: src/bin/acp-proxy (avoids conflict with src/acp-proxy/ source dir)
    local proxy_bin="${_CAI_SCRIPT_DIR}/bin/acp-proxy"

    # Must be a regular file and executable
    if [[ ! -f "$proxy_bin" || ! -x "$proxy_bin" ]]; then
        echo "ACP proxy binary not found at $proxy_bin. Run 'cai update' to install." >&2
        return 1
    fi

    exec "$proxy_bin" "$agent"
}
```

### Update Check Guard

Add to `_cai_update_check` in `src/lib/update.sh`:

```bash
_cai_update_check() {
    # Skip if explicitly disabled (used by ACP proxy for stdout purity)
    if [[ "${CAI_NO_UPDATE_CHECK:-}" == "1" ]]; then
        return 0
    fi
    # ... existing logic
}
```

### NDJSON Framing

```csharp
// Reader
async IAsyncEnumerable<JsonRpcMessage> ReadMessagesAsync(StreamReader reader) {
    string? line;
    while ((line = await reader.ReadLineAsync()) != null) {
        if (string.IsNullOrWhiteSpace(line)) continue;
        yield return JsonSerializer.Deserialize<JsonRpcMessage>(line);
    }
}

// Writer
async Task WriteMessageAsync(Stream stdout, JsonRpcMessage msg) {
    var json = JsonSerializer.Serialize(msg);
    var bytes = Encoding.UTF8.GetBytes(json + "\n");
    await stdout.WriteAsync(bytes);
    await stdout.FlushAsync();
}
```

### Session ID Namespacing

```csharp
class Session {
    public string ProxySessionId { get; } = Guid.NewGuid().ToString();
    public string AgentSessionId { get; set; } = "";
    public string Workspace { get; }
    public Process AgentProcess { get; }
    public Task ReaderTask { get; set; }
}

class SessionManager {
    private readonly ConcurrentDictionary<string, Session> _sessions = new();

    // Lookup by proxy ID (from editor)
    public Session? GetByProxyId(string proxyId) =>
        _sessions.TryGetValue(proxyId, out var s) ? s : null;

    // Register session after agent responds
    public void Register(Session session) {
        _sessions[session.ProxySessionId] = session;
    }
}
```

### Workspace Resolution

```csharp
async Task<string> ResolveWorkspaceRootAsync(string cwd) {
    // Try git root first
    var result = await RunAsync("git", "-C", cwd, "rev-parse", "--show-toplevel");
    if (result.ExitCode == 0) {
        return result.Stdout.Trim();
    }

    // Walk up looking for .containai/config.toml (per src/lib/config.sh)
    var dir = new DirectoryInfo(cwd);
    while (dir != null) {
        var configPath = Path.Combine(dir.FullName, ".containai", "config.toml");
        if (File.Exists(configPath)) {
            return dir.FullName;
        }
        dir = dir.Parent;
    }

    // Fall back to cwd
    return cwd;
}
```

### Agent Process Spawning with Test Mode

```csharp
Process SpawnAgentProcess(string workspace, string agent) {
    // Check for direct spawn mode (testing)
    var directSpawn = Environment.GetEnvironmentVariable("CAI_ACP_DIRECT_SPAWN") == "1";

    if (directSpawn) {
        var psi = new ProcessStartInfo {
            FileName = agent,
            Arguments = "--acp",
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
        };
        return Process.Start(psi);
    }

    var containerPsi = new ProcessStartInfo {
        FileName = "cai",
        Arguments = $"exec --workspace \"{workspace}\" --quiet -- {agent} --acp",
        RedirectStandardInput = true,
        RedirectStandardOutput = true,
        RedirectStandardError = true,
        UseShellExecute = false,
        CreateNoWindow = true,
    };

    // Prevent stdout pollution from child cai processes
    containerPsi.Environment["CAI_NO_UPDATE_CHECK"] = "1";

    return Process.Start(containerPsi);
}
```

### Output Serialization

```csharp
class OutputWriter {
    private readonly Channel<JsonRpcMessage> _channel =
        Channel.CreateUnbounded<JsonRpcMessage>();
    private readonly Stream _stdout;

    public OutputWriter(Stream stdout) => _stdout = stdout;

    public async Task EnqueueAsync(JsonRpcMessage msg) {
        await _channel.Writer.WriteAsync(msg);
    }

    public async Task RunAsync(CancellationToken ct) {
        await foreach (var msg in _channel.Reader.ReadAllAsync(ct)) {
            var json = JsonSerializer.Serialize(msg);
            var bytes = Encoding.UTF8.GetBytes(json + "\n");
            await _stdout.WriteAsync(bytes, ct);
            await _stdout.FlushAsync(ct);
        }
    }
}
```

### Path-Aware MCP Translation (absolute paths only)

```csharp
string[] TranslateMcpArgs(string[] args, string hostWorkspace) {
    var containerPath = "/home/agent/workspace";
    var normalizedWorkspace = Path.GetFullPath(hostWorkspace).TrimEnd(Path.DirectorySeparatorChar);

    return args.Select(arg => {
        // Only translate absolute paths
        if (!Path.IsPathRooted(arg)) {
            return arg;
        }

        // Normalize the arg
        string normalizedArg;
        try {
            normalizedArg = Path.GetFullPath(arg).TrimEnd(Path.DirectorySeparatorChar);
        } catch {
            return arg; // Invalid path format
        }

        // Exact match
        if (normalizedArg == normalizedWorkspace) {
            return containerPath;
        }

        // Descendant match
        var prefix = normalizedWorkspace + Path.DirectorySeparatorChar;
        if (normalizedArg.StartsWith(prefix)) {
            var relative = normalizedArg.Substring(prefix.Length);
            return containerPath + "/" + relative.Replace(Path.DirectorySeparatorChar, '/');
        }

        // Not a workspace path
        return arg;
    }).ToArray();
}
```

### Session Lifecycle

```csharp
async Task HandleSessionEndAsync(string proxySessionId) {
    if (!_sessions.TryRemove(proxySessionId, out var session))
        return;

    // Forward session/end to agent
    var endReq = new JsonRpcMessage {
        Method = "session/end",
        Params = new { sessionId = session.AgentSessionId }
    };
    await WriteMessageAsync(session.AgentProcess.StandardInput.BaseStream, endReq);

    // Wait for reader to complete (agent may send final messages)
    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
    try {
        await session.ReaderTask.WaitAsync(cts.Token);
    } catch (OperationCanceledException) {
        // Timeout - proceed with kill
    }

    // Terminate
    try { session.AgentProcess.Kill(); } catch { }
    session.AgentProcess.Dispose();
}
```

## Dependencies
- **fn-10-vep.35** (workspace symlink strategy) - Container creates symlink from host path to mount point

## Done summary
TBD

## Evidence
- Commits:
- Tests:
- PRs:
