# fn-40-996.2 Integration Testing

## Description
Test the ACP proxy with comprehensive coverage of critical failure modes: NDJSON framing, stdout purity, concurrent session output serialization, session ID namespacing, workspace resolution, and proper routing.

## Acceptance
- [ ] Mock ACP server executable created for testing (bash script, no extra toolchain)
- [ ] Test: NDJSON framing works correctly (newline-delimited, not Content-Length)
- [ ] Test: stdout purity (no diagnostic output leaks, even with verbose/update-check code paths)
- [ ] Test: Proxy responds to `initialize` correctly
- [ ] Test: Single session works (session/new → session/prompt → response)
- [ ] Test: Multiple simultaneous sessions to different workspaces
- [ ] Test: Concurrent session output remains valid NDJSON (no byte interleaving)
- [ ] Test: Session ID namespacing prevents collisions
- [ ] Test: Session routing by proxySessionId
- [ ] Test: Workspace resolution normalizes subdirectories to root
- [ ] Test: MCP path translation (path-aware, only absolute paths)
- [ ] Test: Session cleanup on session/end
- [ ] Test: Stdin EOF triggers graceful shutdown
- [ ] Tests run in CI

## Implementation Notes

### Mock ACP Server (Bash - no extra toolchain)

Create a minimal ACP-compatible server for testing using bash (consistent with repo conventions):

```bash
#!/usr/bin/env bash
# tests/integration/mock-acp-server
# Mock ACP server for testing - NDJSON protocol

set -euo pipefail

session_counter=0

while IFS= read -r line; do
    [[ -z "$line" ]] && continue

    method=$(echo "$line" | jq -r '.method // empty')
    id=$(echo "$line" | jq -r '.id // empty')

    case "$method" in
        initialize)
            printf '{"jsonrpc":"2.0","id":"%s","result":{"protocolVersion":"2025-01-01","capabilities":{}}}\n' "$id"
            ;;
        session/new)
            ((session_counter++)) || true
            printf '{"jsonrpc":"2.0","id":"%s","result":{"sessionId":"agent-session-%d"}}\n' "$id" "$session_counter"
            ;;
        session/prompt)
            session_id=$(echo "$line" | jq -r '.params.sessionId // empty')
            message=$(echo "$line" | jq -r '.params.message // empty')
            printf '{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"%s","message":"Echo: %s"}}\n' "$session_id" "$message"
            ;;
        session/end)
            # Acknowledge silently
            ;;
    esac
done
```

Make executable: `chmod +x tests/integration/mock-acp-server`

### Test Structure
```
tests/integration/
├── test-acp-proxy.sh           # Main test runner
├── mock-acp-server             # Bash mock server (no build needed)
└── helpers/
    └── acp-utils.sh            # NDJSON helpers
```

### Test Mode Environment

Tests use direct spawn mode to bypass containers:

```bash
export CAI_ACP_TEST_MODE=1        # Allow mock-agent
export CAI_ACP_DIRECT_SPAWN=1     # Spawn mock directly, no cai exec
export PATH="./tests/integration:$PATH"  # mock-acp-server in PATH
```

### Stdout Purity Test

```bash
test_stdout_purity() {
    export CAI_ACP_TEST_MODE=1
    export CAI_ACP_DIRECT_SPAWN=1
    export PATH="./tests/integration:$PATH"

    # Capture ALL stdout from proxy initialization (with verbose enabled)
    local output
    output=$(printf '{"jsonrpc":"2.0","id":"1","method":"initialize","params":{"protocolVersion":"2025-01-01"}}\n' | \
        CONTAINAI_VERBOSE=1 timeout 10 cai --acp mock-acp-server 2>/dev/null | head -1)

    # Must be valid JSON
    if ! echo "$output" | jq -e . >/dev/null 2>&1; then
        echo "FAIL: stdout contains non-JSON content: $output"
        return 1
    fi

    # Must be our response
    if ! echo "$output" | jq -e '.result.protocolVersion' >/dev/null 2>&1; then
        echo "FAIL: expected initialize response, got: $output"
        return 1
    fi

    echo "PASS: stdout purity"
}
```

### NDJSON Framing Test

```bash
test_ndjson_framing() {
    export CAI_ACP_TEST_MODE=1
    export CAI_ACP_DIRECT_SPAWN=1
    export PATH="./tests/integration:$PATH"

    coproc PROXY { cai --acp mock-acp-server 2>/dev/null; }

    # Send initialize (single line)
    printf '{"jsonrpc":"2.0","id":"1","method":"initialize","params":{"protocolVersion":"2025-01-01"}}\n' >&${PROXY[1]}

    # Read response - must be single line, valid JSON
    read -t 5 response <&${PROXY[0]}

    # Validate it's complete JSON on one line
    if ! echo "$response" | jq -e . >/dev/null 2>&1; then
        echo "FAIL: response is not valid JSON: $response"
        kill $PROXY_PID 2>/dev/null
        return 1
    fi

    # Validate no Content-Length header pattern
    if echo "$response" | grep -q "Content-Length"; then
        echo "FAIL: response contains Content-Length header (should be NDJSON)"
        kill $PROXY_PID 2>/dev/null
        return 1
    fi

    kill $PROXY_PID 2>/dev/null
    echo "PASS: NDJSON framing"
}
```

### Concurrent Sessions Output Test

```bash
test_concurrent_output_serialization() {
    export CAI_ACP_TEST_MODE=1
    export CAI_ACP_DIRECT_SPAWN=1
    export PATH="./tests/integration:$PATH"

    local ws1=$(mktemp -d)
    local ws2=$(mktemp -d)

    coproc PROXY { cai --acp mock-acp-server 2>/dev/null; }

    # Initialize
    printf '{"jsonrpc":"2.0","id":"1","method":"initialize","params":{"protocolVersion":"2025-01-01"}}\n' >&${PROXY[1]}
    read -t 5 response <&${PROXY[0]}

    # Create two sessions
    printf '{"jsonrpc":"2.0","id":"2","method":"session/new","params":{"cwd":"%s"}}\n' "$ws1" >&${PROXY[1]}
    read -t 10 response <&${PROXY[0]}
    local s1=$(echo "$response" | jq -r '.result.sessionId')

    printf '{"jsonrpc":"2.0","id":"3","method":"session/new","params":{"cwd":"%s"}}\n' "$ws2" >&${PROXY[1]}
    read -t 10 response <&${PROXY[0]}
    local s2=$(echo "$response" | jq -r '.result.sessionId')

    # Send prompts rapidly to both sessions
    for i in {1..10}; do
        printf '{"jsonrpc":"2.0","id":"p%d-1","method":"session/prompt","params":{"sessionId":"%s","message":"msg%d"}}\n' "$i" "$s1" "$i" >&${PROXY[1]}
        printf '{"jsonrpc":"2.0","id":"p%d-2","method":"session/prompt","params":{"sessionId":"%s","message":"msg%d"}}\n' "$i" "$s2" "$i" >&${PROXY[1]}
    done

    # Read all responses and validate each is complete JSON
    local all_valid=true
    for i in {1..20}; do
        read -t 5 response <&${PROXY[0]} || break
        if ! echo "$response" | jq -e . >/dev/null 2>&1; then
            echo "FAIL: response $i is not valid JSON (interleaving?): $response"
            all_valid=false
            break
        fi
    done

    kill $PROXY_PID 2>/dev/null
    rm -rf "$ws1" "$ws2"

    if $all_valid; then
        echo "PASS: concurrent output serialization"
    else
        return 1
    fi
}
```

### Session ID Namespacing Test

```bash
test_session_id_namespacing() {
    export CAI_ACP_TEST_MODE=1
    export CAI_ACP_DIRECT_SPAWN=1
    export PATH="./tests/integration:$PATH"

    local ws1=$(mktemp -d)
    local ws2=$(mktemp -d)

    coproc PROXY { cai --acp mock-acp-server 2>/dev/null; }

    # Initialize
    printf '{"jsonrpc":"2.0","id":"1","method":"initialize","params":{}}\n' >&${PROXY[1]}
    read -t 5 response <&${PROXY[0]}

    # Create two sessions (mock returns sequential IDs like agent-session-1, agent-session-2)
    printf '{"jsonrpc":"2.0","id":"2","method":"session/new","params":{"cwd":"%s"}}\n' "$ws1" >&${PROXY[1]}
    read -t 10 response <&${PROXY[0]}
    local s1=$(echo "$response" | jq -r '.result.sessionId')

    printf '{"jsonrpc":"2.0","id":"3","method":"session/new","params":{"cwd":"%s"}}\n' "$ws2" >&${PROXY[1]}
    read -t 10 response <&${PROXY[0]}
    local s2=$(echo "$response" | jq -r '.result.sessionId')

    # Session IDs must be different (proxy namespaces them)
    if [[ "$s1" == "$s2" ]]; then
        echo "FAIL: session IDs are identical (no namespacing): $s1 == $s2"
        kill $PROXY_PID 2>/dev/null
        return 1
    fi

    # Session IDs should be UUIDs (proxy-generated), not "agent-session-N"
    if [[ "$s1" == agent-session-* ]]; then
        echo "FAIL: session ID is raw agent ID (not namespaced): $s1"
        kill $PROXY_PID 2>/dev/null
        return 1
    fi

    kill $PROXY_PID 2>/dev/null
    rm -rf "$ws1" "$ws2"
    echo "PASS: session ID namespacing"
}
```

### Workspace Resolution Test

```bash
test_workspace_resolution() {
    export CAI_ACP_TEST_MODE=1
    export CAI_ACP_DIRECT_SPAWN=1
    export PATH="./tests/integration:$PATH"

    local git_root=$(mktemp -d)
    local subdir="$git_root/src/components"

    # Initialize git repo
    git -C "$git_root" init >/dev/null 2>&1
    mkdir -p "$subdir"

    coproc PROXY { cai --acp mock-acp-server 2>/dev/null; }

    # Initialize
    printf '{"jsonrpc":"2.0","id":"1","method":"initialize","params":{}}\n' >&${PROXY[1]}
    read -t 5 response <&${PROXY[0]}

    # Create session with subdirectory as cwd
    printf '{"jsonrpc":"2.0","id":"2","method":"session/new","params":{"cwd":"%s"}}\n' "$subdir" >&${PROXY[1]}
    read -t 10 response <&${PROXY[0]}
    local s1=$(echo "$response" | jq -r '.result.sessionId')

    # Create session with git root as cwd
    printf '{"jsonrpc":"2.0","id":"3","method":"session/new","params":{"cwd":"%s"}}\n' "$git_root" >&${PROXY[1]}
    read -t 10 response <&${PROXY[0]}
    local s2=$(echo "$response" | jq -r '.result.sessionId')

    # Both should map to same container/agent (in direct spawn mode,
    # they share the same mock process, so we verify via workspace routing)

    kill $PROXY_PID 2>/dev/null
    rm -rf "$git_root"
    echo "PASS: workspace resolution (subdirectory mapped to git root)"
}
```

### CI Integration

```yaml
# .github/workflows/test.yml
- name: Build ACP Proxy
  run: |
    cd src/acp-proxy
    dotnet publish -r linux-x64 -c Release -p:PublishAot=true
    # Install to src/bin/ directory (binary location per spec)
    mkdir -p ../bin
    cp bin/Release/net10.0/linux-x64/publish/acp-proxy ../bin/acp-proxy

- name: ACP Integration Tests
  env:
    CAI_ACP_TEST_MODE: "1"
    CAI_ACP_DIRECT_SPAWN: "1"
  run: |
    chmod +x ./tests/integration/mock-acp-server
    export PATH="./tests/integration:$PATH"
    ./tests/integration/test-acp-proxy.sh
```

## Dependencies
- fn-40-996.1 (ACP Proxy)

## Done summary
TBD

## Evidence
- Commits:
- Tests:
- PRs:
