# fn-13-1c7.3 Evaluate CLI wrapping approach

## Description
Evaluate using @devcontainers/cli as the parsing layer, filtering its output before container creation. Analyze feasibility, security implications, and implementation complexity.

**Size:** M
**Files:** Output to `.flow/research/fn-13-1c7/option-cli-wrapping.md`

## Approach

1. **Evaluate CLI inside Sysbox container first** (preferred - no host Node dependency)
   - Can CLI run inside the system container?
   - Does it work with DinD?
2. Analyze `devcontainer read-configuration` output format
3. Determine which security-sensitive fields appear in output
4. Prototype filtering the output (conceptual, not implementation)
5. **Document build handling explicitly**:
   - Where does image build execute? (host daemon vs DinD inside Sysbox)
   - How to enforce feature allowlist/digest pinning?
   - What's exposed during build (network, .git, tokens)?
6. Identify limitations:
   - Can we intercept before Docker commands run?
   - Does the CLI respect filtered config or re-read original?
   - Node.js dependency implications for shell-based ContainAI
7. Document pros/cons vs direct parsing

## Key context

Key CLI commands to investigate:
- `devcontainer read-configuration` - parses and merges config
- `devcontainer up` - creates container (may be hard to intercept)
- `devcontainer run-user-commands` - executes lifecycle hooks
- `devcontainer exec` - runs commands in container

**Prefer evaluating "CLI inside Sysbox container" first** to avoid host Node.js dependency. Host installation is optional/fallback.

## Acceptance
- [ ] CLI-inside-Sysbox feasibility assessed first
- [ ] CLI output format documented
- [ ] Security-sensitive fields in output identified
- [ ] Filtering feasibility assessed
- [ ] **Build handling documented**: where builds run, feature control, supply-chain
- [ ] Node.js dependency implications documented
- [ ] Pros/cons table vs alternatives
- [ ] Clear recommendation on viability

## Done summary
TBD

## Evidence
- Commits:
- Tests:
- PRs:
