{
  "created_at": "2026-02-02T11:02:35.887404Z",
  "epic": {
    "data": {
      "branch_name": "fn-40-996",
      "created_at": "2026-01-29T09:40:50.965174Z",
      "depends_on_epics": [
        "fn-41-9xt",
        "fn-34-fk5",
        "fn-32-2mq",
        "fn-43-container-network-security-private"
      ],
      "id": "fn-40-996",
      "next_task": 1,
      "plan_review_status": "unknown",
      "plan_reviewed_at": null,
      "spec_path": ".flow/specs/fn-40-996.md",
      "status": "open",
      "title": "Agent Client Protocol (ACP) Integration",
      "updated_at": "2026-01-30T04:34:36.179029Z"
    },
    "spec": "# Epic: Agent Client Protocol (ACP) Integration\n\n## Summary\n\nAdd `cai --acp <agent>` command that editors configure as their ACP executable. This is a terminating proxy that:\n1. Handles ACP handshake with the editor\n2. Supports multiple simultaneous sessions (each with own container/agent)\n3. Routes each session to the appropriate container based on `cwd`\n4. Passes MCP server config through to the agent (agent handles MCP)\n\n## Understanding the Protocol Stack\n\n```mermaid\nflowchart TB\n    subgraph Editor[\"Editor (Zed, VS Code, Cursor)\"]\n        UI[User Interface]\n        ACPClient[ACP Client]\n        MCPConfig[MCP Server Config]\n    end\n\n    subgraph ContainAI[\"cai --acp claude\"]\n        Proxy[ACP Terminating Proxy]\n        Sessions[(Session Table)]\n    end\n\n    subgraph Container[\"Container (per workspace)\"]\n        Agent[claude / codex / gemini]\n        subgraph MCPClients[\"Agent's MCP Clients\"]\n            MCP1[MCP Client 1]\n            MCP2[MCP Client 2]\n        end\n    end\n\n    subgraph MCPServers[\"MCP Servers\"]\n        StdioMCP[Stdio MCP<br/>runs in container]\n        RemoteMCP[HTTP/SSE MCP<br/>remote service]\n    end\n\n    UI --> ACPClient\n    ACPClient -->|\"ACP over stdio\"| Proxy\n    MCPConfig -->|\"passed in session/new\"| Proxy\n    Proxy --> Sessions\n    Proxy -->|\"ACP over SSH\"| Agent\n    Agent --> MCPClients\n    MCP1 -->|\"stdio\"| StdioMCP\n    MCP2 -->|\"HTTP/SSE\"| RemoteMCP\n```\n\n### Protocol Roles\n\n| Component             | Role                  | Protocol                                |\n|-----------------------|-----------------------|-----------------------------------------|\n| Editor                | ACP Client            | Sends prompts, receives updates         |\n| cai --acp             | ACP Proxy             | Routes sessions to containers           |\n| Agent (claude, codex) | ACP Server + MCP Host | Handles prompts, spawns/connects to MCP |\n| MCP Servers           | MCP Servers           | Provide tools, resources, context       |\n\n**Key insight**: The **agent is the MCP client**. It spawns stdio MCP servers and connects to HTTP/SSE servers. We just pass the config through.\n\n## MCP Server Handling\n\n### How It Works\n\n1. Editor passes `mcpServers` config in `session/new`\n2. We forward config to agent in container\n3. Agent spawns/connects to MCP servers\n4. For stdio servers: agent spawns them **in the container**\n5. For HTTP/SSE servers: agent connects **from the container**\n\n### Implications for Containerized Agents\n\n| MCP Type  | How It Works                      | Requirements                                            |\n|-----------|-----------------------------------|---------------------------------------------------------|\n| **Stdio** | Agent spawns process in container | Package must be installed in container (npm, pip, etc.) |\n| **HTTP**  | Agent connects from container     | Server reachable from container                         |\n| **SSE**   | Agent connects from container     | Server reachable from container                         |\n\n### Container Requirements\n\nFor stdio MCP servers to work, their packages need to be in the container:\n```bash\n# Example: filesystem MCP server\nnpm install -g @modelcontextprotocol/server-filesystem\n\n# Example: other MCP servers\nnpm install -g @mcp/fetch @mcp/postgres\n```\n\nFor HTTP/SSE servers to localhost on host:\n```bash\n# Container needs host.docker.internal\ndocker run --add-host=host.docker.internal:host-gateway ...\n```\n\n### What We Pass Through\n\n```json\n// Editor sends:\n{\n  \"method\": \"session/new\",\n  \"params\": {\n    \"cwd\": \"/home/user/project\",\n    \"mcpServers\": [\n      {\"type\": \"stdio\", \"name\": \"fs\", \"command\": \"npx\", \"args\": [\"@mcp/filesystem\", \"/home/user/project\"]},\n      {\"type\": \"sse\", \"name\": \"github\", \"url\": \"https://mcp.github.com/sse\"}\n    ]\n  }\n}\n\n// We forward to agent (with path translation):\n{\n  \"method\": \"session/new\",\n  \"params\": {\n    \"cwd\": \"/home/user/project\",  // symlink handles this\n    \"mcpServers\": [\n      {\"type\": \"stdio\", \"name\": \"fs\", \"command\": \"npx\", \"args\": [\"@mcp/filesystem\", \"/home/agent/workspace\"]},\n      {\"type\": \"sse\", \"name\": \"github\", \"url\": \"https://mcp.github.com/sse\"}\n    ]\n  }\n}\n```\n\nNote: We may need to translate paths in MCP server args (workspace path \u2192 container path).\n\n## Multiple Sessions\n\nACP supports multiple simultaneous sessions. Each `session/new` can target a different workspace.\n\n### Session Flow\n\n```mermaid\nsequenceDiagram\n    participant Editor\n    participant Proxy as cai --acp claude\n    participant ContainerA as Container A\n    participant ContainerB as Container B\n\n    Editor->>Proxy: initialize\n    Proxy->>Editor: capabilities\n\n    Editor->>Proxy: session/new {cwd: \"/proj/a\", mcpServers: [...]}\n    Proxy->>ContainerA: Find/create, SSH, initialize agent\n    Proxy->>ContainerA: session/new (with mcpServers)\n    ContainerA->>Proxy: {sessionId: \"s1\"}\n    Proxy->>Editor: {sessionId: \"s1\"}\n\n    Editor->>Proxy: session/new {cwd: \"/proj/b\", mcpServers: [...]}\n    Proxy->>ContainerB: Find/create, SSH, initialize agent\n    Proxy->>ContainerB: session/new (with mcpServers)\n    ContainerB->>Proxy: {sessionId: \"s2\"}\n    Proxy->>Editor: {sessionId: \"s2\"}\n\n    par Session s1\n        Editor->>Proxy: session/prompt {sessionId: \"s1\", ...}\n        Proxy->>ContainerA: forward\n        ContainerA->>Proxy: session/update\n        Proxy->>Editor: forward\n    and Session s2\n        Editor->>Proxy: session/prompt {sessionId: \"s2\", ...}\n        Proxy->>ContainerB: forward\n        ContainerB->>Proxy: session/update\n        Proxy->>Editor: forward\n    end\n```\n\n### Session Table\n\n```\nsessionId -> {\n    workspace: \"/home/user/project\",\n    container: \"containai-project-abc\",\n    agentStdio: SshConnection,\n}\n```\n\n## CLI Interface\n\n```bash\n# Editor configures:\ncai --acp <agent>\n\n# Examples:\ncai --acp claude\ncai --acp codex\ncai --acp gemini\n```\n\n## Implementation\n\n### Language Choice\n\nC# (.NET 10 Native AOT trimmed) or Rust. Need:\n- Async I/O for concurrent sessions\n- JSON-RPC parsing\n- Process/SSH management\n\n### Core Components\n\n```\nsrc/acp-proxy/\n\u251c\u2500\u2500 Program.cs           # Entry point\n\u251c\u2500\u2500 JsonRpc.cs           # JSON-RPC parsing\n\u251c\u2500\u2500 AcpMessages.cs       # ACP message types\n\u251c\u2500\u2500 SessionManager.cs    # Multi-session tracking\n\u251c\u2500\u2500 ContainerManager.cs  # Find/create containers\n\u2514\u2500\u2500 PathTranslator.cs    # Host \u2194 container paths\n```\n\n### Message Router\n\n```csharp\nasync Task RouteAsync(JsonRpcMessage msg) {\n    switch (msg.Method) {\n        case \"initialize\":\n            // Respond with proxy capabilities\n            // Cache for forwarding to agents later\n            break;\n\n        case \"session/new\":\n            // Extract cwd, mcpServers\n            // Translate paths in mcpServers args\n            // Find/create container\n            // Connect to agent, initialize, create session\n            // Track session in table\n            break;\n\n        case \"session/prompt\":\n        case \"session/end\":\n            // Look up session by sessionId\n            // Forward to appropriate container\n            break;\n    }\n}\n```\n\n### Path Translation for MCP\n\nMCP server configs may contain host paths that need translation:\n\n```csharp\nMcpServer[] TranslateMcpPaths(McpServer[] servers, string hostWorkspace) {\n    return servers.Select(s => {\n        if (s.Type != \"stdio\" || s.Args == null) return s;\n\n        // Replace host workspace path with container path\n        var translatedArgs = s.Args.Select(arg =>\n            arg.Replace(hostWorkspace, \"/home/agent/workspace\")\n        ).ToArray();\n\n        return s with { Args = translatedArgs };\n    }).ToArray();\n}\n```\n\n## Path Translation\n\nContainer has symlink from host path to mount point (fn-10-vep.35):\n```\n/home/user/project -> /home/agent/workspace\n```\n\nFor `cwd`: Forward as-is, symlink handles it.\n\nFor MCP server args: May need explicit translation if they reference the workspace.\n\n## Editor Configuration\n\n### Zed\n```json\n{\n  \"agent_servers\": {\n    \"claude-sandbox\": {\n      \"type\": \"custom\",\n      \"command\": \"cai\",\n      \"args\": [\"--acp\", \"claude\"]\n    }\n  }\n}\n```\n\n### VS Code\n```json\n{\n  \"acp.executable\": \"cai\",\n  \"acp.args\": [\"--acp\", \"claude\"]\n}\n```\n\n## Acceptance Criteria\n\n1. [ ] `cai --acp claude` handles ACP protocol\n2. [ ] Responds to `initialize`\n3. [ ] Supports multiple simultaneous sessions\n4. [ ] Routes messages by `sessionId`\n5. [ ] Passes `mcpServers` config to agent (with path translation)\n6. [ ] Agent successfully uses stdio MCP servers (if installed in container)\n7. [ ] Agent successfully uses HTTP/SSE MCP servers\n8. [ ] Sessions cleaned up properly on `session/end`\n9. [ ] Works with Zed's ACP configuration\n\n## Out of Scope\n\n- HTTP/WebSocket transport for ACP (only stdio)\n- Installing MCP server packages in container (separate concern)\n- Host-only MCP servers that can't run in container\n\n## References\n\n- [ACP Spec](https://agentclientprotocol.com)\n- [ACP Architecture](https://agentclientprotocol.com/overview/architecture)\n- [MCP Introduction](https://modelcontextprotocol.io/introduction)\n- [MCP Architecture](https://modelcontextprotocol.io/docs/learn/architecture)\n- [Zed External Agents](https://zed.dev/docs/ai/external-agents)\n- [claude-code-acp](https://github.com/zed-industries/claude-code-acp)\n- [Codex MCP](https://developers.openai.com/codex/mcp/)\n"
  },
  "epic_id": "fn-40-996",
  "schema_version": 2,
  "tasks": [
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-01-29T10:53:19.466311Z",
        "depends_on": [],
        "epic": "fn-40-996",
        "id": "fn-40-996.1",
        "priority": null,
        "spec_path": ".flow/tasks/fn-40-996.1.md",
        "status": "todo",
        "title": "Build ACP Terminating Proxy",
        "updated_at": "2026-01-29T10:53:19.466323Z"
      },
      "id": "fn-40-996.1",
      "runtime": null,
      "spec": "# fn-40-996.1 Build ACP Terminating Proxy\n\n## Description\nBuild a native binary that acts as a terminating ACP proxy with multi-session support. It handles the ACP handshake, tracks multiple sessions, routes messages by sessionId, and passes MCP server config through to agents (with path translation).\n\n## Acceptance\n- [ ] Native binary compiles (C# .NET 10 Native AOT or Rust)\n- [ ] Handles `initialize` request, responds with proxy capabilities\n- [ ] Handles multiple `session/new` requests (multi-session)\n- [ ] Translates paths in `mcpServers` args (host \u2192 container)\n- [ ] Routes `session/prompt`, `session/end` by sessionId\n- [ ] Forwards agent responses/notifications back to editor\n- [ ] Clean session cleanup on `session/end`\n- [ ] Clean exit when all sessions end or stdin closes\n\n## Implementation Notes\n\n### Core Flow\n\n```csharp\nasync Task RunAsync() {\n    // 1. Handle initialize (cache for later)\n    var initReq = await ReadRequestAsync(stdin);\n    _cachedInit = initReq;\n    await WriteResponseAsync(stdout, MakeInitResponse(initReq.Id));\n\n    // 2. Main message loop\n    while (true) {\n        var msg = await ReadRequestAsync(stdin);\n\n        switch (msg.Method) {\n            case \"session/new\":\n                await HandleSessionNewAsync(msg);\n                break;\n\n            case \"session/prompt\":\n            case \"session/end\":\n                await RouteToSessionAsync(msg);\n                break;\n\n            default:\n                // Forward or handle other methods\n                break;\n        }\n    }\n}\n```\n\n### Session Manager\n\n```csharp\nclass Session {\n    string Id { get; }\n    string Workspace { get; }\n    string Container { get; }\n    Process SshProcess { get; }\n    Stream AgentStdin { get; }\n    Stream AgentStdout { get; }\n}\n\nclass SessionManager {\n    ConcurrentDictionary<string, Session> _sessions = new();\n\n    async Task<Session> CreateSessionAsync(SessionNewParams params, string agent) {\n        var workspace = params.Cwd;\n\n        // Find/create container\n        var container = await _containerMgr.EnsureContainerAsync(workspace);\n\n        // Connect to agent via SSH\n        var ssh = await ConnectSshAsync(container, $\"{agent} --acp\");\n\n        // Initialize agent\n        await WriteRequestAsync(ssh.Stdin, _cachedInit);\n        await ReadResponseAsync(ssh.Stdout);\n\n        // Translate MCP paths and create session\n        var translatedParams = TranslateMcpPaths(params, workspace);\n        await WriteRequestAsync(ssh.Stdin, MakeSessionNew(translatedParams));\n        var response = await ReadResponseAsync(ssh.Stdout);\n\n        var session = new Session {\n            Id = response.SessionId,\n            Workspace = workspace,\n            Container = container,\n            SshProcess = ssh.Process,\n            AgentStdin = ssh.Stdin,\n            AgentStdout = ssh.Stdout,\n        };\n\n        _sessions[session.Id] = session;\n\n        // Start reading agent output in background\n        _ = Task.Run(() => ForwardAgentOutputAsync(session));\n\n        return session;\n    }\n}\n```\n\n### Path Translation for MCP\n\n```csharp\nSessionNewParams TranslateMcpPaths(SessionNewParams params, string hostWorkspace) {\n    if (params.McpServers == null) return params;\n\n    var translated = params.McpServers.Select(server => {\n        if (server.Type != \"stdio\" || server.Args == null)\n            return server;\n\n        // Replace host workspace with container path\n        var newArgs = server.Args.Select(arg =>\n            arg.Replace(hostWorkspace, \"/home/agent/workspace\")\n        ).ToArray();\n\n        return server with { Args = newArgs };\n    }).ToArray();\n\n    return params with { McpServers = translated };\n}\n```\n\n### Container Manager\n\n```csharp\nasync Task<string> EnsureContainerAsync(string workspace) {\n    // Check for existing container\n    var result = await RunAsync(\"docker\", \"ps\", \"-q\",\n        \"--filter\", $\"label=containai.workspace={workspace}\");\n\n    if (!string.IsNullOrEmpty(result.Stdout.Trim()))\n        return result.Stdout.Trim();\n\n    // Create new container with host.docker.internal for MCP HTTP servers\n    result = await RunAsync(\"cai\", \"shell\", \"--detach\",\n        \"--mount\", $\"{workspace}:/home/agent/workspace\",\n        \"--label\", $\"containai.workspace={workspace}\");\n\n    return result.Stdout.Trim();\n}\n```\n\n### Agent Output Forwarding\n\n```csharp\nasync Task ForwardAgentOutputAsync(Session session) {\n    await foreach (var msg in ReadMessagesAsync(session.AgentStdout)) {\n        // Forward all agent messages to editor\n        await WriteMessageAsync(stdout, msg);\n\n        // If session ended, clean up\n        if (msg.Method == \"session/end\") {\n            _sessions.TryRemove(session.Id, out _);\n            session.SshProcess.Kill();\n        }\n    }\n}\n```\n\n## Dependencies\n- **fn-10-vep.35** (workspace symlink strategy) - Container creates symlink from host path to mount point.\n\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-01-29T10:53:19.531804Z",
        "depends_on": [
          "fn-40-996.1"
        ],
        "epic": "fn-40-996",
        "id": "fn-40-996.2",
        "priority": null,
        "spec_path": ".flow/tasks/fn-40-996.2.md",
        "status": "todo",
        "title": "Integration testing",
        "updated_at": "2026-01-29T10:53:19.531815Z"
      },
      "id": "fn-40-996.2",
      "runtime": null,
      "spec": "# fn-40-996.2 Integration Testing\n\n## Description\nTest the ACP proxy with multi-session support and MCP server passthrough.\n\n## Acceptance\n- [ ] Test: Proxy responds to `initialize` correctly\n- [ ] Test: Single session works (session/new \u2192 session/prompt \u2192 response)\n- [ ] Test: Multiple simultaneous sessions to different workspaces\n- [ ] Test: Session routing by sessionId\n- [ ] Test: MCP path translation (host path \u2192 container path)\n- [ ] Test: Stdio MCP server works in container (if installed)\n- [ ] Test: Session cleanup on session/end\n- [ ] Tests run in CI\n\n## Implementation Notes\n\n### Test Structure\n```\ntests/integration/\n\u251c\u2500\u2500 test-acp-proxy.sh           # Main test runner\n\u251c\u2500\u2500 test-acp-sessions.sh        # Multi-session tests\n\u2514\u2500\u2500 helpers/\n    \u251c\u2500\u2500 mock-acp-client.sh      # Simulates editor\n    \u2514\u2500\u2500 acp-utils.sh            # JSON-RPC helpers\n```\n\n### Initialize Test\n```bash\ntest_initialize() {\n    local response\n    response=$(printf '{\"jsonrpc\":\"2.0\",\"id\":\"1\",\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-01-01\"}}\\n' | \\\n        timeout 10 cai --acp mock-agent 2>/dev/null | head -1)\n\n    assert_contains \"$response\" '\"protocolVersion\"'\n    assert_contains \"$response\" '\"capabilities\"'\n}\n```\n\n### Single Session Test\n```bash\ntest_single_session() {\n    local workspace=$(mktemp -d)\n\n    # Start proxy with coprocess\n    coproc PROXY { cai --acp mock-agent; }\n\n    # Initialize\n    echo '{\"jsonrpc\":\"2.0\",\"id\":\"1\",\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-01-01\"}}' >&${PROXY[1]}\n    read -t 5 response <&${PROXY[0]}\n    assert_contains \"$response\" '\"protocolVersion\"'\n\n    # Create session\n    echo \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\\\"2\\\",\\\"method\\\":\\\"session/new\\\",\\\"params\\\":{\\\"cwd\\\":\\\"$workspace\\\",\\\"mcpServers\\\":[]}}\" >&${PROXY[1]}\n    read -t 10 response <&${PROXY[0]}\n    assert_contains \"$response\" '\"sessionId\"'\n\n    local session_id=$(echo \"$response\" | jq -r '.result.sessionId')\n\n    # Send prompt\n    echo \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\\\"3\\\",\\\"method\\\":\\\"session/prompt\\\",\\\"params\\\":{\\\"sessionId\\\":\\\"$session_id\\\",\\\"message\\\":\\\"test\\\"}}\" >&${PROXY[1]}\n\n    # Should get response/updates\n    read -t 10 response <&${PROXY[0]}\n    # Verify we got something back\n\n    # Cleanup\n    kill $PROXY_PID 2>/dev/null\n    docker rm -f $(docker ps -q --filter \"label=containai.workspace=$workspace\") 2>/dev/null\n    rm -rf \"$workspace\"\n}\n```\n\n### Multiple Sessions Test\n```bash\ntest_multiple_sessions() {\n    local ws1=$(mktemp -d)\n    local ws2=$(mktemp -d)\n\n    coproc PROXY { cai --acp mock-agent; }\n\n    # Initialize\n    echo '{\"jsonrpc\":\"2.0\",\"id\":\"1\",\"method\":\"initialize\",...}' >&${PROXY[1]}\n    read -t 5 response <&${PROXY[0]}\n\n    # Create session 1\n    echo \"{...\\\"cwd\\\":\\\"$ws1\\\"...}\" >&${PROXY[1]}\n    read -t 10 response <&${PROXY[0]}\n    local s1=$(echo \"$response\" | jq -r '.result.sessionId')\n\n    # Create session 2\n    echo \"{...\\\"cwd\\\":\\\"$ws2\\\"...}\" >&${PROXY[1]}\n    read -t 10 response <&${PROXY[0]}\n    local s2=$(echo \"$response\" | jq -r '.result.sessionId')\n\n    # Verify different containers\n    local c1=$(docker ps -q --filter \"label=containai.workspace=$ws1\")\n    local c2=$(docker ps -q --filter \"label=containai.workspace=$ws2\")\n    assert_not_equal \"$c1\" \"$c2\"\n\n    # Cleanup\n    kill $PROXY_PID 2>/dev/null\n    docker rm -f $c1 $c2 2>/dev/null\n    rm -rf \"$ws1\" \"$ws2\"\n}\n```\n\n### MCP Path Translation Test\n```bash\ntest_mcp_path_translation() {\n    local workspace=\"/home/testuser/project\"\n\n    # Mock the session/new with MCP servers containing host paths\n    local mcp_config='[{\"type\":\"stdio\",\"name\":\"fs\",\"command\":\"npx\",\"args\":[\"@mcp/fs\",\"'$workspace'\"]}]'\n\n    # Verify path gets translated to container path\n    # (This requires inspecting what gets sent to the agent)\n\n    # The MCP args should become /home/agent/workspace instead of /home/testuser/project\n}\n```\n\n### CI Integration\n```yaml\n# .github/workflows/test.yml\n- name: Build ACP Proxy\n  run: |\n    cd src/acp-proxy\n    dotnet publish -r linux-x64 -c Release -p:PublishAot=true\n\n- name: ACP Integration Tests\n  run: |\n    ./tests/integration/test-acp-proxy.sh\n    ./tests/integration/test-acp-sessions.sh\n```\n\n## Dependencies\n- fn-40-996.1 (ACP Proxy)\n\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-01-29T10:53:19.596809Z",
        "depends_on": [
          "fn-40-996.2"
        ],
        "epic": "fn-40-996",
        "id": "fn-40-996.3",
        "priority": null,
        "spec_path": ".flow/tasks/fn-40-996.3.md",
        "status": "todo",
        "title": "Documentation",
        "updated_at": "2026-01-29T10:53:19.596820Z"
      },
      "id": "fn-40-996.3",
      "runtime": null,
      "spec": "# fn-40-996.3 Documentation\n\n## Description\nDocument the ACP proxy including multi-session support and MCP server handling.\n\n## Acceptance\n- [ ] docs/acp.md with comprehensive usage guide\n- [ ] Editor setup guides (Zed, VS Code, Cursor)\n- [ ] MCP server explanation (what works, what doesn't)\n- [ ] Troubleshooting section\n\n## Implementation Notes\n\n### User Documentation\nCreate `docs/acp.md`:\n\n```markdown\n# ACP Integration\n\nContainAI supports the [Agent Client Protocol](https://agentclientprotocol.com) (ACP) for editor integration.\n\n## Quick Start\n\nConfigure your editor to use `cai --acp <agent>`:\n\n**Zed** (`~/.config/zed/settings.json`):\n```json\n{\n  \"agent_servers\": {\n    \"claude-sandbox\": {\n      \"type\": \"custom\",\n      \"command\": \"cai\",\n      \"args\": [\"--acp\", \"claude\"]\n    }\n  }\n}\n```\n\n**VS Code** (with ACP extension):\n```json\n{\n  \"acp.executable\": \"cai\",\n  \"acp.args\": [\"--acp\", \"claude\"]\n}\n```\n\n## How It Works\n\n```mermaid\nflowchart LR\n    Editor -->|ACP stdio| Proxy[cai --acp]\n    Proxy -->|SSH| Container\n    Container --> Agent[claude --acp]\n    Agent -->|MCP| MCPServers[MCP Servers]\n```\n\n1. Editor spawns `cai --acp claude`\n2. Editor sends `initialize`, then `session/new` with workspace and MCP config\n3. Proxy creates container for workspace, connects to agent\n4. Agent handles MCP servers (spawns stdio, connects to HTTP/SSE)\n5. All communication proxied through\n\n## Multiple Sessions\n\nOne proxy process can handle multiple editor sessions:\n- Each `session/new` can target a different workspace\n- Different workspaces use different containers\n- Messages routed by `sessionId`\n\n## MCP Servers\n\nMCP servers provide tools and context to the agent. The agent (not the proxy) manages MCP connections.\n\n### What Works\n\n| MCP Type | Works? | Notes |\n|----------|--------|-------|\n| HTTP/SSE | \u2705 Yes | Agent connects directly from container |\n| Stdio (in container) | \u2705 Yes | Package must be installed in container |\n| Stdio (host-only) | \u274c No | Can't spawn host processes from container |\n\n### Installing MCP Packages in Container\n\nFor stdio MCP servers to work, install their packages in the container image:\n\n```dockerfile\n# In Dockerfile.agents\nRUN npm install -g @modelcontextprotocol/server-filesystem \\\n                   @mcp/fetch \\\n                   @mcp/postgres\n```\n\nOr install at runtime:\n```bash\ncai shell\nnpm install -g @mcp/whatever\n```\n\n### HTTP/SSE to Localhost\n\nFor MCP servers running on your host machine:\n- Container uses `host.docker.internal` to reach host\n- Configure MCP URL as `http://host.docker.internal:PORT/...`\n\n## Path Handling\n\nYour local paths work transparently:\n```\n/home/user/project -> /home/agent/workspace (symlink in container)\n```\n\nMCP server args containing the workspace path are automatically translated.\n\n## Supported Agents\n\n| Agent | Command |\n|-------|---------|\n| Claude Code | `cai --acp claude` |\n| Codex | `cai --acp codex` |\n| Gemini CLI | `cai --acp gemini` |\n| Goose | `cai --acp goose` |\n\n## Troubleshooting\n\n### Agent not starting\n```bash\ncai shell\nwhich claude  # Verify agent installed\nclaude --help | grep -i acp  # Verify ACP support\n```\n\n### MCP server not found\n```bash\ncai shell\nwhich npx  # Verify npm available\nnpx @mcp/fetch --version  # Verify MCP package works\n```\n\n### Can't reach host services\n```bash\n# From container, verify host.docker.internal works\ncai shell\ncurl http://host.docker.internal:8080/\n```\n\n### Multiple sessions not routing\nCheck that each `session/new` returned a unique `sessionId`.\n```\n\n## Dependencies\n- fn-40-996.2 (Integration Testing)\n\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    }
  ]
}
