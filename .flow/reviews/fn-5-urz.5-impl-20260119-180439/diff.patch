diff --git a/.flow/tasks/fn-5-urz.5.json b/.flow/tasks/fn-5-urz.5.json
index eae14fb..f8b3cbe 100644
--- a/.flow/tasks/fn-5-urz.5.json
+++ b/.flow/tasks/fn-5-urz.5.json
@@ -1,7 +1,7 @@
 {
-  "assignee": null,
+  "assignee": "claire@novotny.org",
   "claim_note": "",
-  "claimed_at": null,
+  "claimed_at": "2026-01-19T18:00:56.859914Z",
   "created_at": "2026-01-18T23:55:51.588190Z",
   "depends_on": [
     "fn-5-urz.2"
@@ -10,7 +10,7 @@
   "id": "fn-5-urz.5",
   "priority": null,
   "spec_path": ".flow/tasks/fn-5-urz.5.md",
-  "status": "todo",
+  "status": "in_progress",
   "title": "ECI detection (uid_map + runtime check)",
-  "updated_at": "2026-01-18T23:57:42.136789Z"
+  "updated_at": "2026-01-19T18:00:56.859937Z"
 }
diff --git a/agent-sandbox/containai.sh b/agent-sandbox/containai.sh
index f65569c..65578a2 100644
--- a/agent-sandbox/containai.sh
+++ b/agent-sandbox/containai.sh
@@ -48,6 +48,7 @@ _containai_libs_exist() {
     [[ -f "$_CAI_SCRIPT_DIR/lib/core.sh" ]] && \
     [[ -f "$_CAI_SCRIPT_DIR/lib/platform.sh" ]] && \
     [[ -f "$_CAI_SCRIPT_DIR/lib/docker.sh" ]] && \
+    [[ -f "$_CAI_SCRIPT_DIR/lib/eci.sh" ]] && \
     [[ -f "$_CAI_SCRIPT_DIR/lib/config.sh" ]] && \
     [[ -f "$_CAI_SCRIPT_DIR/lib/container.sh" ]] && \
     [[ -f "$_CAI_SCRIPT_DIR/lib/import.sh" ]] && \
@@ -81,6 +82,11 @@ if ! source "$_CAI_SCRIPT_DIR/lib/docker.sh"; then
     return 1
 fi

+if ! source "$_CAI_SCRIPT_DIR/lib/eci.sh"; then
+    echo "[ERROR] Failed to source lib/eci.sh" >&2
+    return 1
+fi
+
 if ! source "$_CAI_SCRIPT_DIR/lib/config.sh"; then
     echo "[ERROR] Failed to source lib/config.sh" >&2
     return 1
diff --git a/agent-sandbox/lib/eci.sh b/agent-sandbox/lib/eci.sh
new file mode 100644
index 0000000..0d3e3e1
--- /dev/null
+++ b/agent-sandbox/lib/eci.sh
@@ -0,0 +1,310 @@
+#!/usr/bin/env bash
+# ==============================================================================
+# ContainAI ECI (Enhanced Container Isolation) Detection
+# ==============================================================================
+# This file must be sourced, not executed directly.
+#
+# Provides:
+#   _cai_eci_available()     - Check if ECI might be available (Docker Desktop 4.50+)
+#   _cai_eci_enabled()       - Check if ECI is actually enabled (uid_map + runtime check)
+#   _cai_eci_status()        - Get ECI status: "enabled", "available_not_enabled", "not_available"
+#
+# Detection methods per Docker documentation:
+#   1. uid_map check: docker run --rm alpine cat /proc/self/uid_map
+#      - ECI active: "0 100000 65536" (root mapped to unprivileged)
+#      - ECI inactive: "0 0 4294967295" (root is root)
+#   2. runtime check: docker inspect --format '{{.HostConfig.Runtime}}' <cid>
+#      - ECI active: "sysbox-runc"
+#      - ECI inactive: "runc" or empty
+#
+# Dependencies:
+#   - Requires lib/core.sh to be sourced first for logging functions
+#   - Requires lib/docker.sh to be sourced first for Docker availability checks
+#
+# Usage: source lib/eci.sh
+# ==============================================================================
+
+# Require bash first (before using BASH_SOURCE)
+if [[ -z "${BASH_VERSION:-}" ]]; then
+    echo "[ERROR] lib/eci.sh requires bash" >&2
+    return 1 2>/dev/null || exit 1
+fi
+
+# Detect direct execution (must be sourced, not executed)
+if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
+    echo "[ERROR] lib/eci.sh must be sourced, not executed directly" >&2
+    echo "Usage: source lib/eci.sh" >&2
+    exit 1
+fi
+
+# Guard against re-sourcing side effects
+if [[ -n "${_CAI_ECI_LOADED:-}" ]]; then
+    return 0
+fi
+_CAI_ECI_LOADED=1
+
+# ==============================================================================
+# ECI availability check
+# ==============================================================================
+
+# Check if ECI might be available (Docker Desktop 4.50+ with business subscription)
+# This checks prerequisites but cannot definitively detect subscription tier.
+# Returns: 0=potentially available (Docker Desktop 4.50+), 1=not available
+# Note: Even if this returns 0, ECI may not be enabled - use _cai_eci_enabled() to verify
+_cai_eci_available() {
+    # ECI requires Docker Desktop
+    local dd_version dd_rc
+    _cai_docker_desktop_version >/dev/null 2>&1 && dd_rc=0 || dd_rc=$?
+    if [[ $dd_rc -ne 0 ]]; then
+        # Not Docker Desktop - ECI not available
+        return 1
+    fi
+
+    # Capture version
+    dd_version=$(_cai_docker_desktop_version)
+
+    # Parse major.minor for comparison
+    local major minor
+    major="${dd_version%%.*}"
+    local rest="${dd_version#*.}"
+    minor="${rest%%.*}"
+
+    # ECI requires Docker Desktop 4.29+ (when ECI was introduced)
+    # https://docs.docker.com/enterprise/security/hardened-desktop/enhanced-container-isolation/
+    if [[ "$major" -lt 4 ]] || { [[ "$major" -eq 4 ]] && [[ "$minor" -lt 29 ]]; }; then
+        return 1
+    fi
+
+    # Docker Desktop version is sufficient for ECI to potentially be available
+    # Actual subscription tier (Business) cannot be detected programmatically
+    return 0
+}
+
+# ==============================================================================
+# ECI uid_map check (Method 1)
+# ==============================================================================
+
+# Check ECI status via uid_map in ephemeral container
+# Returns: 0=ECI active, 1=ECI not active or error
+# Outputs: Sets _CAI_ECI_UID_MAP_ERROR on failure with reason
+_cai_eci_check_uid_map() {
+    _CAI_ECI_UID_MAP_ERROR=""
+
+    if ! _cai_docker_daemon_available; then
+        _CAI_ECI_UID_MAP_ERROR="daemon_unavailable"
+        return 1
+    fi
+
+    # Run ephemeral container to check uid_map
+    # ECI maps root (uid 0) to unprivileged user (typically 100000+)
+    # Without ECI: "0 0 4294967295" (root is root)
+    # With ECI: "0 100000 65536" (root mapped to 100000)
+    local uid_map_output rc
+    uid_map_output=$(_cai_timeout 30 docker run --rm alpine cat /proc/self/uid_map 2>&1) && rc=0 || rc=$?
+
+    # Timeout
+    if [[ $rc -eq 124 ]]; then
+        _CAI_ECI_UID_MAP_ERROR="timeout"
+        return 1
+    fi
+
+    # Command failed
+    if [[ $rc -ne 0 ]]; then
+        _CAI_ECI_UID_MAP_ERROR="container_failed"
+        return 1
+    fi
+
+    # Parse uid_map output
+    # Format: "inside_uid outside_uid count"
+    # ECI active: first field is 0, second field is high (100000+)
+    # ECI inactive: first field is 0, second field is 0
+    local inside_uid outside_uid _count line
+    # Read first line (may have leading whitespace)
+    line=$(printf '%s' "$uid_map_output" | head -1)
+    # _count captures the third field but is unused (only need inside_uid and outside_uid)
+    if ! read -r inside_uid outside_uid _count <<< "$line"; then
+        _CAI_ECI_UID_MAP_ERROR="parse_failed"
+        return 1
+    fi
+
+    # Validate we got numeric values
+    if [[ ! "$inside_uid" =~ ^[0-9]+$ ]] || [[ ! "$outside_uid" =~ ^[0-9]+$ ]]; then
+        _CAI_ECI_UID_MAP_ERROR="parse_failed"
+        return 1
+    fi
+
+    # ECI detection: root (0) mapped to high uid (100000+)
+    # Docker's ECI uses userns starting at 100000
+    if [[ "$inside_uid" == "0" ]] && [[ "$outside_uid" -ge 100000 ]]; then
+        return 0
+    fi
+
+    # No user namespace remapping active
+    _CAI_ECI_UID_MAP_ERROR="not_remapped"
+    return 1
+}
+
+# ==============================================================================
+# ECI runtime check (Method 2)
+# ==============================================================================
+
+# Check ECI status via runtime inspection
+# Returns: 0=ECI active (sysbox-runc), 1=ECI not active or error
+# Outputs: Sets _CAI_ECI_RUNTIME_ERROR on failure with reason
+_cai_eci_check_runtime() {
+    _CAI_ECI_RUNTIME_ERROR=""
+
+    if ! _cai_docker_daemon_available; then
+        _CAI_ECI_RUNTIME_ERROR="daemon_unavailable"
+        return 1
+    fi
+
+    # Start ephemeral container (detached, short-lived)
+    local cid rc
+    cid=$(_cai_timeout 30 docker run -d --rm alpine sleep 10 2>&1) && rc=0 || rc=$?
+
+    # Timeout starting container
+    if [[ $rc -eq 124 ]]; then
+        _CAI_ECI_RUNTIME_ERROR="timeout_start"
+        return 1
+    fi
+
+    # Failed to start container
+    if [[ $rc -ne 0 ]]; then
+        _CAI_ECI_RUNTIME_ERROR="container_failed"
+        return 1
+    fi
+
+    # Validate we got a container ID (64 hex chars or short form 12 hex chars)
+    if [[ ! "$cid" =~ ^[a-f0-9]+$ ]]; then
+        _CAI_ECI_RUNTIME_ERROR="invalid_cid"
+        return 1
+    fi
+
+    # Inspect runtime
+    local runtime
+    runtime=$(_cai_timeout 10 docker inspect --format '{{.HostConfig.Runtime}}' "$cid" 2>&1) && rc=0 || rc=$?
+
+    # Always cleanup container (use timeout to avoid hanging)
+    _cai_timeout 10 docker stop "$cid" >/dev/null 2>&1 || true
+
+    # Timeout inspecting
+    if [[ $rc -eq 124 ]]; then
+        _CAI_ECI_RUNTIME_ERROR="timeout_inspect"
+        return 1
+    fi
+
+    # Inspect failed
+    if [[ $rc -ne 0 ]]; then
+        _CAI_ECI_RUNTIME_ERROR="inspect_failed"
+        return 1
+    fi
+
+    # Check runtime value
+    # ECI uses sysbox-runc
+    # Non-ECI uses "runc" or empty string (default runtime)
+    if [[ "$runtime" == "sysbox-runc" ]]; then
+        return 0
+    fi
+
+    _CAI_ECI_RUNTIME_ERROR="not_sysbox"
+    return 1
+}
+
+# ==============================================================================
+# Combined ECI enabled check
+# ==============================================================================
+
+# Check if ECI is enabled using both uid_map and runtime checks
+# Both methods must agree for "enabled" status (high confidence)
+# Returns: 0=ECI enabled, 1=ECI not enabled
+# Outputs: Sets _CAI_ECI_ENABLED_ERROR with detailed reason on failure
+_cai_eci_enabled() {
+    _CAI_ECI_ENABLED_ERROR=""
+
+    local uid_map_rc runtime_rc
+
+    # Run uid_map check
+    _cai_eci_check_uid_map && uid_map_rc=0 || uid_map_rc=$?
+
+    # Run runtime check
+    _cai_eci_check_runtime && runtime_rc=0 || runtime_rc=$?
+
+    # Both must pass for ECI to be considered enabled
+    if [[ $uid_map_rc -eq 0 ]] && [[ $runtime_rc -eq 0 ]]; then
+        return 0
+    fi
+
+    # Determine most useful error message
+    if [[ $uid_map_rc -ne 0 ]] && [[ $runtime_rc -ne 0 ]]; then
+        # Both failed - report uid_map error (typically more informative)
+        _CAI_ECI_ENABLED_ERROR="${_CAI_ECI_UID_MAP_ERROR:-unknown}"
+    elif [[ $uid_map_rc -ne 0 ]]; then
+        _CAI_ECI_ENABLED_ERROR="uid_map_${_CAI_ECI_UID_MAP_ERROR:-failed}"
+    else
+        _CAI_ECI_ENABLED_ERROR="runtime_${_CAI_ECI_RUNTIME_ERROR:-failed}"
+    fi
+
+    return 1
+}
+
+# ==============================================================================
+# ECI status summary
+# ==============================================================================
+
+# Get comprehensive ECI status
+# Outputs: One of: "enabled", "available_not_enabled", "not_available"
+# Returns: Always 0 (status is in output)
+_cai_eci_status() {
+    # Check if ECI is actually enabled
+    if _cai_eci_enabled; then
+        printf '%s' "enabled"
+        return 0
+    fi
+
+    # Check if ECI could be available (Docker Desktop 4.29+)
+    if _cai_eci_available; then
+        printf '%s' "available_not_enabled"
+        return 0
+    fi
+
+    printf '%s' "not_available"
+    return 0
+}
+
+# ==============================================================================
+# ECI status message helpers
+# ==============================================================================
+
+# Print human-readable ECI status message
+# Arguments: none (uses _cai_eci_status internally)
+# Outputs: Status message to stdout
+_cai_eci_status_message() {
+    local status
+    status=$(_cai_eci_status)
+
+    case "$status" in
+        enabled)
+            printf '%s\n' "ECI enabled"
+            ;;
+        available_not_enabled)
+            printf '%s\n' "ECI available but not enabled"
+            printf '%s\n' "  Enable ECI in Docker Desktop Settings > Security > Enhanced Container Isolation"
+            printf '%s\n' "  Requires Docker Business subscription"
+            ;;
+        not_available)
+            printf '%s\n' "ECI not available"
+            if ! _cai_docker_desktop_version >/dev/null 2>&1; then
+                printf '%s\n' "  ECI requires Docker Desktop 4.29+"
+                printf '%s\n' "  Current Docker is not Docker Desktop"
+            else
+                local dd_version
+                dd_version=$(_cai_docker_desktop_version)
+                printf '%s\n' "  ECI requires Docker Desktop 4.29+ with Business subscription"
+                printf '%s\n' "  Current version: $dd_version"
+            fi
+            ;;
+    esac
+}
+
+return 0
