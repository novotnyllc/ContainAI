# Research Devcontainer Support Options

## Overview

Investigate how ContainAI could support projects with `.devcontainer/devcontainer.json` configurations, launching them securely through `cai` instead of regular `docker run`. This is a **research epic** to explore options and produce recommendationsâ€”no implementation code.

**Goal**: Present 3-4 viable integration options with security analysis, tradeoffs, and recommendations.

**Non-goal**: Implementing devcontainer support (that's a follow-up epic).

## Scope

**In scope**:
- Deep analysis of devcontainer specification and security implications
- Evaluation of integration approaches (wrap CLI vs parse directly vs alternatives)
- Property-by-property security classification of devcontainer.json schema
- Analysis of real-world devcontainer usage patterns
- Recommendations for ContainAI's security model compatibility
- Documentation of dependencies and blockers
- Conflict matrix: devcontainer semantics vs ContainAI model

**Out of scope**:
- Writing implementation code
- Docker Compose multi-container support (may note as future work)
- VS Code Remote extension integration specifics

## Background

Devcontainers define reproducible development environments. However, they have significant security risks for sandboxing AI agents:

- **`initializeCommand`** runs on the HOST machine before container creation
- **`runArgs`** can include `--privileged`, arbitrary volume mounts
- **Features** execute `install.sh` as root during build
- **Lifecycle hooks** can exfiltrate mounted secrets

**Critical architectural consideration**: ContainAI's outer runtime is a long-lived Sysbox *system container* with SSH/systemd expectations. The workspace mounts to `/home/agent/workspace`, sshd runs, and the container has specific labels/ports. A typical devcontainer image won't have this shape. This means:

1. "Just run the devcontainer image via cai" is NOT a viable baseline without major architecture changes
2. **Primary path to evaluate**: Run devcontainer *inside* the Sysbox system container (DinD)
3. "Replace outer container with devcontainer image" is likely **L/XL** effort (needs SSH/systemd layer or different connection model)

**Threat model clarification**: Classification is primarily about *host boundary / privilege escalation / unexpected host-side execution*. Network exfiltration is an expected risk of running untrusted code in sandbox (per SECURITY.md), with WARN only for surprising *automatic* code execution (hooks/features).

## Key Questions to Answer

1. What is the minimum viable scope? Run ANY devcontainer securely, or a SUBSET of safe configs?
2. How to handle `initializeCommand`? Block, sandbox, warn, or require approval?
3. What about Features? Ignore, allowlist, or sandbox feature installation?
4. Should ContainAI parse devcontainer.json directly or wrap @devcontainers/cli?
5. How to resolve conflicts between devcontainer config and ContainAI's model? (See Conflict Matrix)

## Conflict Matrix (must cover in fn-13-1c7.7)

| Devcontainer Property | ContainAI Expectation | Conflict Type | Resolution Options |
|----------------------|----------------------|---------------|-------------------|
| `workspaceFolder`/`workspaceMount` | `/home/agent/workspace` | Path mapping | Remap, reject, or passthrough |
| `remoteUser`/`containerUser` | `agent` (uid 1000) | User model | Remap UID, or run as configured |
| `updateRemoteUserUID` | Agent user already configured | UID sync | Honor or ignore |
| `overrideCommand` | Systemd as PID 1 | Entrypoint | Run inside DinD, not outer |
| `forwardPorts`/`portsAttributes` | SSH on 2300-2500 range | Port model | Merge or reject conflicts |
| `containerEnv` | Env from .containai/env hierarchy | Env merge | Define precedence |
| Lifecycle hooks timing | SSH-based connection | Execution timing | Before/after SSH ready? |

## Integration Options to Evaluate

### Option A: CLI Wrapping with Filtering
Use `devcontainer read-configuration` to parse, filter dangerous properties, then launch **inside the Sysbox system container** via DinD.

**Build handling**: CLI builds image, but must specify *where* (host daemon vs DinD), feature allowlist, digest pinning.

### Option B: Direct JSON Parsing with DinD Launch
Parse devcontainer.json with jq/Python, build own container configuration, launch as nested container inside Sysbox.

**Build handling**: ContainAI controls build location (DinD preferred), can enforce supply-chain policies.

### Option C: DevPod-Style Provider
Abstract container creation behind a "provider" interface. ContainAI becomes a provider for DevPod.

**Build handling**: Delegated to DevPod's build system with ContainAI security policy overlay.

### Option D: Envbuilder-Style Daemonless
Build devcontainer images using Kaniko without Docker daemon. Strongest isolation but partial spec support.

**Build handling**: Kaniko builds in userspace, no daemon exposure, natural supply-chain control point.

### Option E: Hybrid (Recommended for Evaluation)
Use CLI for parsing only (`read-configuration`), apply security policy layer, then launch via ContainAI's DinD inside Sysbox.

**Build handling**: Build inside Sysbox's DinD (host is already sandboxed), feature allowlist enforced at policy layer.

## Security Classification Categories

For fn-13-1c7.1, use these operationally-defined categories:

| Category | Definition | Enforcement | Default Action in cai |
|----------|------------|-------------|----------------------|
| **SAFE** | Property has no security implications | None | Pass through unchanged |
| **FILTERED** | Property needs sanitization (remove dangerous values) | Transform before use | Apply filter, use safe subset |
| **BLOCKED** | Property is inherently dangerous | Hard error | Reject with error message |
| **WARN** | Property may be risky but allowed | Log warning | Allow but log, suggest review |

**Execution scope** must be documented per property:
- **Host-machine**: Runs on user's actual host (most dangerous)
- **Sandbox-host**: Runs inside Sysbox container's "host" (already sandboxed)
- **Devcontainer**: Runs inside the nested devcontainer (most isolated)

## Dependencies

- **fn-12-css** (in-progress): Workspace-centric config may affect devcontainer discovery
- **fn-10-vep** (complete): System container infrastructure to build on
- **fn-5-urz** (complete): Security model to maintain compatibility with

## Quick commands

```bash
# View epic status
.flow/bin/flowctl show fn-13-1c7

# List tasks
.flow/bin/flowctl tasks --epic fn-13-1c7

# View devcontainer spec (reference)
# https://containers.dev/implementors/json_reference/

# Pin schema source (for reproducibility)
# https://github.com/devcontainers/spec/tree/main/schemas
```

## Acceptance

- [ ] Property-by-property security classification document with execution scope column
- [ ] At least 3 integration options evaluated with build resolution details
- [ ] Analysis of real-world devcontainer usage with documented methodology
- [ ] Conflict matrix completed with resolution options
- [ ] Clear recommendation with rationale
- [ ] List of follow-up implementation tasks for chosen approach
- [ ] Security implications documented for each option

## References

- [Dev Container Specification](https://containers.dev/implementors/spec/)
- [Dev Container JSON Reference](https://containers.dev/implementors/json_reference/)
- [Dev Container JSON Schema](https://github.com/devcontainers/spec/tree/main/schemas) - pin to specific version
- [devcontainers/cli](https://github.com/devcontainers/cli) - Official CLI
- [loft-sh/devpod](https://github.com/loft-sh/devpod) - Open-source Codespaces alternative
- [coder/envbuilder](https://github.com/coder/envbuilder) - Daemonless devcontainer builds
- [STRML/claude-cells](https://github.com/STRML/claude-cells) - Security tier example
- [Security blog post](https://blog.theredguild.org/where-do-you-run-your-code-part-ii-2/)
