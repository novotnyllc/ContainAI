# Container UX & Templates

## STATUS: PARTIALLY SUPERSEDED

**Templates** -> Superseded by **fn-33-lp4** (User Templates & Customization)
**Container UX** (--container, lookup helper, naming) -> Superseded by **fn-36-rb7** (CLI UX Consistency & Workspace State)
**Shell Completion** -> Superseded by **fn-36-rb7** (task fn-36-rb7.8 and fn-36-rb7.9)

Remaining work: Shell completion (`cai completion bash/zsh`)

---

## Overview

Improve container lifecycle management with auto-creation, consistent parameter handling, custom templates, and shell completion. Remove legacy cai sandbox command.

## Scope

**In scope:**
- cai shell auto-creates/starts container if none exists (partially implemented, needs refinement)
- `--container` parameter for explicit container selection on shell, run, import, export, stop
- Container name completion for existing ContainAI containers
- Custom user image templates via Dockerfiles
- `--template` parameter with autocompletion
- Remove cai sandbox with explicit error handling
- Human-readable container naming (repo-branch format)

**Out of scope:**
- Multi-container orchestration
- Devcontainer integration (fn-13-1c7)
- New `cai exec` subcommand (use `cai docker exec` instead)

## Custom Templates

Users can create custom Dockerfiles in the config directory:
```
${XDG_CONFIG_HOME:-~/.config}/containai/templates/
├── ml-gpu/
│   └── Dockerfile      # FROM containai:latest
├── frontend/
│   └── Dockerfile
└── my-custom/
    └── Dockerfile
```

**Template directory resolution:**
1. `$XDG_CONFIG_HOME/containai/templates/` if XDG_CONFIG_HOME set
2. `~/.config/containai/templates/` otherwise

**Base image requirements:**
- Must use ContainAI base image:
  - `containai:<tag>` (any tag, local image)
  - `ghcr.io/novotnyllc/containai/agents:<tag>` (any tag, remote image)
- The FROM line is validated with strict regex: `^FROM\s+(containai:[a-zA-Z0-9._-]+|ghcr\.io/novotnyllc/containai/agents:[a-zA-Z0-9._-]+)`
- Non-ContainAI base images are rejected with a clear error

**Template build context:**
- Templates MUST be built using the same Docker context selected by `_cai_select_context`
- Example: `docker --context "$selected_context" build ...`
- This ensures template images exist in the correct context (Sysbox vs default)

**Agent selection and templates:**
- Templates use a fixed base image specified in their FROM line
- The FROM line is NOT rewritten based on `--agent` selection
- Users who want different agents should create separate template directories
- This keeps template behavior predictable and debuggable

Usage:
```bash
cai shell --template ml-gpu
cai run --template frontend
```

Template Dockerfile pattern:
```dockerfile
# Must be based on ContainAI image (local or remote)
FROM containai:latest

# User customizations
RUN apt-get update && apt-get install -y cuda-toolkit
```

**Template build caching:**
- Templates are built on first use and tagged as `containai-template-{name}:latest`
- Rebuild triggered if Dockerfile mtime changes or `--rebuild-template` flag passed

## Container Parameter (--container)

The `--container <name>` parameter allows explicit container targeting:

```bash
cai shell --container my-project      # Open shell to specific container
cai run --container my-project        # Create container with specified name
cai import --container my-project     # Import into specific container
cai export --container my-project     # Export from specific container
cai stop --container my-project       # Stop specific container
```

**Semantics by command:**
- `shell --container NAME`: Select existing container by name. Errors if container doesn't exist or isn't ContainAI-managed.
- `run --container NAME`: Creates container with specified name (instead of auto-generated). Errors if name already exists.
- `import --container NAME`: Target specific container. Workspace path and data volume are derived from container labels.
- `export --container NAME`: Export from specific container. Workspace and data volume derived from container labels.
- `stop --container NAME`: Stop the specific named container. Without `--container`, prompts for selection or uses current workspace's container.

**Label-based resolution for import/export:**
When `--container` is specified:
1. Inspect container for `containai.workspace` label → use as workspace path
2. Inspect container for `containai.data-volume` label → use as data volume
3. Error if `containai.workspace` label is missing: `[ERROR] Container NAME is missing workspace label`
4. Error if `containai.data-volume` label is missing: `[ERROR] Container NAME is missing data-volume label`

**Parameter precedence for import/export:**
- If `--container` AND `--workspace` are both provided: Error - mutually exclusive
- If `--container` AND `--data-volume` are both provided: Error - mutually exclusive
- `--container` implies using container labels for both workspace and data volume
- Cannot mix explicit paths with container-based resolution

**Error messages:**
```
[ERROR] --container and --workspace are mutually exclusive
[ERROR] --container and --data-volume are mutually exclusive
[ERROR] Container NAME is missing workspace label
[ERROR] Container NAME is missing data-volume label
```

**Relationship to --name:**
- The existing `--name` parameter is **renamed** to `--container` for workspace commands (shell, run, import, export, stop)
- The `links` command retains `--name` for container name argument (different semantic - specifying name, not selecting)
- No backward compatibility shim for `--name` on commands that now use `--container`
- Update help text and documentation to reflect the change

**Default container selection (when --container not specified):**
1. Workspace label match (`containai.workspace=<resolved-path>`)
2. Auto-generated name from workspace path (new repo-branch format)

## Container Lookup Helper

All commands that need to find a container MUST use a shared lookup helper that searches in this order:
1. Workspace label match: `containai.workspace=<resolved-path>`
2. New naming format: `containai-{repo}-{branch}*`
3. Legacy hash format: `containai-<12-char-hash>` (using existing `_cai_hash_path` logic)

This ensures backward compatibility with existing containers while supporting new naming.

**Function: `_cai_find_workspace_container()`**
```bash
_cai_find_workspace_container() {
    local workspace_path="$1"
    local context="${2:-}"
    local -a docker_cmd=(docker)
    [[ -n "$context" ]] && docker_cmd=(docker --context "$context")

    # 1. Label match (most reliable)
    local -a by_label
    mapfile -t by_label < <("${docker_cmd[@]}" ps -a \
        --filter "label=containai.workspace=$workspace_path" \
        --format '{{.Names}}')

    if [[ ${#by_label[@]} -gt 1 ]]; then
        _cai_error "Multiple containers found for workspace: $workspace_path"
        _cai_error "Containers: ${by_label[*]}"
        _cai_error "Use --container to specify which one"
        return 1
    fi

    if [[ ${#by_label[@]} -eq 1 ]]; then
        printf '%s\n' "${by_label[0]}"
        return 0
    fi

    # 2. New naming format
    local new_name
    new_name=$(_containai_container_name "$workspace_path")
    if "${docker_cmd[@]}" inspect "$new_name" >/dev/null 2>&1; then
        printf '%s\n' "$new_name"
        return 0
    fi

    # 3. Legacy hash format (using existing _cai_hash_path logic)
    local legacy_name
    legacy_name=$(_containai_legacy_container_name "$workspace_path")
    if "${docker_cmd[@]}" inspect "$legacy_name" >/dev/null 2>&1; then
        printf '%s\n' "$legacy_name"
        return 0
    fi

    return 1  # Not found
}
```

**Duplicate container handling:**
- If multiple containers have the same workspace label, `_cai_find_workspace_container` returns error
- User must use `--container NAME` to explicitly select
- This maintains safety and predictability (matching current import behavior)

## Removing cai sandbox

The `cai sandbox` command is removed without backward compatibility.

**Implementation requirements:**
- Remove the `sandbox)` case from the main dispatcher in `containai.sh`
- Add an explicit error handler for unknown subcommands that looks like commands (starts with letter)
- `cai sandbox` must output exactly:
  ```
  [ERROR] Unknown command: sandbox. Run 'cai help' for available commands.
  ```
  (Single line, matching the acceptance criteria exactly)
- This is distinct from `cai /path/to/workspace` which is a valid shorthand for `cai run /path/to/workspace`

**Dispatcher logic:**
```bash
case "$subcommand" in
    # ... known commands ...
    -*)
        # Flags without subcommand go to default run
        _containai_run_cmd "$@"
        ;;
    /*)
        # Absolute path - pass to run
        _containai_run_cmd "$@"
        ;;
    *)
        # Unknown token - error if it looks like a command, else treat as relative path
        if [[ "$subcommand" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]] && [[ ! -d "$subcommand" ]]; then
            _cai_error "Unknown command: $subcommand. Run 'cai help' for available commands."
            return 1
        fi
        # Could be a relative path or existing directory
        _containai_run_cmd "$@"
        ;;
esac
```

## Shell Completion

Tab completion for bash and zsh (fish is optional/stretch goal).

**Completable items:**
- Container names: All containers with `containai.managed=true` label
- Template names: Directory names under the templates directory
- Command options: Standard flags for each subcommand

**Installation mechanism:**
```bash
# Generate completion script
cai completion bash > /etc/bash_completion.d/containai
cai completion zsh > ~/.zsh/completions/_containai

# Or eval directly
eval "$(cai completion bash)"
```

**New `cai completion` subcommand:**
- `cai completion bash` - Output bash completion script
- `cai completion zsh` - Output zsh completion script
- `cai completion fish` - Output fish completion script (optional)

**Container name completion filtering:**
- Only show containers with `containai.managed=true` label
- No workspace filtering (show all ContainAI containers for flexibility)

**Helper function naming convention:**
- Use `_cai_` prefix consistently for internal helpers
- `_cai_list_templates()` - List template names
- `_cai_list_containers()` - List ContainAI container names

## Container Naming (repo-branch format)

Replace hash-based naming with human-readable format.

**Current:** `containai-a1b2c3d4e5f6` (hash of workspace path)
**New:** `containai-{repo}-{branch}` (e.g., `containai-myapp-main`)

**Naming rules:**
- Repo name: Last path component of workspace (or git remote's repo name if available)
- Branch name: From `git branch --show-current` or `git rev-parse --abbrev-ref HEAD`, fallback to "default"
- Sanitize: Replace invalid Docker name chars with `-`, lowercase
- Truncate: Max 64 chars total
- Duplicate handling: Append `-2`, `-3`, etc. if name exists for different workspace

**Legacy naming compatibility:**
- `_containai_legacy_container_name()` MUST use the same logic as existing `_cai_hash_path`
- This includes: path normalization, trailing slash handling, sha256sum/shasum/openssl fallback
- Do NOT reimplement the hash algorithm - wrap the existing function

**Migration path:**
- New naming applies to newly created containers only
- Existing hash-named containers continue to work via the shared lookup helper
- Container lookup order: (1) workspace label match, (2) new naming format, (3) legacy hash format
- No automatic migration (document manual migration if desired)

## Quick Commands

```bash
# Test auto-create
cai shell  # Should create if none exists

# Test template
cai shell --template ml-gpu

# Test container override
cai shell --container my-test

# List templates
ls ${XDG_CONFIG_HOME:-~/.config}/containai/templates/

# Generate completions
cai completion bash
```

## Acceptance

- [ ] cai shell auto-creates container if none exists
- [ ] cai shell auto-starts stopped container (already implemented in _cai_ssh_shell)
- [ ] --container parameter works on shell, run, import, export, stop
- [ ] import/export with --container derives workspace/volume from container labels
- [ ] --container mutually exclusive with --workspace/--data-volume (error if both)
- [ ] Error if container missing workspace or data-volume labels
- [ ] Default container derived from workspace label or auto-generated name
- [ ] Multiple containers for same workspace: error with list, require --container
- [ ] Custom templates read from XDG_CONFIG_HOME/containai/templates/
- [ ] --template parameter builds from user Dockerfile with strict base image validation
- [ ] Template builds use correct Docker context (from _cai_select_context)
- [ ] `cai completion bash` and `cai completion zsh` generate working scripts
- [ ] Template autocompletion works (bash, zsh)
- [ ] Container name autocompletion works
- [ ] `cai sandbox` outputs single-line error: "[ERROR] Unknown command: sandbox. Run 'cai help' for available commands."
- [ ] Unknown alpha-numeric subcommands error (not fallthrough to run)
- [ ] --name removed on shell/run/import/export/stop; links retains --name
- [ ] Container naming uses repo-branch format for new containers
- [ ] Legacy hash lookup uses existing _cai_hash_path logic (not reimplemented)
- [ ] Existing hash-named containers discoverable via shared lookup helper
- [ ] All commands use `_cai_find_workspace_container()` for container discovery

## References

- Workspace state: fn-12-css
- Bash completion: https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html
- Zsh completion: https://zsh.sourceforge.io/Doc/Release/Completion-System.html
- XDG Base Directory: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html

## Dependencies

- **fn-17-axl**: Auth flow improvements (must complete first)
