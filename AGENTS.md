# ContainAI Repository

This file contains repository-specific guidance for working with the ContainAI codebase.

# Required Tools and Workflows

## Always Use These MCP Tools

1. **Serena** - For semantic code retrieval and editing
   - Use for understanding code structure and relationships
   - Use for targeted code modifications
   - Provides symbol-level navigation and editing

2. **Context7** - For up-to-date third-party documentation
   - Use when working with external libraries or frameworks
   - Ensures you have current API references
   - Helps avoid deprecated patterns

3. **Sequential Thinking** - For decision making
   - Use for complex problem-solving
   - Break down multi-step tasks
   - Validate assumptions before implementing

## Repository Structure

- `agent-configs/` - Custom instruction files for agents (copied to containers)
- `docker/` - Container definitions and compose configurations
- `host/profiles/` - **Security profiles (AppArmor + seccomp)
- `host/launchers/` - Agent launcher scripts
- `host/utils/` - Shared bash utilities (common-functions.sh)
- `scripts/` - Utility scripts (bash plus thin Windows shims)
- `config.toml` - MCP server configuration template
- `docs/` - Documentation

## Security Profile Management

### Profile Locations
- **Source files**: `host/profiles/` (in git, NO channel suffix)
- **Installed files**: `/opt/containai/profiles/` (with `-dev` or `-prod` suffix)

### Profile Naming Convention
- Source: `apparmor-containai-proxy.profile`, `seccomp-containai-proxy.json`
- Installed: `apparmor-containai-proxy-dev.profile`, `seccomp-containai-proxy-dev.json`

### Installation Workflow
The setup script handles copying, renaming, and loading profiles:
```bash
sudo ./scripts/setup-local-dev.sh
```

This script:
1. Copies profiles from `host/profiles/` to `/opt/containai/profiles/`
2. Renames files to add channel suffix (`-dev`)
3. Updates internal profile names (e.g., `containai-proxy` → `containai-proxy-dev`)
4. Loads AppArmor profiles into the kernel via `apparmor_parser`

### Common Mistakes to Avoid
- ❌ NEVER add channel suffix (`-dev`, `-prod`) to source files in `host/profiles/`
- ❌ NEVER edit installed profiles directly in `/opt/containai/profiles/`
- ✅ ALWAYS edit source files in `host/profiles/`, then run setup script

### Adding New Syscalls
When container startup fails with seccomp violations:
1. Check container logs for blocked syscall names
2. Add syscalls to the appropriate `host/profiles/seccomp-*.json` allow list
3. Run `sudo ./scripts/setup-local-dev.sh` to reinstall
4. Rebuild the affected container image if needed

### AppArmor Profile Loading Verification
AppArmor profiles are loaded into the kernel and can be verified via `/sys/kernel/security/apparmor/profiles`.
**Note**: Reading this file requires `CAP_SYS_ADMIN` (effectively root), even though it shows `r--r--r--` permissions.

When running as non-root:
- The launcher trusts that if profile FILES exist in `/opt/containai/profiles/`, they were loaded by the setup script
- To manually verify profiles are loaded: `sudo cat /sys/kernel/security/apparmor/profiles | grep containai`
- To reload a profile: `sudo apparmor_parser -r /opt/containai/profiles/apparmor-containai-*-dev.profile`

### Seccomp Profile Updates
The seccomp profiles whitelist specific syscalls. When updating:
- Modern container runtimes (runc, containerd) require syscalls like `clone3`, `close_range`, `faccessat2`, `openat2`, `rseq`, `statx`
- These are NOT optional - containers will fail to start without them
- The `deny` list provides defense-in-depth for dangerous syscalls (mount, pivot_root, etc.)
- Always test profile changes with `--mode launchers` before running full integration tests

## MITM CA Architecture

The proxy container performs TLS interception (MITM) to inspect traffic. The CA certificate must be generated by the **launcher**, not auto-generated inside the container.

### Why Launcher-Generated CA is Required
1. **Trust Chain**: The agent container needs to trust the CA certificate
2. **Security**: Auto-generated certs inside proxy would be untrusted by agents
3. **Distribution**: Launcher generates once, distributes to both proxy AND agent containers

### CA File Requirements
- **Format**: Traditional RSA PEM (`-----BEGIN RSA PRIVATE KEY-----`), NOT PKCS#8
- **Key Ownership**: `root:proxy` with mode `640` (root validates, proxy runs squid)
- **Cert Ownership**: Can be world-readable

### Key Format Conversion
Squid 5.7+ requires traditional RSA format. If using OpenSSL 3.x, convert:
```bash
openssl rsa -in key.pem -out key.pem -traditional
```

### Common Mistakes to Avoid
- ❌ NEVER auto-generate CA inside proxy container (breaks trust chain)
- ❌ NEVER use PKCS#8 format keys (`-----BEGIN PRIVATE KEY-----`)
- ❌ NEVER chown key to `proxy:proxy` with 600 (root can't validate without CAP_DAC_READ_SEARCH)
- ✅ ALWAYS generate CA in launcher via `generate_session_mitm_ca`
- ✅ ALWAYS use traditional RSA format for keys
- ✅ ALWAYS use `root:proxy` ownership with mode 640 for keys

## Docker Disk Space Management

**CRITICAL**: Docker images, volumes, and build cache can quickly consume 100+ GB during development.

### Cleanup Commands
```bash
# Check disk usage
docker system df

# Aggressive cleanup (removes ALL unused resources)
docker system prune -af --volumes && docker builder prune -af

# Less aggressive (keeps recent images)
docker system prune -f
```

### Best Practices
- Run `docker system df` before and after test runs
- The integration test harness cleans up test containers/networks but NOT images or build cache
- After iterating on Dockerfiles, build cache grows rapidly - prune periodically
- Monitor with: `df -h /` to catch disk usage before it becomes critical

### Automated Cleanup
Consider adding to your shell profile:
```bash
# Warn if Docker is using more than 50GB
docker_usage=$(docker system df --format '{{.Size}}' | head -1)
# Add your own threshold check here
```

## Key Principles

1. **Canonical Bash** - Bash implementations are the source of truth. Windows `.ps1` wrappers simply delegate into WSL and must stay in sync with their bash counterparts.
2. **Test Coverage** - All functions must have comprehensive unit tests
3. **Shim Quality** - Windows shims should perform only WSL validation/path translation and must not fork business logic
4. **Fail-Closed Security** - Security controls (user switching, seccomp, capabilities) must never fail open. If a security primitive cannot be established, the process must exit immediately. No silent fallbacks to insecure states.
5. **Dependency Management** - Regularly check for and update dependencies (Docker base images, system packages, NuGet packages, Rust crates, npm packages) to the latest stable versions to absorb bug fixes and security updates.
6. **Documentation** - Keep CONTRIBUTING.md `docs/` updated with workflow changes

## Coding Conventions 

- **Windows shims**: `host/utils/wsl-shim.ps1` handles WSL detection and path conversion. Keep individual `.ps1` entrypoints minimal—dot-source the shim, pass arguments through, and propagate exit codes.
- **Bash**: Use `set -euo pipefail`, quote variables, prefer POSIX-friendly syntax unless Bash-only needed.
- **Shared Behavior**: Fixes belong in bash. After updating a bash workflow, regenerate or adjust the corresponding shim (if any) plus its tests so Windows callers still reach the new logic.
- **Tests First-Class**: Whenever you change branch/remote handling or setup scripts, update both bash and PowerShell launcher tests plus integration tests to reflect the new guarantees.

## Agent Configuration

Custom instructions for AI agents are stored in `agent-configs/`

These files are automatically copied to containers and applied per agent.

## Development Workflow

See `CONTRIBUTING.md` for detailed development guidelines including:
- Test suite usage
- Inner loop development process
- Code quality standards
- Debugging techniques

### Integration Test Expectations

- **Build time**: A full rebuild (`integration-test.sh --mode full`) takes 15-25 minutes because every agent image is rebuilt. Launchers mode (`--mode launchers`) uses mock images and completes in 5-10 minutes. Plan your CI and local workflows accordingly.
- **Resource isolation**: Integration tests use session-scoped labels (`containai.test.session=<ID>`) to track all created resources. The harness automatically cleans up test containers, networks, and volumes on exit. Orphaned resources older than 24 hours are also pruned at startup.

### CI Verification Standards

All code changes must pass the following automated checks in the CI pipeline:

1.  **Static Analysis**:
    - **Bash**: `shellcheck` must pass for all `.sh` scripts.
    - **Python**: `pylint` and `mypy` must pass for all host utility scripts.
    - **Rust**: `cargo clippy` must pass with no warnings.

2.  **Unit Tests**:
    - **C#**: All `.Tests` projects must pass (`dotnet test`).
    - **Rust**: All crates must pass `cargo test`.
    - **Bash**: Launcher logic must pass `scripts/test/test-launchers.sh`.

3.  **Integration Tests**:
    - Changes to launchers or core runtime must pass `scripts/test/integration-test.sh`.

